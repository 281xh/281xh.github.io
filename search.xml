<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree lc538]]></title>
    <url>%2F2019%2F08%2F14%2F20190814-lc538%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / 2 13 Output: The root of a Greater Tree like this: 18 / 20 13 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree python3–lastOrder递归1234567891011121314151617= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: count=0; def convertBST(self, root: TreeNode) -&gt; TreeNode: if root: root.right=self.convertBST(root.right); root.val=root.val+self.count; self.count=root.val; root.left=self.convertBST(root.left); return root; return None; java–lastOrder非递归12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int count=0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack(); //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考 TreeNode node=root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.add(node); node=node.right; &#125; node=stack.pop(); node.val+=count; count=node.val; if(node.left!=null) node=node.left; else node=null; &#125; return root; &#125;&#125; 总结本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求众数 lc169]]></title>
    <url>%2F2019%2F08%2F07%2F20190807-lc169%2F</url>
    <content type="text"><![CDATA[题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element java–sort+map+摩尔投票法sort后一次遍历处理，时间复杂度O(NlogN)12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; //if(nums==null)return 0;题目保证不会出现的情况 if(nums.length==1)return nums[0]; int count=1; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i++) &#123; if(nums[i]==nums[i+1]) count++; else &#123; if(count&gt;nums.length/2) return nums[i]; else count=1; &#125; &#125; return count&gt;nums.length/2?nums[nums.length-1]:0; &#125;&#125; map一次遍历存储后输出即可，时间复杂度O(N)123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int x:nums)&#123; if(map.containsKey(x)) map.put(x,map.get(x)+1); else map.put(x,1); &#125; for(int x:map.keySet())//keySet方法返回key的集合set if(map.get(x)&gt;nums.length/2) return x; return 0; &#125;&#125; 摩尔投票法O(N)1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int maj = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (maj == nums[i]) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; &#125; return maj; &#125;&#125; python本题投机取巧法（如果有唯一众数，那一定是排序后的中位数） 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2]; 总结本题是leetcode中的简单难度题，只是求解的话比较容易。 但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好 而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pow(x,n) lc50]]></title>
    <url>%2F2019%2F08%2F06%2F20190806-lc50%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000 示例 2:输入: 2.10000, 3输出: 9.26100 示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n java–非递归分治循环123456789101112class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i=i/2) &#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; python–递归123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x, n = 1/x, -n; if not n: #recursion termination return 1; if n % 2: return x*self.myPow(x, n-1); return self.myPow(x*x, n/2); 总结本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。需要注意的有两点：一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n = 1/x, -n」比较方便。二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。tip：注意递归写法的重要习惯————递归终止语句]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯理解+实例]]></title>
    <url>%2F2019%2F08%2F05%2F20190805%2F</url>
    <content type="text"><![CDATA[什么是贝叶斯英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。 在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2/10）而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。 贝叶斯案例有两个一模一样的碗1号碗里有：30个巧克力和10个水果糖2号碗里有：20个巧克力和20个水果糖然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率） 第1步，分解问题1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？来自1号碗记为事件A1，来自2号碗记为事件A2取出的是巧克力，记为事件B，那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率 2）已知信息：1号碗里有30个巧克力和10个水果糖2号碗里有20个巧克力和20个水果糖取出的是巧克力 第2步，应用贝叶斯定理1）求先验概率由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)=P(A2)=0.5,(其中A1表示来自1号碗，A2表示来自2号碗)这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。 2）求可能性函数P(B|A1)/P(B)其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)=30/(30+10)=75%P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)=0.75*0.5+20/(20+20)*0.5=62.5%所以，可能性函数P(A1|B)/P(B)=75%/62.5%=1.2可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。 3）带入贝叶斯公式求后验概率将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)=60%这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
