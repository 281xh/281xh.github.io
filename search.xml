<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[固定和的元素对-T2.6]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-6%2F</url>
    <content type="text"><![CDATA[Description输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，统计这样两个数的对数。 Input输入第一行为用例个数， 每个测试用例输入第一行是数组，每一个数用空格隔开；第二行是数字和。 Output输出这样两个数有几对。 SampleSample Input 111 2 4 7 11 0 9 1511 Sample Input 23 java1234567891011121314151617181920212223242526272829303132333435import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a; a = scan.nextInt(); scan.nextLine(); while(a&gt;0)&#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int num=0; a--; String[] s = scan.nextLine().split(" "); int[] group = new int[s.length]; for(int j=0;j&lt;s.length;j++)&#123; group[j] = Integer.parseInt(s[j]); &#125; int b = scan.nextInt(); scan.nextLine(); for(int k = 0 ; k &lt; group.length ; k++)&#123; if(map.get(group[k])==null)&#123; map.put(b-group[k],group[k]); &#125; else&#123; num++; &#125; &#125; System.out.println(num); &#125; scan.close(); &#125;&#125; 总结&amp;思路lc原题，可以蛮力法简单粗暴，想要比较好的时间复杂度就用1、双指针法。2、借用map。原题就不多赘述了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间第k最小-T2.5]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-5%2F</url>
    <content type="text"><![CDATA[Description找到给定数组的给定区间内的第K小的数值。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个数用空格隔开；第二行是区间（第几个数到第几个数，两头均包含），两个值用空格隔开；第三行为K值。 Output结果。 SampleSample Input 111 2 3 4 5 6 73 52 Sample Input 24 java12345678910111213141516171819202122232425262728293031323334353637import java.util.*;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int start = scan.nextInt(); int end = scan.nextInt(); scan.nextLine(); //int k = scan.nextInt(); //scan.nextLine(); //String[] num2 = scan.nextLine().split(" "); //int start = Integer.parseInt(num2[0]); //int end = Integer.parseInt(num2[1]); int k = Integer.parseInt(scan.nextLine()); System.out.println(Run(num,start-1,end-1,k)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int Run(int[] num, int start, int end, int k)&#123; int[] n = new int[end-start+1]; for(int i=start;i&lt;=end;i++) n[i-start]=num[i]; Arrays.sort(n); return n[k-1]; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔-T2.4]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-4%2F</url>
    <content type="text"><![CDATA[Description汉诺塔问题中限制不能将一层塔直接从最左侧移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间。求当有N层塔的时候移动步数。 Input输入第一行为用例个数， 每个测试用例输入的第一行为N。 Output移动步数。 SampleSample Input 112 Sample Input 28 java12345678910111213141516171819import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; int num = Integer.parseInt(scan.nextLine()); System.out.println(hanoi(num)); &#125; scan.close(); &#125; static int hanoi(int n)&#123; if(n == 1) return 2; else return hanoi(n-1)*3+2; &#125;&#125; 总结&amp;思路题目描述其实不太准确，给出的sample的要求其实不太一样，但是也不是很困难。 当筹码只有一个的时候需要移动两次，而n个筹码移动的次数N(n)=N(n-1)*3+2： 即先将n-1个筹码放到最右边–将第n个筹码放到中间–将n-1个筹码放到最左边–将第n个筹码放到最右边–将n-1个筹码放到最右边。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和窗口-T2.3]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-3%2F</url>
    <content type="text"><![CDATA[Description给定一个整型数组arr和一个大小为w的窗口，窗口从数组最左边滑动到最右边，每次向右滑动一个位置，求出每一次滑动时窗口内最大元素的和。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个元素使用空格隔开；第二行为窗口大小。 Output输出每个测试用例结果。 SampleSample Input 114 3 5 4 3 3 6 73 Sample Input 232 java123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int win = Integer.parseInt(scan.nextLine()); System.out.println(countWin(num,win)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int countWin(int[] num,int win)&#123; int res = 0; for(int i=0;i&lt;num.length-win+1;i++) res+=max(num,i,win+i-1); return res; &#125; static int max(int[] num,int start,int end)&#123; int res = Integer.MIN_VALUE; for(int i=start;i&lt;=end;i++) if(res&lt;num[i]) res = num[i]; return res; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子矩阵问题-T2.2]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-2%2F</url>
    <content type="text"><![CDATA[Description给定一个矩形区域，每一个位置上都是1或0，求该矩阵中每一个位置上都是1的最大子矩形区域中的1的个数。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为矩阵行数n和列数m，下面的n行每一行是用空格隔开的0或1。 Output输出一个值。 SampleSample Input 113 41 0 1 11 1 1 11 1 1 0 Sample Input 26 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;class T2&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = scan.nextInt(); for(int i = 0;i &lt; count; i++)&#123; scan.nextLine();//pass the /0 String[] two = scan.nextLine().split(" "); int n = Integer.parseInt(two[0]); int m = Integer.parseInt(two[1]); int[][] matrix = new int[n][m]; for(int k1=0;k1&lt;n;k1++) for(int k2=0;k2&lt;m;k2++) matrix[k1][k2] = scan.nextInt(); System.out.println(Deal(matrix)); &#125; scan.close(); &#125; //deal with the matrix and produce arrays to deal static int Deal(int[][] matrix)&#123; if(matrix == null||matrix.length == 0||matrix[0].length == 0) return 0; int res = 0; int[] arr = new int[matrix[0].length]; for(int i=0;i&lt;matrix.length;i++)&#123; for(int j=0;j&lt;matrix[0].length;j++) arr[j] = (matrix[i][j]==0?0:arr[j]+1); res = Math.max(res, dealArra(arr)); &#125; return res; &#125; //deal with the arr and return the max area static int dealArra(int[] arr)&#123; if(arr == null||arr.length == 0) return 0; int maxArea = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;arr.length;i++)&#123; while(!stack.empty()&amp;&amp;arr[i]&lt;arr[stack.peek()])&#123; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (i-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; stack.push(i); &#125; while(!stack.isEmpty())&#123; // while the arr is finished int right = arr.length; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (right-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; return maxArea; &#125;&#125; 总结&amp;思路解决这题需要先了解直方图最大面积的求法初次理解花了比较多时间，说起来比较复杂就留个连接：https://www.cnblogs.com/CodeCafe/p/7634233.html 了解做法以后只要将矩阵读入成int[][]后每次读一行，并将那一行的数值当作一个直方图进行处理得出一个最大值存储起来 然后每次读下一行（需要通过上一行的值进行更新），又作为直方图得到一个最大值，并和之前存储的最大值进行比较留较大的。 循环遍历矩阵的每一行后最后留下的值就是最大值。 本题难度主要在直方图最大面积的理解，并通过辅助Stack进行代码层次的实现。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子数组的取值范围-T2.1]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-1%2F</url>
    <content type="text"><![CDATA[Description给定数组arr和整数num，求arr的连续子数组中满足：其最大值减去最小值的结果大于num的个数。请实现一个时间复杂度为O(length(arr))的算法。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为数组，每一个数用空格隔开，第二行为num。 Output输出一个值。 SampleSample Input 113 6 4 3 22 Sample Input 26 java123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int i=0;i&lt;count;i++)&#123; int res = 0,p = 0,q = 1; String[] num = scan.nextLine().split(" "); int target = Integer.parseInt(scan.nextLine()); while(p!=num.length&amp;&amp;q!=num.length)&#123; if(p==q)&#123; q++; continue; &#125; int c = run(num,p,q); if(c&gt;target)&#123; res+=num.length-q; p++; continue; &#125; else&#123; q++; continue; &#125; &#125; System.out.println(res); &#125; scan.close(); &#125; public static int run(String[] num, int p, int q)&#123; int max=Integer.parseInt(num[p]),min=Integer.parseInt(num[p]); for(int i=p;i&lt;=q;i++)&#123; int t = Integer.parseInt(num[i]); if(t&gt;max) max=t; if(t&lt;min) min=t; &#125; return max-min; &#125;&#125; 总结&amp;思路做法是滑动窗口一次遍历数组做到时间复杂度O(N)，具体做法如下： 用两个指针l, r确定窗口边界，初始窗口大小为2只包含数组的前两位，然后对每次窗口做如下判断 1、如果窗口内的最大数-最小数&gt;num，则包含当前窗口的所有窗口必然满足条件，count += arr.length-count，然后l指针向右移一位； 2、如果窗口内的最大数-最小数&lt;num，则当前窗口不满足要求，指针l向右移一位扩大窗口后再进行判断； 3、注意窗口大小一定要&gt;=2，所以要处理l,r重合的情况； 高级算法课的课后练习和平时刷lc有较大差别，不止要想出解决的做法，还要处理好输入输出，之前一味刷lc忽略了输入输出的处理导致一开始做题真的很难受，nextInt() nextLine()换行符问题都困扰了一段时间。自己写完整程序时也要多考虑合理的模块化，方便错误定位和代码清晰性。还是要多多学习，多多练习。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据身高重建队列-lc406]]></title>
    <url>%2F2019%2F10%2F14%2F20191014-lc406%2F</url>
    <content type="text"><![CDATA[题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height 思路&amp;实现本题题目逻辑没有很清楚，需要了解到最终的排序要求是对于每个身处最终位置的人，他前面有且仅有k个h大于他的人。 我们用排序思路理清我们要做的就是，首先将所有人按照1、身高顺序降序排序2、身高相同则k升序排序3、遍历排序后的数组，根据K插入到K的位置上 核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求 在代码实现方面，使用java的比较器实现，并用匿名函数Lambda表达式优化代码结构，以下是实现降序排序的比较器Comparator的使用方法（Collections.reverseOrder()的实现） 1234567891011public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2)&#123; return o2-o1; &#125; &#125;); for(int x:num) System.out.println(x); &#125; 然后是使用Lambda表达式优化后的做法 123456public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,(o1,o2)-&gt;o2-o1); for(int x:num) System.out.println(x); &#125; 可以看到代码大大简化，可读性提升。 java比较器传统实现 1234567891011121314class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0]? o1[1]-o2[1]:o2[0]-o1[0]; &#125; &#125;); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; Lambda实现 123456789class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,(o1,o2)-&gt;o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; python3-Lambda1234567class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key = lambda x: [-x[0], x[1]]) res = [] for p in people: res.insert(p[1], p) return res 总结本题是一道lc中等难度题,题目要求转换成解法比较绕弯不易想到，而且比较器和Lambda函数对我来说算是新知识了，花了些时间学习了一下，比较有收获，需要注意的是，Lambda表达式虽然可以优化代码结构，但是运行速度在lc编译器中显示没有传统比较器实现来的快。 java比较器使用： 1234567Arrays.sort(object o,new Comparator&lt;sonDataType&gt;()&#123; @Override public sonDataType compare(sonDataType o1, sonDataType o2)&#123; //排序顺序o1-o2为升序，o2-o1为降序 return o1-o2; &#125;&#125;); java Lambda表达式用法： 12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); python3 Lambda表达式用法： 12345//按照people中的子list的第二个元素大小升序排序people.sort(key=Lambda x:x[1])//按照people中的子list的第一个元素的大小降序排序，第一个元素同样大的情况下按照第二个元素大小升序排序people.sort(key=Lambda x:[-x[0],x[1]])]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序链表-lc148]]></title>
    <url>%2F2019%2F10%2F07%2F20191007-lc148%2F</url>
    <content type="text"><![CDATA[题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-list 思路&amp;实现题目要求逻辑很清晰，其实就是基于链表的排序，主要是限制了时间复杂度，再加上链表的特性，限制了排序方法的选择，这里我觉得用归并排序的方法解决这个题比较容易。 java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head == null||head.next == null) return head; ListNode left = head; ListNode right = head.next; while(right!=null&amp;&amp;right.next!=null)&#123; left = left.next; right = right.next.next; &#125; ListNode tmp = left.next; left.next = null;//以中点断开链表以免相互影响 left = sortList(head); right = sortList(tmp); ListNode dummy = new ListNode(-1); ListNode res = dummy; while(left!=null&amp;&amp;right!=null)&#123; if(left.val &gt; right.val)&#123; dummy.next = right; right = right.next; &#125;else&#123; dummy.next = left; left = left.next; &#125; dummy = dummy.next; &#125; dummy.next = left!=null?left:right; return res.next; &#125;&#125; python31234567891011121314151617181920class Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head left, right = head, head.next while right and right.next: left, right = left.next, right.next.next tmp ,left.next = left.next, None left, right = self.sortList(head), self.sortList(tmp) m = res = ListNode(-1) while left and right: if left.val &lt; right.val: m.next = left left = left.next else: m.next = right right = right.next m = m.next m.next = left if left else right return res.next 总结本题是一道lc中等难度题，主要考察限制条件的sort算法，使用归并递归的方式比较好解决，但是这样会使用一些额外空间，如果想要使得空间复杂度保持O(1)，那么就需要用到非递归的归并算法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除自身以外数组的乘积-238]]></title>
    <url>%2F2019%2F09%2F25%2F20190925-238%2F</url>
    <content type="text"><![CDATA[题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self 思路&amp;实现题目其实比较简单，直观的第一想法应该是先将nums数组的元素总乘机求出然后遍历一遍数组，每个元素都对总乘机做一次除法即可。时间复杂度为O(N)但是题目要求限制使用除法，并且要求相同的复杂度。题目使坏导致我们没法那么舒适的做出这道题但是其实也可以用乘法思路解决。 对于res数组的每个元素都可以将他看成是 [该元素左边所有元素的乘积]*[该元素右边所有元素的乘积] 所以我们可以采用两次循环遍历解决这个题第一遍循环遍历解决所有左边元素的乘积（因为可以累乘所以这并不难）第二便循环遍历解决所有右边元素的乘积（相同思路） java1234567891011121314151617class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; int k = 1; for(int i = 0; i &lt; nums.length; i++)&#123; res[i] = k; k *= nums[i]; &#125; k = 1; for(int i = nums.length-1; i &gt;= 0; i--)&#123; res[i] *= k; k *= nums[i]; &#125; return res; &#125;&#125; python312345678910class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: res, k, k1 = [1]*len(nums), 1, 1 for i in range(len(nums)): res[i] *= k k *= nums[i] for i in range(len(nums)-1, -1, -1): res[i] *= k1 k1 *= nums[i] return res 总结本题是一道lc中等难度题，主要考察对线性表的基本数据操作，通过限制条件加大难度，思路理清后较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树展开为链表-lc114]]></title>
    <url>%2F2019%2F09%2F23%2F20190923-lc114%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / 2 5 / \ 3 4 6将其展开为： 1 2 3 4 5 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list 思路看题目以及给的例子可以看出题目要求，即将一颗二叉树的全部节点都放置到顺序的右子树，左子树为空。形似一根单链表。 有这样的思路步骤：1、将二叉树的右子树暂存起来，记为y2、将二叉树的左子树移到右子树位置，然后遍历现在这棵树的右节点直到尽头，然后将y接在后面3、递归处理所有的右子节点 java12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null) return; TreeNode temp = root.right; root.right = root.left; root.left = null; TreeNode t = root; while(t.right != null) t = t.right; t.right = temp; flatten(root.right); &#125;&#125; python312345678910111213141516171819\# Definition for a binary tree node.\# class TreeNode:\# def __init__(self, x):\# self.val = x\# self.left = None\# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return t1, t2 = root.right, root root.right, root.left = root.left, None while t2.right: t2 = t2.right t2.right = t1 self.flatten(root.right) 总结本题是一道lc中等难度题，主要考察二叉树的处理结合递归操作，思路清晰后代码实现比较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特位计数-lc338]]></title>
    <url>%2F2019%2F09%2F18%2F20190918-lc338%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2输出: [0,1,1]示例 2: 输入: 5输出: [0,1,1,2,1,2]进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits java python3–位运算&amp;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++)//要从1开始，第0位在数组初始化时default值为0满足要求 res[i] = res[i &amp; (i - 1)] + 1; return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0]*(num+1) for i in range(1, num+1): res[i] = res[i&amp;(i-1)] + 1 return res 这种做法运用了位运算符 a&amp;b————两个数a b都转换成二进制编码进行位比较，当且仅当两位同时为1则该位结果为1，否则为0。 技巧在于i &amp; (i-1)这个操作可以去掉i的二进制编码的最右边的一个1（被-1后的数二进制表现为最右边的1右移一位，而不影响其他1位），因此（1）i &amp; (i-1)的结果十进制数的1的个数+1就是我们要的结果。（2）i &amp; (i-1)由于最右边一位1被去掉了十进制数大小要比i小，所以已经被我们在前面计算过了并存储在了结果数组中。（3）通过这种做法不断迭代计算后面的值即可。 java python3–位运算&gt;&gt;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++) res[i] = res[i&gt;&gt;1] + (i&amp;1);//注意括号一定要，&amp;和加减乘除的优先级是一样的 return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0] for i in range(1, num+1): res.append(res[i&gt;&gt;1] + (i&amp;1)) return res 这种做法运用了位运算符 a&gt;&gt;b————将十进制数a的二进制形式右移b位（最右边b位去掉），然后返回处理后的二进制数的十进制结果。 技巧在于 i&gt;&gt;1 这个操作可以去掉i的二进制编码的最右边一位（不管是0还是1），因此（1）i&gt;&gt;1的结果（十进制）一定比i小，所以i&gt;&gt;1的1的个数的值已经被我们在前面计算过了并存储在了结果数组中。（2）如果被去掉的最后一位是0，那么我们要的值就是res[i&gt;&gt;1]； 如果是1，那么我们要的值就是res[i&gt;&gt;1]+1. 综合一下就是res[i&gt;&gt;1]+(1&amp;i)不是吗(3)通过这种做法不断迭代计算后面的值即可。 总结本题是lc中等难度的一道题，禁止使用java或是python中基本库包含的直接计数函数，考察的是对二进制以及位运算方面的知识，当然也可以将十进制数化成二进制以后再操作而不是用位运算，简单粗暴但是这样的话代码会复杂很多而且十分不优雅，所以还是要好好学习下如何用位运算来处理这样的题。在lc评论区学习一番之后总结了两种代码比较优雅时间复杂度也比较优秀的做法。 附上位运算的一些基础介绍，以后忘了可以回来看看（java,python3的位运算符用法相同）]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集-lc78]]></title>
    <url>%2F2019%2F09%2F16%2F20190916-lc78%2F</url>
    <content type="text"><![CDATA[题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subsets java–迭代123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); res.add(new ArrayList()); for(int i = 0; i &lt; nums.length; i++)&#123; int count = res.size();//记录下当前res的长度，否则res空间跟着程序变化就会死循环 for(int j = 0; j &lt; count; j++)&#123; List&lt;Integer&gt; temp = new ArrayList(res.get(j)); temp.add(nums[i]); res.add(temp); &#125; &#125; return res; &#125;&#125; 程序思路是一开始创建一个[[]]，然后针对nums中的每个元素（以nums[0] = 1为例）进行：1、取出res中的每个子list–[]2、加上nums[0] = 1–[1]3、将这个新list加入到res中–res = [[],[1]]4、以此类推遍历nums中的所有元素 java–回溯123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); back(res, 0, nums, new ArrayList()); return res; &#125; public void back(List&lt;List&lt;Integer&gt;&gt; res, int n, int[] nums, List&lt;Integer&gt; temp)&#123; res.add(temp); for(int i = n; i &lt; nums.length; i++)&#123; List&lt;Integer&gt; t = new ArrayList(temp);//基础类型所以可以做到深拷贝 t.add(nums[i]); back(res, i+1, nums, t); &#125; &#125;&#125; python3–迭代12345678class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: count = len(res) for j in range(count): res.append([i]+res[j]) return res 123456class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: res = res + [[i] + num for num in res] return res 总结本题是一道lc中等难度题，主要学习了回溯和迭代两种做法，其中回溯法只要想像出递归树那么就能解决，主要注意的是避免因为细节问题出现重复项或多余项；迭代法思路比较巧妙，每次都在前一次迭代的基础上添加一个新元素，直到nums遍历完成。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到字符串中所有字母异位词-lc438]]></title>
    <url>%2F2019%2F09%2F11%2F20190911-lc438%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。不考虑答案输出的顺序。示例 1: 输入:s: “cbaebabacd” p: “abc” 输出:[0, 6] 解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。 示例 2: 输入:s: “abab” p: “ab” 输出:[0, 1, 2] 解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string java–滑动窗口123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res=new ArrayList(); if(s.length()==0||s.length()&lt;p.length()) return res; int[] pnum=new int[26]; int[] snum=new int[26]; for(char c:p.toCharArray()) pnum[c-'a']++; for(int i=0; i&lt;p.length()-1; i++) snum[s.charAt(i)-'a']++; for(int i=p.length()-1; i&lt;s.length(); i++)&#123; snum[s.charAt(i)-'a']++; if(Arrays.equals(pnum, snum)) res.add(i-p.length()+1); snum[s.charAt(i-p.length()+1)-'a']--; &#125; return res; &#125;&#125; python3–滑动窗口123456789101112131415161718class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: if len(s) &lt; len(p): return [] Num = [] n = len(p) A = [0] * 26 for i in range(n): A[ord(p[i]) - ord('a')] += 1 A[ord(s[i]) - ord('a')] -= 1 if A == [0] * 26: Num.append(0) for i in range(n, len(s)): A[ord(s[i]) - ord('a')] -= 1 A[ord(s[i - n]) - ord('a')] += 1 if A == [0] * 26: Num.append(i + 1 - n) return Num ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。实例如下 12345&gt;&gt;&gt;ord('a')97&gt;&gt;&gt; ord('€')8364&gt;&gt;&gt; 总结又是一道扮猪吃老虎的简单题，如果对于滑动窗口的使用不够熟练，那么这个题是有些难度的，我在空闲时间想刷一下简单题一下子就卡住了，花了些时间搞懂了滑动窗口逻辑处理的方式就很简单了。这题主要在于在窗口的移动中要维护好窗口，并且每次移动窗口都进行判断是否配对。python3和java是两种做法，但是都是基于的滑动窗口的维护，刚好可以帮助我们更好的多角度的掌握滑动窗口的使用。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Level Order Traversal-lc102]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc102%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / 9 20 / 15 7返回其层次遍历结果： [ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal java–BFS123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); if(root == null) return res; Queue&lt;TreeNode&gt; queue=new LinkedList(); queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); List&lt;Integer&gt; temp = new ArrayList(); for(int i=0;i&lt;len;i++)&#123; TreeNode t = queue.poll(); temp.add(t.val); if(t.left!=null) queue.add(t.left); if(t.right!=null) queue.add(t.right); &#125; res.add(temp); &#125; return res; &#125;&#125; python3–BFS1234567891011121314151617181920212223242526272829= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result=[] queue=collections.deque() queue.append(root) \#visited=set(root) 在二叉树的层序遍历中可省，但是在图中这句是必须的，否则会访问重复的节点 while queue: level_size=len(queue) cur_level=[] for _ in range(level_size): node = queue.popleft() cur_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(cur_level) return result python3–DFS123456789101112131415class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] self.result = [] self._dfs(root,0) return self.result def _dfs(self, root: TreeNode, level): if not root: return if len(self.result)&lt;level+1: self.result.append([]) self.result[level].append(root.val) self._dfs(root.left,level+1) self._dfs(root.right,level+1) 总结非常经典的题，以至于在数据结构这门专业课中都有专门介绍的经典算法，但是即使在已经学习过思想的情况下，写起来依旧有很多值得注意的点。经典的solution是我们的BFS，也顺应我们的通常思维，通过一个队列来一层一层的存储树中的节点，每次内层循环都是每层的长度，值得注意的是图的层序遍历也可以这么做，不过需要多加一个visited的set用于判断是否重复（这是树中没有的操作因为树不会有循环结构） 另一方面，发现了DFS的做法，说实话DFS非常的反正常思维，但是确实可行，而且利用递归代码还显得更为简洁，我参考视频中大牛的思路写了python3的版本，将java版本留下以后复习再写。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House Robber lc198]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc198%2F</url>
    <content type="text"><![CDATA[题目描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber python31234567class Solution: def rob(self, nums: List[int]) -&gt; int: pre = 0 cur = 0 for i in nums: cur, pre = max(pre+i,cur),cur return cur java123456789101112class Solution &#123; public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int i:nums)&#123; int temp = curMax; curMax = Math.max(preMax+i,curMax); preMax = temp; &#125; return curMax; &#125;&#125; 总结个人感觉又是一道扮猪吃老虎的lc简单题，看到easy的标签让人觉得可以通过循环遍历来处理解决它，但其实通常的循环遍历并不能解决这个题，它其实是个典型的动态规划思想的题，通过从数组长度1开始拓展，每次规划取最优解。没错这种不使用递归的简单动态规划似乎又可以被想成一种数学归纳的方法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diameter of Binary Tree lc543]]></title>
    <url>%2F2019%2F09%2F07%2F20190907-lc543%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/diameter-of-binary-tree python3–递归123456789101112131415161718192021222324= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: res = 0 def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: if root == None: return 0 self.depth(root) return self.res def depth(self, root: TreeNode): if root == None: return 0; l = self.depth(root.left) r = self.depth(root.right) if l + r &gt; self.res: self.res = l + r return max(l, r) + 1 java–递归12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res=0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; depth(root); return res; &#125; public int depth(TreeNode root)&#123; if(root == null) return 0; int r = depth(root.right); int l = depth(root.left); if(r + l &gt; res) res = r + l; return Math.max(r, l)+1; &#125;&#125; 总结本题是一道leetcode简单难度的题，思路比较明确那就是利用递归的思想每次对于一个节点都要获取它的左右子树的最大深度然后暂存这两个值的和，并且每次返回的是两者中的较大的值供上层递归使用，这题比较奇特的地方在于它虽然利用递归但是并不能靠递归的返回值累加来获得最终的结果，需要创建一个全局变量并且在整个递归的过程中维护这个全局变量的值，它才是我们最终的res，所以我抱着传统的递归思路去做这个题的时候总感觉思路很清晰却总有点问题，最后看了评论区大佬的思路才恍然大悟，所以说思路不能固化，即使是递归也有不同的用法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 teaching experience]]></title>
    <url>%2F2019%2F08%2F30%2F20190830%2F</url>
    <content type="text"><![CDATA[前言由于这周回了一条天国的微信消息被老师派遣去干苦力教一名高中生python3编程，并且自己的python3也就是个半吊子于是乎一周都沉浸在现学现卖赶制第二天ppt的劳累生活之中，算是尝试了一把新人老师的心酸生活。 但是，另一个角度来说我也又过了一遍python3的基础语法，可以说收获还是有的。由于本科是c语言作为第一门编程语言学习语法，所以母语思维就是静态语言类型，后来学c++，java可以说由于同是静态语言差别并不大。而python是在大三的时候企业工程实践老师在介绍Jquery和Flask时提到让我们学，当时也没有系统的教我们，只是在用到的部分就去查这样的填补式学习，而这一周算是让我补上了以前缺失的基础部分知识。 安装与使用自己用的macos所以有自带python2.7，但是教学需要还是重新下载覆盖了python3.7，使用的是python3.7版本的anaconda，记得以前本科时使用opencv2踩过坑，当时傻白甜的下载了官网python并自己导入包，老师就说过可以用anaconda。如今才知道anaconda是个python开源版本&amp;包管理工具，如果可以回到从前我一定拍死自己= =。 下载anaconda就意味着python3.7和一些IDE都已经下载好了，配置一下环境变量即可覆盖2.7并使用，python环境变量配置比较简单就略过吧。值得一题的是Jupyter notebook这个IDE，作为新手的IDE来说确实不错，不需要适应新的客户端，网页端就可以用，基础功能也比较全面，非常时候新手学习使用。而且anaconda自带，也不需要另外下了。 动态语言python的优势作为我接触的第一个动态编程语言，python给我的第一感觉是不可思议的，相比之下java就显得严格且死板。 首先接触到的区别在于python对于基础类型的自动转换，使得我们不需要通过基础类型关键字去创建变量，并且可以批量赋值十分灵活。 12345678910===python3x, y=1, 1.2x, y='1', '1.2'===javaint x=1;float y=1.2char z='1'String x="1.2"//......wdnmd 其次python灵活丰富的方法以及运算符重载使得可操作性极其强大，你不仅可以用+号去拼接字符串，还可以去拼接list，set等，用-号去操作set等。而这些高级数据结构的重载在java中是没有的，你只能手动去实现。。。 python与java在看了一周python的基础语法后我发现作为一门OOP语言python与java其实在基础语法方面基本是一致的，只是形式不同，python使用冒号：以及严格的缩进区分方法体，类内容等，同时加不加分号；作为结束都是不影响的。而java使用大括号{}区分方法体和类的内部，并且严格的要求在变量定义和创建参数列表时使用基础类型关键字，并且每一条语句需要分号；结束。 当然除了格式的不同，它们在基础语法的部分也是有一定差别的第一、python中没有char类型的概念，全部使用string类型，也没有数组int[]的概念全部使用list。可以说更加简洁方便 第二、python中没有java中的这种常用for循环用法 123for(int i=0;i&lt;nums.length;i++)&#123; ......&#125; 取而代之的是配合range的for循环，两者功能一致，而且都非常好用 12for i in range(nums): ...... 第三、python的类变量区分为class variables 和 instance variables。而java中与之对应的是static关键字修饰的静态成员变量以及普通成员变量。两种语言的变量相互对应起来功能类似，但是又有细微的区别。 1234567891011===pythonclass Shark(): \# class variable type="fish" def __init__(self, name): \# instance variable self.name = names1=Shark("Lucy")s2=Shark("Lily")s1.type="food" 如果我执行以上的语句，如果是java的静态成员变量，那么s2的type属性会同步成”food”，但是在python中不会，python会认为s1并没有权限修改class variable因此在执行修改时将s1的type属性降级成instance variable从而成为s1专属的成员变量，而不会影响其他Shark对象的type属性。简单说来python拒绝类对象对类变量执行重新赋值“=”的操作，会导致变量类型的转换（我理解为权限的降级），但是以下的修改语句是被允许的 123456class Shark(): num=[1,2,3]s1=Shark()s2=Shark()s1.num.append(4) 可以理解为类对象可以修改但不能重新赋值类变量，这种行为比较奇特也是java中没有的，我暂时还不知道为什么python会有这样的特性。 总结这一周时间都贡献给了python，既没有新技术栈的学习，也没有踩坑解惑的经历，只是回顾了以前的知识并补ß上一些空白，最初的两天我是很不爽的，我觉得这完全是浪费时间，然而现在我觉得这还是有意义的，而且是我以前很少做的事，知识在回顾的时候可能学到更多，而且可以加深自己以前的理解。总的来说这一周不亏。马上后天研究生开学了，期待一个新的生活吧。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ+Mqtt enable publisher/subscriber]]></title>
    <url>%2F2019%2F08%2F17%2F20190817-tec%2F</url>
    <content type="text"><![CDATA[前言这周有空余时间于是补了一下上周的week4任务中的ActiveMQ使用，本来想下载apache apollo的，但是发现apache官网已经没有了apollo的下载提供，短暂的尝试寻找资源后放弃了，反正一脉相承，又是官网主推的，那么就用ActiveMQ代替学习吧。但是不得不说最新版本东西的可借鉴博客真的少的可怜，基本都是讲apollo的，我结合apollo类似部分以及啃官方文档总算是大概用起来了。 经历安装与启用本来还在官网下载了一下ActiveMQ的最新版本然后手动移动解压文件后来一拍脑袋，有homebrew不用的都是傻子，于是删掉后shell里一行装好，不得不说homebrew是真的香啊，不枉我上周踩了好久坑才装好。 1brew install activemq 安装好以后直接用activemq命令就可以开启和关闭服务 12activemq startactivemq stop 这里有一点，启动后官方文档说shell中会有启动的web页面端口号，但是我自己启动并没有发现有端口号提示，一开始是看网上的博主的默认端口号打开的网页端，后来知道activemq的文件家中/../conf文件夹中有activemq的所有配置文件，包括默认用户名密码，网页默认端口，各种连接方式端口等等，都可供修改。 启动服务后，打开网页url输入用户名密码就可以登陆服务端管理界面了里面有topic，queue创建管理以及连接上服务端的客户端的管理，已有订阅者的管理等等。 实现subscriber/publisher在上一步开启服务进入服务页面后，我还使用了两个客户端和它进行连接，分别是：1、mqttfx，之前学mqtt的时候下的，当时没用上现在用了，通过activemq提供的mqtt端口接入，填好mqttfx的信息后connect建立连接。就可以实现订阅topic和向topic publish信息。2、下载的activemq文件夹中有提供相应的简易客户端用于test，我使用了example文件夹下mqtt/websocket的客户端，就一个html页面，页面极度简单，填完连接信息connect后就一个输入框一个按钮一个显示框，像极了刚学C# winform时拖控件的我做出的第一个界面= =，不过这也算是有基本功能了，可以说是易用性极强。 两个客户端都连接上服务端后，就可以动手创建topic，订阅消息发布消息，查看mqtt这种中间件的运作模式了，动了手以后会让理论上的理解更上一层楼。 总结mqtt确实是提供了一个双向交互的中间消息队列服务，其中服务端只是做一个中转站，只要是连接上服务端的客户端，并且订阅了同一个topic，那么他们就可以通过服务端进行双向的交互，可以说非常方便。还记得以前企业工程实践课的老师让我们学socket的时候，说用socket就可以很快的实现类似qq这样的聊天软件功能，现在知道了mqtt这种中间件，看看都是封装tcp协议的东西，如果只是实现聊天的话mqtt这边用现成的客户端一行代码都不用敲= =。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project experience summary]]></title>
    <url>%2F2019%2F08%2F16%2F20190816-tec%2F</url>
    <content type="text"><![CDATA[前言暑假提前来到学校也跟着学长的开发任务做了些事，大概是一周前还做着开发任务，隔了一周配置本地项目又是不知所措，好多熟悉的bug又遗忘了怎么处理，关键是自己寻找问题解决方案的能力还很有待提高总是浪费很多时间才能解决，总是去问学长又太麻烦他，以后我会将每一段时间的项目经验总结在这里，方便回顾学习，温故而知新。 这次主要是springboot+springcloude+mybatis的果麦新风drift模块的开发，需要给订单order对应的快递单号express功能接口的实现，中间碰了很多坑。 踩坑经历1、本地与服务器的配置不同与冲突这一部分是每次git pull整合本地代码以后都要做的事，已经习惯了如何处理倒是没有花费太多的时间，首先检查eureka-server端的properties文件，写一个自己想用的端口号，并且做一些常规的处理 1234567#spring.profiles.active=test 这一行是服务端代码，用于选择需要的properties版本server.port=8080eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 然后检查需要开发的drift模块的properties文件 12345678910111213server.port=8000spring.application.name=drift-agenteureka.client.healthcheck=trueeureka.client.service-url.defaultZone=http://127.0.0.1:8080/eureka/mybatis.config-location=classpath:mybatis-config.xmlspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/gmair_drift?useLegacyDatetimeCode=false&amp;serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=shuge888 以及pom文件中的架包依赖，这主要是修改本地与服务端使用的不同版本的架包依赖，例如我们服务端中mysql的drive驱动版本是6.0.6，但是我本地的mysql版本较新需要使用新一些的drive驱动例如8.0.11否则本地运行会报错。 这里要着重说的是common模块中lombok版本不匹配问题影响了我很长时间，最后是麻烦学长才解决的，lombok是用于自动添加实体类get()/set()方法的工具，但是服务器上的java9版本的lombok版本却与我本地的java11冲突，导致maven重新生成target文件夹失败，进而导致mybatis的XML文件中引用枚举类型enum的handler失败，需要修改lombok架包版本才能解决这一系列的问题。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--这条语句是老版本lombok没有的，但是缺少这条语句又是不行的--&gt;&lt;/dependency&gt; Addition:我对maven的命令使用也不熟悉，常用命令还是要牢记的，例如清理maven后重新安装项目以及依赖的命令；maven打包命令 123mvn -U clean installmvn package 2、总体项目进度带来的对其他模块的依赖在一周前还可以本地运行的项目一周后就不行了，因为总的项目进度在向前，开发的模块可能加入了对其他开发者模块的依赖，例如我这次添加的wechat.properties以及sesame.properties。这两个配置文件缺失的话就无法运行项目，前者是微信模块，可以直接创建一个新的文件里面的内容部分留空也可以运行；后者则是alipay相关模块，里面需要内容，这一部分问学长要了一下填上也就解决了。 3、自己编程造成的bug这一部分我是没有想到的，由于昨天是12点前开始写到1点半写完的接口（别问我之前干嘛去了，我也不知道我的时间去哪儿了= =），在第二天提交后测试的时候发现两处致命的错误。。。（没错有一处还是拼写错误），这两处错误精妙的没有引起编译报错，又确实的造成了软件错误，因为这两处错误一处出在xml文件中的拼写错误，另一处是写Express实体类的时候忘记extend Entity基础类了导致实体缺了两个公共属性。 回想起来这是真的蠢，再次提醒自己编码一定要细致，尽量在自己精力充沛的时候进行开发任务，不然会出很多错。 新学到的东西java中的枚举类型enum早就知道有这么个东西了，但是一直都没有自己用过，这次在开发任务中碰到也算是学习了一下，首先枚举类型的构造十分简单，和class类似。 123456789101112131415161718192021public enum ExpressStatus implements EnumValue &#123; DELIVERED(0),BACk(1); private int value; ExpressStatus(int value)&#123;this.value=value;&#125; public static ExpressStatus valueOf(int value)&#123; //这个方法是重载的，用于枚举值和实际值int转换 switch (value)&#123; case 0: return DELIVERED; case 1: return BACk; default: return null; &#125; &#125; @Override public int getValue()&#123;return value;&#125;&#125; 定义后在后端代码中正常使用即可，主要的不同在于mybatis的xml文件中与数据库表的映射需要调用一个handler处理，在insert方法中调用系统的EnumOrdinalTypeHandler即可正常转换插入 123456789&lt;insert id="insert" parameterType="finley.gmair.model.drift.Express" useGeneratedKeys="false"&gt; insert into gmair_drift.order_express (order_id, express_id, express_status, company, block_flag, create_time) VALUES (#&#123;orderId&#125;, #&#123;expressId&#125;, #&#123;status, typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;company&#125;, #&#123;blockFlag&#125;, #&#123;createAt&#125;)&lt;/insert&gt; 这样可以保证数据插入的正常，但是想要正常的获取数据还需要我们自己写一个handler用于数据的检验和转换，这个handler类的编写是继承并实现系统提供的abstract class，第一眼看上去好像代码很复杂但是其实都是根据实际情况overwrite，而且逻辑简单，只是抽象类的方法体比较陌生，但是其实并不难。这个ExpressStatusHandler的代码较长而且就是实现抽象类就不贴了，写好以后在mybatis中的xml文件中的”resultMap”映射标签中提供这个handler就ok了 1234567&lt;resultMap id="expressVo" type="finley.gmair.model.drift.Express"&gt; &lt;result property="orderId" column="order_id"&gt;&lt;/result&gt; &lt;result property="expressId" column="express_id"&gt;&lt;/result&gt; &lt;result property="company" column="company"&gt;&lt;/result&gt; &lt;result property="status" column="express_status" typeHandler="finley.gmair.mybatis.handler.ExpressStatusHandler"&gt;&lt;/result&gt;&lt;/resultMap&gt; 这样就实现了枚举类与数据库交互的转换。 总结学习总是难受的过程，拿到任务我也总是会畏难，拖啊拖的，但是其实碰到的困难有多难克服并总结后的收获就有多大。今天是8月16号，离开学也就剩两周时间了，希望自己能好好抓紧时间少摸鱼多锄地！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree lc538]]></title>
    <url>%2F2019%2F08%2F14%2F20190814-lc538%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / 2 13 Output: The root of a Greater Tree like this: 18 / 20 13 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree python3–lastOrder递归1234567891011121314151617= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: count=0; def convertBST(self, root: TreeNode) -&gt; TreeNode: if root: root.right=self.convertBST(root.right); root.val=root.val+self.count; self.count=root.val; root.left=self.convertBST(root.left); return root; return None; java–lastOrder非递归12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int count=0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack(); //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考 TreeNode node=root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.add(node); node=node.right; &#125; node=stack.pop(); node.val+=count; count=node.val; if(node.left!=null) node=node.left; else node=null; &#125; return root; &#125;&#125; 总结本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求众数 lc169]]></title>
    <url>%2F2019%2F08%2F07%2F20190807-lc169%2F</url>
    <content type="text"><![CDATA[题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element java–sort+map+摩尔投票法sort后一次遍历处理，时间复杂度O(NlogN)12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; //if(nums==null)return 0;题目保证不会出现的情况 if(nums.length==1)return nums[0]; int count=1; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i++) &#123; if(nums[i]==nums[i+1]) count++; else &#123; if(count&gt;nums.length/2) return nums[i]; else count=1; &#125; &#125; return count&gt;nums.length/2?nums[nums.length-1]:0; &#125;&#125; map一次遍历存储后输出即可，时间复杂度O(N)123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int x:nums)&#123; if(map.containsKey(x)) map.put(x,map.get(x)+1); else map.put(x,1); &#125; for(int x:map.keySet())//keySet方法返回key的集合set if(map.get(x)&gt;nums.length/2) return x; return 0; &#125;&#125; 摩尔投票法O(N)1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int maj = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (maj == nums[i]) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; &#125; return maj; &#125;&#125; python本题投机取巧法（如果有唯一众数，那一定是排序后的中位数） 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2]; 总结本题是leetcode中的简单难度题，只是求解的话比较容易。 但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好 而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pow(x,n) lc50]]></title>
    <url>%2F2019%2F08%2F06%2F20190806-lc50%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000 示例 2:输入: 2.10000, 3输出: 9.26100 示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n java–非递归分治循环123456789101112class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i=i/2) &#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; python–递归123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x, n = 1/x, -n; if not n: #recursion termination return 1; if n % 2: return x*self.myPow(x, n-1); return self.myPow(x*x, n/2); 总结本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。需要注意的有两点：一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n = 1/x, -n」比较方便。二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。tip：注意递归写法的重要习惯————递归终止语句]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯理解+实例]]></title>
    <url>%2F2019%2F08%2F05%2F20190805%2F</url>
    <content type="text"><![CDATA[什么是贝叶斯英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。 在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2/10）而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。 贝叶斯案例有两个一模一样的碗1号碗里有：30个巧克力和10个水果糖2号碗里有：20个巧克力和20个水果糖然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率） 第1步，分解问题1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？来自1号碗记为事件A1，来自2号碗记为事件A2取出的是巧克力，记为事件B，那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率 2）已知信息：1号碗里有30个巧克力和10个水果糖2号碗里有20个巧克力和20个水果糖取出的是巧克力 第2步，应用贝叶斯定理1）求先验概率由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)=P(A2)=0.5,(其中A1表示来自1号碗，A2表示来自2号碗)这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。 2）求可能性函数P(B|A1)/P(B)其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)=30/(30+10)=75%P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)=0.75*0.5+20/(20+20)*0.5=62.5%所以，可能性函数P(A1|B)/P(B)=75%/62.5%=1.2可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。 3）带入贝叶斯公式求后验概率将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)=60%这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
