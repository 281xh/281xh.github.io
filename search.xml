<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三角形最小路径和-lc120]]></title>
    <url>%2F2020%2F03%2F19%2F20200319-lc120%2F</url>
    <content type="text"><![CDATA[120. 三角形最小路径和题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 java123456789101112131415161718192021222324252627//自上而下public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==1) return triangle.get(0).get(0); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(triangle.get(0)); for(int i=1;i&lt;triangle.size();i++)&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); for(int j=0; j&lt;triangle.get(i).size(); j++)&#123; int tmin = 0; if(j==0) tmin = triangle.get(i).get(j)+res.get(i-1).get(j); else if(j==triangle.get(i).size()-1) tmin = triangle.get(i).get(j)+res.get(i-1).get(j-1); else&#123; tmin = Math.min(triangle.get(i).get(j)+res.get(i-1).get(j),triangle.get(i).get(j)+res.get(i-1).get(j-1)); &#125; tmp.add(tmin); &#125; res.add(tmp); &#125; int min = Integer.MAX_VALUE; int len = res.size(); for(int i=0;i&lt;res.get(len-1).size();i++) min = Math.min(min,res.get(len-1).get(i)); return min;&#125; 12345678910111213//自下而上public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size() == 1) return triangle.get(0).get(0); for(int i=triangle.size()-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; int a = triangle.get(i).get(j)+triangle.get(i+1).get(j); int b = triangle.get(i).get(j)+triangle.get(i+1).get(j+1); triangle.get(i).set(j,Math.min(a,b)); &#125; &#125; return triangle.get(0).get(0);&#125; python312345678class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if len(triangle)==1: return triangle[0][0] for i in range(len(triangle)-2,-1,-1): for j in range(0,len(triangle[i])): triangle[i][j] = min(triangle[i][j]+triangle[i+1][j],triangle[i][j]+triangle[i+1][j+1]) return triangle[0][0] 总结&amp;&amp;思路自上而下或者自下而上遍历三角形，每次保留本节点和上一层节点相加的最小值做动态规划。很显然自下而上的方式可以大大简化判断次数以及边界判断，更适合本题数据结构。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的二叉搜索树-lc96 & lc95]]></title>
    <url>%2F2020%2F03%2F03%2F20200303-lc96%2F</url>
    <content type="text"><![CDATA[96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ 3 2 1 1 3 2 / / \ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees java12345678910public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2; i&lt;dp.length; i++) for(int j=1; j&lt;=i; j++)&#123; dp[i] += dp[j-1]*dp[i-j]; &#125; return dp[dp.length-1];&#125; python31234567def numTrees(self, n: int) -&gt; int: dp = [0]*(n+1) dp[0], dp[1] = 1, 1 for i in range(2,n+1): for j in range(1,i+1): dp[i] = dp[i] + dp[i-j]*dp[j-1] return dp[-1] 总结&amp;&amp;思路lc中等题，动态规划 假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数 即有:G(n) = f(1) + f(2) + f(3) + f(4) + … + f(n) n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,…,i-1]，右子树节点个数为[i+1,i+2,…n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) = G(i-1)*G(n-i), 上面两式可得:G(n) = G(0)G(n-1)+G(1)(n-2)+…+G(n-1)*G(0) 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ 3 2 1 1 3 2 / / \ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii java123456789101112131415161718192021222324public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n &lt; 1) return new ArrayList(); List&lt;TreeNode&gt; res = Run(1,n); return res;&#125;public List&lt;TreeNode&gt; Run(int start,int end)&#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if(start &gt; end)&#123; res.add(null); return res; &#125; for(int i=start; i&lt;=end; i++)&#123; List&lt;TreeNode&gt; llist = Run(start,i-1); List&lt;TreeNode&gt; rlist = Run(i+1,end); for(TreeNode l:llist) for(TreeNode r:rlist)&#123; TreeNode node = new TreeNode(i); node.left = l; node.right = r; res.add(node); &#125; &#125; return res;&#125; python312345678910111213141516171819def generateTrees(self, n: int) -&gt; List[TreeNode]: if n &lt; 1: return [] res = self.Run(1,n) return resdef Run(self, start, end) -&gt; List[TreeNode]: res = [] if start &gt; end: return [None] for i in range(start,end+1): llist = self.Run(start,i-1) rlist = self.Run(i+1,end) for l in llist: for r in rlist: node = TreeNode(i) node.left, node.right = l, r res.append(node) return res 总结&amp;&amp;思路lc中等题，动态规划遍历1～n，每次将遍历到的数作为根节点，计为i 递归返回左右子树，分别为0～i-1以及i+1～n 由于1～n本身就是升序序列，按照这种方式也能满足二叉搜索树的性质。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair权限划分]]></title>
    <url>%2F2020%2F03%2F01%2F20200301-tec%2F</url>
    <content type="text"><![CDATA[前言这次的项目由于春招找实习准备中断了一段时间，任务量没有很大但是也踩了不少坑。 需求功能，给管理员划分权限：超级管理员 安装 检测 客服 短信主要通过枚举类型解决。 步骤一、添加pom依赖可以说任何功能的添加修改在springboot项目中首先要注意的就是pom依赖，在以前的项目任务中我曾经参与过枚举类型的添加修改，但是当时是做的增量类型的任务，pom依赖以及一些xml细节都已经有前辈添加过，所以这次自己完整的完成任务第一个碰到的问题就是jar依赖的缺失。 12345&lt;dependency&gt; &lt;groupId&gt;finley.gmair&lt;/groupId&gt; &lt;artifactId&gt;gmbatis&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 将存放枚举类型转换器handler的包模块添加进依赖中。 二、枚举类型创建与构造函数枚举类型的创建很常规不多赘述，但是想要在使用枚举类型的类中正常的使用枚举类型属性，就需要按需求添加对应的构造函数 123456789101112131415161718192021222324252627282930313233public Admin(String email, String username, String password, AdminRole role)&#123; this(); this.email = email; this.username = username; this.password = password; this.role = role;&#125;public Admin(String email, String username, String password, int role) &#123; this(); this.email = email; this.username = username; this.password = password; switch (role)&#123; case 0: this.role = AdminRole.MANAGER; break; case 1: this.role = AdminRole.INSTALL; break; case 2: this.role = AdminRole.CHECK; break; case 3: this.role = AdminRole.CUSTOM_SERVICE; break; case 4: this.role = AdminRole.MESSAGE; break; default: this.role = null; &#125;&#125; 三、枚举类型转换器handler想要枚举类型正常的参与数据库逻辑，我们需要使用枚举类型的handler转换器。其中插入操作使用系统的handler即可保证插入正常 123456&lt;insert id="insert" parameterType="finley.gmair.model.admin.Admin" useGeneratedKeys="false"&gt; INSERT INTO gmair_admininfo.admin_info (admin_id, admin_email, admin_name, admin_password, admin_role, block_flag, create_time) VALUES (#&#123;adminId&#125;, #&#123;email&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;role, typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;blockFlag&#125;, #&#123;createAt&#125;)&lt;/insert&gt; 而想要正常查询枚举类型，需要我们自己继承实现baseHandler类。使用自己的handler有两种方法，一种是在转换类前使用注解@MappedTypes指定那些需要转换的枚举，第二种是在xml映射文件中指定。我是用了第二种方法： 123456789&lt;resultMap id="adminVo" type="finley.gmair.model.admin.Admin"&gt; &lt;result property="adminId" column="admin_id"&gt;&lt;/result&gt; &lt;result property="email" column="admin_email"&gt;&lt;/result&gt; &lt;result property="username" column="admin_name"&gt;&lt;/result&gt; &lt;result property="role" column="admin_role" typeHandler="finley.gmair.mybatis.handler.AdminRoleHandler"&gt;&lt;/result&gt; &lt;result property="password" column="admin_password"&gt;&lt;/result&gt; &lt;result property="blockFlag" column="block_flag"&gt;&lt;/result&gt; &lt;result property="createAt" column="create_time"&gt;&lt;/result&gt;&lt;/resultMap&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class AdminRoleHandler extends BaseTypeHandler&lt;AdminRole&gt; &#123; private Class&lt;AdminRole&gt; role; private final AdminRole[] enums; public AdminRoleHandler(Class&lt;AdminRole&gt; role) &#123; if (role == null) &#123; throw new IllegalArgumentException("role argument cannot be null"); &#125; this.role = role; this.enums = role.getEnumConstants(); if (this.enums == null) &#123; throw new IllegalArgumentException(new StringBuffer(role.getSimpleName()).append(" does not represent an enum type.").toString()); &#125; &#125; @Override public void setNonNullParameter(PreparedStatement preparedStatement, int i, AdminRole adminRole, JdbcType jdbcType) throws SQLException &#123; preparedStatement.setInt(i, adminRole.getValue()); &#125; @Override public AdminRole getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; int i = resultSet.getInt(s); if (resultSet.wasNull()) &#123; return null; &#125; else &#123; return locateEnumStatus(i); &#125; &#125; @Override public AdminRole getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; int index = resultSet.getInt(i); if (resultSet.wasNull()) &#123; return null; &#125; else &#123; return locateEnumStatus(index); &#125; &#125; @Override public AdminRole getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; int index = callableStatement.getInt(i); if (callableStatement.wasNull()) &#123; return null; &#125; else &#123; return locateEnumStatus(index); &#125; &#125; private AdminRole locateEnumStatus(int code) &#123; for (AdminRole role : enums) &#123; if (role.getValue() == (Integer.valueOf(code))) &#123; return role; &#125; &#125; throw new IllegalArgumentException("Unknown enum type：" + code + ",please check " + role.getSimpleName()); &#125;&#125; 踩坑经历&amp;&amp;总结开发阶段每一次项目任务中最消耗时间让人痛彻心扉的坑往往都是因为自己的疏漏而犯下的愚蠢错误，而不是技术上的难点。这一次也一样，枚举类心的插入转换很顺利，但是取出碰到了问题，当时的场景是这样的。1、数据库中的数据字段正常。2、执行查询状态操作，查询出来的枚举状态总是null。3、如果修改model类的无参构造函数给枚举状态赋上初值，那么查询出来的结果永远是这个初值而与数据库中的值无关。这个问题困扰了我非常久，我将问题定位在了枚举转换器的实现错误或者是引用错误，因而花费了大量的时间精力去排查，但是一无所获。在我将近绝望的时候，我突然意识到这个问题场景十分类似于select中根本没有去查询这个字段，所以mybatis映射实体model的时候调用了无参构造函数生成了那个默认值。于是我看了一眼xml中的select语句。。 12SELECT admin_id, admin_email, admin_name, admin_password, admin_role, block_flag, create_time FROM gmair_admininfo.admin_info 果然是没有用*而是按字段查询，而枚举状态的那个字段是新加的，我花费了那么多时间去写转化器加属性，结果最后没用上。。。一口老血。。 测试阶段使用postman测试时习惯于通常的springboot设置的http请求将参数写在http的param中跟在url后面。但是如果是一些敏感信息比如账号密码，那么久不能放在param中了，要加密后放在body中，需要用到@RequestBody注解 12@RequestMapping(method = RequestMethod.POST, value = "/admin/login") public ResultData login(@RequestBody LoginForm form) &#123; 而在测试的时候，自然也需要使用body包含信息的http post请求。 总结总结就是功能技术实现非常重要，但是也不能忽视最基本的接口，pom依赖和数据库逻辑都是应该首先检查的点。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Recall]]></title>
    <url>%2F2020%2F02%2F26%2F20200226-offer%2F</url>
    <content type="text"><![CDATA[(1)矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 java12345678910111213141516171819202122232425public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; boolean[] flag = new boolean[matrix.length]; for(int i=0; i&lt;rows; i++) for(int j=0; j&lt;cols; j++) if(Judge(matrix,rows,cols,i,j,str,0,flag)) return true; return false; &#125; public boolean Judge(char[] matrix,int rows,int cols,int i,int j,char[] str,int k,boolean[] flag)&#123; int index = i*cols+j; if(i&lt;0 || i&gt;=rows || j&lt;0 || j&gt;=cols || matrix[index]!=str[k] || flag[index]==true) return false; if(k == str.length-1) return true; flag[index] = true; if(Judge(matrix,rows,cols,i+1,j,str,k+1,flag) || Judge(matrix,rows,cols,i-1,j,str,k+1,flag) || Judge(matrix,rows,cols,i,j+1,str,k+1,flag) || Judge(matrix,rows,cols,i,j-1,str,k+1,flag) ) return true; flag[index] = false;//递归树收束，要做还原操作！ return false; &#125; 思路&amp;&amp;总结链接：https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?f=discussion来源：牛客网 回溯基本思想：0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。 (2)机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ java12345678910111213141516171819public int movingCount(int threshold, int rows, int cols)&#123; boolean[][] flag = new boolean[rows][cols]; return Count(threshold,rows,cols,0,0,flag);&#125;public int Count(int threshold,int rows,int cols,int x,int y,boolean[][] flag)&#123; if(x&lt;0||x&gt;=rows||y&lt;0||y&gt;=cols||flag[x][y]==true||Sum(x)+Sum(y)&gt;threshold) return 0; flag[x][y]=true; //记录当前位置 return 1+Count(threshold,rows,cols,x+1,y,flag)+Count(threshold,rows,cols,x,y+1,flag);&#125;public int Sum(int n)&#123; int sum = 0; while(n&gt;0)&#123; sum+=n%10; n = n/10; &#125; return sum;&#125; 思路&amp;&amp;总结一定要记得写记录数组，不然无限递归tips：注意与上题区别，是否需要做记录数组flag的回退操作。 (3)剪绳子题目描述给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 java1234567891011121314151617181920212223public int cutRope(int target) &#123; // n&lt;=3的情况，m&gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2, if(target==1 || target==2) return 1; if(target == 3) return 2; int[] dp = new int[target+1]; /* 下面3行是n&gt;=4的情况，跟n&lt;=3不同，4可以分很多段，比如分成1、3， 这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。 */ dp[1] = 1; dp[2] = 2; dp[3] = 3; int res = 0;//记录最大值 for(int i=4;i&lt;dp.length;i++)&#123; for(int j=1; j&lt;=i/2; j++)&#123; res = Math.max(res,dp[j]*dp[i-j]); &#125; dp[i] = res; &#125; return dp[target];&#125; 12345678910public int cutRope(int target) &#123; if(target==2 || target==3) return target-1; int res = 1; while(target &gt; 4)&#123; target-=3; res*=3; &#125; return res*target;&#125; 思路&amp;&amp;总结方法一动态规划。方法二数学运算。本体重点在于3这个点，小于等于3的数分段乘积都不如本身长，大于3的数分段乘积就要大于等于本身。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-recall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Mess3]]></title>
    <url>%2F2020%2F02%2F25%2F20200225-offer%2F</url>
    <content type="text"><![CDATA[(1)扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 java12345678910111213141516public boolean isContinuous(int [] num) &#123; if(num.length != 5) return false; int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0; i&lt;num.length; i++)&#123; if(set.contains(num[i])) return false; if(num[i] == 0) continue; set.add(num[i]); max = Math.max(max,num[i]); min = Math.min(min,num[i]); &#125; return (max-min)&lt;=4;&#125; 思路&amp;&amp;总结按照规则，五张牌满足如下条件即可：（1）最大值与最小值之差小于等于4（由于有0的存在）。（2）没有重复的数出现。（对子情况） (2)孩子们的游戏(圆圈中最后剩下的数)题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 java1234567891011public int LastRemaining_Solution(int n, int m) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for(int i=0;i&lt;n;i++) list.add(i); int index = 0; while(list.size() &gt; 1)&#123; index = (index+m-1)%list.size(); list.remove(index); &#125; return list.size()==1 ? list.get(0) : -1;&#125; 思路&amp;&amp;总结约瑟夫环问题（1）使用一个list模拟游戏过程即可（使用数组也是可以的）（2）如果想要代码效率大大提升，那么可以先推出数学公式，然后套用公式求解。 (3)求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 java12345public int Sum_Solution(int n) &#123; int a = n; boolean condition = (a&gt;0) &amp;&amp; ((a+=Sum_Solution(n-1))&gt;0); return a;&#125; 思路&amp;&amp;总结链接：https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1?f=discussion来源：牛客网 解题思路：1.需利用逻辑与的短路特性实现递归终止。2.当n==0时，(n&gt;0)&amp;&amp;((sum+=Sum_Solution(n-1))&gt;0)只执行前面的判断，为false，然后直接返回0；3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。 (4)不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 java12345678public int Add(int num1,int num2) &#123; while(num2 != 0)&#123; int tmp = num1^num2; //非进位相加 num2 = (num1&amp;num2)&lt;&lt;1; //计算进位 num1 = tmp; &#125; return num1;&#125; 思路&amp;&amp;总结链接：https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?f=discussion来源：牛客网 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果 (5)把字符串转换成整数题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 java1234567891011121314151617181920public int StrToInt(String str) &#123; if(str==null || str.length()==0) return 0; int res = 0, i=0, flag=1; char[] num = str.toCharArray(); if(num[0] == '+' || num[0]=='-') i++; if(num[0]=='-') flag=-1; for(;i&lt;num.length; i++)&#123; if(num[i]&lt;='9' &amp;&amp; num[i]&gt;='0')&#123; int part = num[i]-'0'; if(flag==1 &amp;&amp; res*10&gt;Integer.MAX_VALUE-part) return 0; if(flag==-1 &amp;&amp; res*10&gt;-Integer.MIN_VALUE-part) return 0; res = res*10+part; &#125; else return 0; &#125; return num[0]=='-' ? -res : res;&#125; 思路&amp;&amp;总结转换方式：（1）判断第一位是否带正负号，使用一个标志位记录。（2）向后判断每一位是否符合’0’~’9’tips:唯一难点在于int溢出的判断，如果是正数那么溢出情况为res10+part &gt; Integer.MAX_VALUE变化一下使判断式合法即可：res10 &gt; Integer.MAX_VALUE-part负数溢出同理。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Mess2]]></title>
    <url>%2F2020%2F02%2F24%2F20200224-offer%2F</url>
    <content type="text"><![CDATA[(1)数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 java12345678910111213141516171819202122232425262728public int GetNumberOfK(int [] array , int k) &#123; if(array.length == 0) return 0; int index = getK(array,0,array.length-1,k); if(index&lt;0) return 0; int l=index, h=index; while(l&gt;0 &amp;&amp; array[l]==k) l--; while(h&lt;array.length-1 &amp;&amp; array[h]==k) h++; if(array[l]==k &amp;&amp; array[h]==k) return h-l+1; else if(array[l]==k || array[h]==k) return h-l; else return h-l-1;&#125;public int getK(int[] array,int low,int high,int k)&#123; if(array[low] == k) return low; if(low&gt;=high) return -1; int mid = (low+high)/2; if(array[mid] == k) return mid; else if(array[mid] &gt; k) return getK(array,mid+1,high,k); else return getK(array,low,mid-1,k);&#125; 思路&amp;&amp;总结有序肯定用二分，递归写法和非递归都可以，二分不难写但是要考虑到所有情况需要非常细致。 (2)二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 java12345678910111213int depth = 0;public int TreeDepth(TreeNode root) &#123; DFS(root,1); return depth;&#125;public void DFS(TreeNode root,int curDepth)&#123; if(root != null)&#123; depth = Math.max(depth,curDepth); DFS(root.left,curDepth+1); DFS(root.right,curDepth+1); &#125;else return;&#125; 12345public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; return Math.max(1+TreeDepth(root.left),1+TreeDepth(root.right));&#125; 思路&amp;&amp;总结DFS递归，第二种极度简洁。 (3)平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 java12345678910111213public boolean IsBalanced_Solution(TreeNode root) &#123; if(root == null) return true; if(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=1) return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right); else return false;&#125;public int getDepth(TreeNode root)&#123; if(root == null) return 0; return Math.max(1+getDepth(root.left),1+getDepth(root.right));&#125; 123456789101112public boolean IsBalanced_Solution(TreeNode root) &#123; return Judge(root) != -1;&#125;public int Judge(TreeNode root)&#123; if(root == null) return 0; int left = Judge(root.left); if(left == -1) return -1; int right = Judge(root.right); if(right == -1) return -1; return Math.abs(left-right)&gt;1 ? -1 : 1+Math.max(left,right);&#125; 思路&amp;&amp;总结借助平衡二叉树的定义：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。第一种做法：自上向下递归判断，缺点会重复遍历下层节点。第二种做法：自底向上递归判断，剪枝重复步骤，借助获取二叉树最大长度的方法，每次判断高度差超过1返回-1标志子树已经不满足平衡，不需要继续遍历。 (4)数组中只出现一次的数字题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 java12345678910111213141516public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0; i&lt;array.length; i++) if(set.contains(array[i])) set.remove(array[i]); else set.add(array[i]); Integer[] num = set.toArray(new Integer[set.size()]); //方法一，注意此处一定要用封装类型 num1[0] = num[0]; num2[0] = num[1]; /** 方法二 * Object[] num = set.toArray(); * num1[0] = (int)num[0]; * num2[0] = (int)num[1]; **/&#125; 思路&amp;&amp;总结借助set快速解决，注意set.toArray()的两种用法，要么使用Object[]数组，要么参数写入封装类数组。 (5)和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! java123456789101112131415161718ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; for(int i=1; i&lt;sum ;i++)&#123; Judge(sum,i,new ArrayList&lt;Integer&gt;()); &#125; return res;&#125;public void Judge(int sum,int n,ArrayList&lt;Integer&gt; list)&#123; if(sum == n)&#123; list.add(n); res.add(list); return; &#125;else if(sum &gt; n)&#123; list.add(n); Judge(sum-n,n+1,list); &#125; return ;&#125; 123456789101112131415161718public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); int i=1, j=2; while(i &lt; j)&#123; int cur = (i+j)*(j-i+1)/2; if(cur == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int k=i; k&lt;=j; k++) list.add(k); res.add(list); i++; &#125;else if(cur &lt; sum) j++; else i++; &#125; return res;&#125; 思路&amp;&amp;总结递归或滑动窗口（更优） (6)和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 java123456789101112131415public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; int i=0, j=array.length-1; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); while(i &lt; j)&#123; if(array[i]+array[j] == sum)&#123; res.add(array[i]); res.add(array[j]); return res; &#125;else if(array[i]+array[j] &lt; sum) i++; else j--; &#125; return res;&#125; 思路&amp;&amp;总结首位指针做法。 (7)左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ java1234567891011121314151617public String LeftRotateString(String str,int n) &#123; if(str.length() &lt; n) return ""; char[] num = str.toCharArray(); Reverse(num,0,n-1); Reverse(num,n,str.length()-1); Reverse(num,0,str.length()-1); return String.valueOf(num);&#125;public void Reverse(char[] str,int start,int end)&#123; while(end &gt; start)&#123; char tmp = str[start]; str[start] = str[end]; str[end] = tmp; start++; end--; &#125;&#125; 思路&amp;&amp;总结原理：YX = (XtYt)t (8)翻转单词顺序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ java123456789101112131415161718192021222324public String ReverseSentence(String str) &#123; char[] ch = str.toCharArray(); int i=0,j=0; while(i &lt; ch.length)&#123; while(i&lt;ch.length &amp;&amp; ch[i]==' ') i++; j = i; while(j&lt;ch.length &amp;&amp; ch[j]!=' ') j++; Reverse(ch,i,j-1); i = j; &#125; Reverse(ch,0,ch.length-1); return String.valueOf(ch);&#125;public void Reverse(char[] str,int start,int end)&#123; while(end &gt; start)&#123; char tmp = str[start]; str[start] = str[end]; str[end] = tmp; start++; end--; &#125;&#125; 123456789101112public String ReverseSentence(String str) &#123; if(str.trim().equals("")) return str; String[] tmp = str.split(" "); StringBuffer sb = new StringBuffer(); for(int i=tmp.length-1; i&gt;=0; i--)&#123; sb.append(tmp[i]); if(i != 0) sb.append(" "); &#125; return sb.toString();&#125; 思路&amp;&amp;总结方法一：同（7），将每个单词反转，最后将整个字符串反转即可。方法二：利用split方法获取每个单词，逆向输出补上空格即可，缺点在于无法处理“ a”这样的情况]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Space&&Time]]></title>
    <url>%2F2020%2F02%2F23%2F20200223-offer%2F</url>
    <content type="text"><![CDATA[(1)丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 java123456789101112131415161718public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); int i2=0, i3=0, i5=0; while(list.size() &lt; index)&#123; int t2 = list.get(i2)*2; int t3 = list.get(i3)*3; int t5 = list.get(i5)*5; int min = Math.min(t2,Math.min(t3,t5)); list.add(min); if(min == t2) i2++; if(min == t3) i3++; if(min == t5) i5++; &#125; return list.get(list.size()-1);&#125; 思路&amp;&amp;总结这道题其实真的不太容易想，首先如果从1～♾判断丑数，那么会超时。我们只能通过丑数的三个因子2，3，5和第一个丑数1进行累乘求一下个最小的丑数。需要注意的是每次求出下一个最小的丑数，那么使用的因子要相应的做好记录，方便下一次的计算。 (2)第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. java12345678910111213public int FirstNotRepeatingChar(String str) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); char[] num = str.toCharArray(); for(int i=0; i&lt;num.length; i++) if(map.containsKey(num[i])) map.put(num[i],map.get(num[i])+1); else map.put(num[i],1); for(int i=0; i&lt;num.length; i++) if(map.get(num[i]) == 1) return i; return -1;&#125; 思路&amp;&amp;总结出现次数，首先联想利用map计数解决。 (3)数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 java123456789101112131415161718192021222324252627282930int res = 0;public int InversePairs(int [] array) &#123; mergeSort(array,0,array.length-1); return res%1000000007;&#125;void mergeSort(int[] array,int low,int high)&#123; if(low &gt;= high) return; int mid = (low+high)/2; mergeSort(array,low,mid); mergeSort(array,mid+1,high); merge(array,low,mid,high);&#125;void merge(int[] array,int low,int mid,int end)&#123; int[] tmp = new int[end-low+1]; int index = 0, l = low, r = mid+1; while(l&lt;=mid &amp;&amp; r&lt;=end)&#123; if(array[l] &gt; array[r])&#123; res = (res+mid-l+1)%1000000007; //这里很坑，不加余就会报错 tmp[index++] = array[r++]; &#125;else tmp[index++] = array[l++]; &#125; while(l &lt;= mid) tmp[index++] = array[l++]; while(r &lt;= end) tmp[index++] = array[r++]; for(int i=0; i&lt;tmp.length; i++) array[low+i] = tmp[i];&#125; 思路&amp;&amp;总结1、暴力法可解，但时间复杂度高一般都会被卡时间。2、利用二分+递归思想，借助归并排序过程可解，研一高级算法课上原题。tip：这题的%1000000007我依旧没有搞懂，尤其是结果累计那部分，如果不加%1000000007就只能通过50%的case。 (4)两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） java123456789//天秀public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1=pHead1, p2=pHead2; while(p1 != p2)&#123; p1 = (p1==null ? pHead2 : p1.next); p2 = (p2==null ? pHead1 : p2.next); &#125; return p1;&#125; 1234567891011121314public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; ListNode p1 = pHead1, p2 = pHead2; List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); while(p1 != null)&#123; list.add(p1); p1 = p1.next; &#125; while(p2 != null)&#123; if(list.contains(p2)) return p2; p2 = p2.next; &#125; return null;&#125; 思路&amp;&amp;总结三种解法（1）先遍历两个链表获得长度，计算出长度差k，让长的链表先走k步，然后同步即可找到公共节点。（略）（2）借助一个list存储一个链表，然后遍历第二个链表找公共节点。缺点空间复杂度O(N)（3）两个指针同时走，走到头就从另一链表的头开始重新走 因为len1+len2==len2+len1并且公共节点到尾部的长度是共享的（即相等长） 所以最晚第二次走一定能找到公共节点，两条链表等长则一次就能找到。 tip：如果两条链表没有公共节点会死循环，可以借助标志位只让循环两次解决这个问题。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-space&amp;&amp;time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Decompose and Efficiency]]></title>
    <url>%2F2020%2F02%2F22%2F20200222-offer%2F</url>
    <content type="text"><![CDATA[(1)复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） java12345678910111213141516171819202122232425262728public RandomListNode Clone(RandomListNode pHead)&#123; if(pHead == null) return null; RandomListNode dummy1 = new RandomListNode(-1); dummy1.next = pHead; while(pHead != null)&#123; RandomListNode tmp = new RandomListNode(pHead.label); tmp.next = pHead.next; pHead.next = tmp; pHead = pHead.next.next; &#125; RandomListNode pre = dummy1.next; while(pre != null)&#123; RandomListNode p = pre.next; p.random = pre.random==null?null:pre.random.next;//注意random指针也可能为空 pre = p.next; &#125; RandomListNode dummy2 = new RandomListNode(-2); RandomListNode d2 = dummy2; pre = dummy1.next; while(pre != null)&#123; d2.next = pre.next; pre.next = pre.next.next; d2 = d2.next; pre = pre.next; &#125; return dummy2.next;&#125; 思路&amp;&amp;总结解题思路：1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;3、拆分链表，将链表拆分为原链表和复制后的链表 (2)二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 java123456789101112131415161718192021222324//非递归版本，利用中序遍历方法public TreeNode Convert(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode p = root , pre = null; boolean flag = true; while(!stack.isEmpty() || p!=null)&#123; while(p != null)&#123; stack.push(p); p = p.left; &#125; p = stack.pop(); if(flag)&#123; root = p; pre = p; flag = false; &#125;else&#123; pre.right = p; p.left = pre; pre = p; &#125; p = p.right; &#125; return root;&#125; 123456789101112131415161718//递归版本public TreeNode Convert(TreeNode root) &#123; if(root == null) return null; if(root.left==null &amp;&amp; root.right==null) return root; TreeNode left = Convert(root.left); if(left != null)&#123; TreeNode p =left; while(p!=null &amp;&amp; p.right!=null) p = p.right; p.right = root; root.left = p; &#125; TreeNode right = Convert(root.right); if(right != null)&#123; root.right = right; right.left = root; &#125; return left!=null?left:root; //return the head of the list&#125; 思路&amp;&amp;总结利用二叉搜索树的特性：中序遍历是升序序列。非递归版本和递归版本都是通过这一特性，然后记录前后节点的方式解决问题。非递归依托栈的特性记录前后节点。而非递归则每次返回list的head解决问题。 (3)字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 java12345678910111213141516171819202122232425262728public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(str==null || str.length()==0) return res; fullPermutation(res,str.toCharArray(),0); Collections.sort(res); //字典序 return res;&#125;public void fullPermutation(ArrayList&lt;String&gt; res,char[] num,int start)&#123; if(start == num.length-1)&#123; res.add(String.valueOf(num)); return; &#125; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int i=start;i&lt;num.length;i++)&#123; if(i==start || !set.contains(num[i]))&#123; //借助set排除重复 set.add(num[i]); swap(num,start,i); fullPermutation(res,num,start+1); swap(num,start,i); &#125; &#125;&#125;public void swap(char[] num,int a,int b)&#123; char tmp = num[a]; num[a] = num[b]; num[b] = tmp;&#125; 思路&amp;&amp;总结（1）固定第一个字符，递归取得首位后面的各种字符串组合；（2）再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合；tips：递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。 (4)数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 java12345678910111213141516public int MoreThanHalfNum_Solution(int [] array) &#123; if(array==null || array.length==0) return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int item:array) if(map.containsKey(item)) map.put(item,map.get(item)+1); else map.put(item,1); for(int k:map.keySet()) if(map.get(k)*2 &gt; array.length) return k; //for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()) // if(entry.getValue()*2 &gt; array.length) // return entry.getKey(); return 0;&#125; 思路&amp;&amp;总结(5)最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 java12345678public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(k &gt; input.length) return res; Arrays.sort(input); for(int i=0;i&lt;k;i++) res.add(input[i]); return res;&#125; 12345678910111213141516public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(k&gt;input.length || k==0) return res; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1,o2) -&gt; o2-o1); for(int i=0; i&lt;input.length; i++)&#123; if(heap.size() != k) heap.add(input[i]); else if(heap.peek() &gt; input[i])&#123; heap.poll(); heap.offer(input[i]); &#125; &#125; for(int item:heap) res.add(item); return res;&#125; 思路&amp;&amp;总结任意排序方法都能解决。或者使用堆来解决，时间效率更高。 (6)连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) java123456789101112//暴力法public int FindGreatestSumOfSubArray(int[] array) &#123; int max = Integer.MIN_VALUE; for(int i=0; i&lt;array.length; i++)&#123; int tmax = 0; for(int j=i; tmax&gt;=0 &amp;&amp; j&lt;array.length; j++)&#123; tmax+=array[j]; max = Math.max(max,tmax); &#125; &#125; return max;&#125; 123456789public int FindGreatestSumOfSubArray(int[] array) &#123; int res = array[0];//记录dp过程中所有子数组的和的最大值 int max = array[0];//dp过程中当前长度数组的连续子数组和最大值 for(int i=1; i&lt;array.length; i++)&#123; max = Math.max(max+array[i], array[i]); res = Math.max(res,max); &#125; return res;&#125; 思路&amp;&amp;总结动态规划解法较优。见注释 (7)整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 java1234567891011public int NumberOf1Between1AndN_Solution(int n) &#123; int res = 0; StringBuffer sb = new StringBuffer(); for(int i=0; i&lt;=n; i++) sb.append(i); char[] num = sb.toString().toCharArray(); for(int i=0;i&lt;num.length;i++) if(num[i] == '1') res++; return res;&#125; 思路&amp;&amp;总结(8)把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 java1234567891011public String PrintMinNumber(int [] num) &#123; if(num==null || num.length==0) return ""; String[] arr = new String[num.length]; for(int i=0; i&lt;num.length; i++) arr[i] = String.valueOf(num[i]); Arrays.sort(arr,(o1,o2) -&gt; (o1+o2).compareTo(o2+o1));//匿名函数 StringBuffer sb = new StringBuffer(); for(int i=0; i&lt;num.length; i++) sb.append(arr[i]); return sb.toString();&#125; 123456789//比较器常规写法Arrays.sort(arr,new Comparator&lt;String&gt;()&#123; @Override public int compare(String o1,String o2)&#123; String c1 = o1 + o2; String c2 = o2 + o1; return c1.compareTo(c2); &#125; &#125;); 思路&amp;&amp;总结数组转为String类型，然后进行排序，利用比较器修改排序规则：（1）如果a+b&lt;b+a，那么说明a和b组合时，b越靠后最终结果越小。（2）每次这样比较两个元素，将（1）中的比较遍历全数组后将数组拼接即是最小的数。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-decompose and efficiency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Abstract]]></title>
    <url>%2F2020%2F02%2F21%2F20200221-offer%2F</url>
    <content type="text"><![CDATA[(1)包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。 java123456789101112131415161718192021222324public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minNum = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); if(minNum.size()==0)&#123; minNum.push(node); return; &#125; if(node &lt; minNum.peek()) minNum.push(node); else minNum.push(minNum.peek()); &#125; public void pop() &#123; stack.pop(); minNum.pop(); &#125; public int top() &#123; minNum.pop(); return stack.peek(); &#125; public int min() &#123; return minNum.peek(); &#125;&#125; 思路&amp;&amp;总结辅助栈记录最小值。 (2)栈的压入、弹出操作题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） java1234567891011121314public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length==0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int index = 0; for(int i=0; i&lt;pushA.length; i++)&#123; stack.push(pushA[i]); while(!stack.isEmpty() &amp;&amp; stack.peek()==popA[index])&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty();&#125; 思路&amp;&amp;总结借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 (3)从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印 java1234567891011121314public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty())&#123; TreeNode tmp = queue.poll(); if(tmp != null)&#123; res.add(tmp.val); queue.add(tmp.left); queue.add(tmp.right); &#125; &#125; return res;&#125; 思路&amp;&amp;总结二叉树的层序遍历。 (4)二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 java12345678910111213141516public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null || sequence.length==0) return false; return Judge(sequence,0,sequence.length-1);&#125;public boolean Judge(int[] sequence,int start,int end)&#123; if(start &gt;= end) return true; int index = end-1; while(index&gt;=start &amp;&amp; sequence[index]&gt;sequence[end]) index--; for(int i=0; i&lt;=index; i++) if(sequence[i] &gt; sequence[end]) return false; return Judge(sequence,start,index) &amp;&amp; Judge(sequence,index+1,end-1);&#125; 思路&amp;&amp;总结利用后序序列的特征递归即可。后序序列特征：（1）序列的最后一个元素e为根。（2）去掉e后的序列T可以分为[T1,T2]，其中T1为e的左子树（所有元素小于e），T2为e的右子树(所有元素大于e)（3）T1，T2都是后序序列。 (5)二叉树中和为某一值的路径题目描述输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) java123456789101112131415161718public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Find(res,list,root,target); return res;&#125;public void Find(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; list,TreeNode root,int target)&#123; if(root == null) return; list.add(root.val); target-=root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add(new ArrayList&lt;Integer&gt;(list)); Find(res,list,root.left,target); Find(res,list,root.right,target); list.remove(list.size()-1);&#125; 1234567891011121314ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return res; list.add(root.val); target-=root.val; if(target==0 &amp;&amp; root.left==null &amp;&amp; root.right==null) res.add(new ArrayList&lt;&gt;(list)); FindPath(root.left,target); FindPath(root.right,target); list.remove(list.size()-1); return res;&#125; 思路&amp;&amp;总结深度优先遍历。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-abstract</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Mess]]></title>
    <url>%2F2020%2F02%2F20%2F20200220-offer%2F</url>
    <content type="text"><![CDATA[(1)二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 java123456789public int NumberOf1(int n) &#123; int count = 0, flag = 1; while(flag != 0)&#123; if((flag &amp; n) != 0) //注意位运算符优先级 count++; flag = flag &lt;&lt; 1; &#125; return count;&#125; 12345678public int NumberOf1(int n) &#123; int count = 0; while(n != 0)&#123; count++; n = (n - 1) &amp; n; //n最右边的1被消去了 &#125; return count;&#125; 思路&amp;&amp;总结见注释，略。 (2)数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 java1234567891011121314public double Power(double base, int exponent) &#123; double res = 1; int n = exponent; if(exponent == 0) return 1; if(exponent &lt; 0) n = -n; while(n != 0)&#123; if(n%2 == 1)//偶数时这个if只用最后一次，奇数时这个if第一次和最后一次用两次 res*=base; base*=base; n = n/2; &#125; return exponent&gt;0?res:1/res;&#125; 123456789101112131415public double Power(double base, int exponent) &#123; if(exponent == 0) return 1; if(exponent &lt; 0)&#123; exponent = -exponent; base = 1/base; &#125; double res = 1; while(exponent != 0)&#123; if(exponent%2 == 1) res*=base; base*=base; exponent/=2; &#125; return res;&#125; 思路&amp;&amp;总结见注释，略。 (3)调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 java123456789101112131415//借助辅助空间public void reOrderArray(int [] array) &#123; List&lt;Integer&gt; odd = new ArrayList&lt;&gt;(); List&lt;Integer&gt; even = new ArrayList&lt;&gt;(); for(int i=0; i&lt;array.length; i++)&#123; if((array[i]&amp;1) == 1) odd.add(array[i]); else even.add(array[i]); &#125; for(int i=0; i&lt;odd.size(); i++) array[i] = odd.get(i); for(int i=0; i&lt;even.size(); i++) array[i+odd.size()] = even.get(i);&#125; 12345678910111213141516171819202122232425//不借助辅助空间，但时间效率增加public void reOrderArray(int [] array) &#123;//冒泡 for(int i=array.length-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;i; j++)&#123; if(array[j]%2==0 &amp;&amp; array[j+1]%2==1)&#123; int tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125;&#125;public void reOrderArray(int [] array) &#123;//插入 int start = 0, index = 0; while(index &lt; array.length)&#123; if(array[index]%2 == 1)&#123; int tmp = array[index]; for(int i=index; i&gt;start; i--) array[i] = array[i-1]; array[start] = tmp; start++; &#125; index++; &#125; &#125; 思路&amp;&amp;总结略。 (4)链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 java12345678910public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode p1 = head, p2 = head; int i = 0; for( ; p2!=null; i++)&#123; if(i &gt;= k) p1 = p1.next; p2 = p2.next; &#125; return i&gt;=k ? p1:null;&#125; 思路&amp;&amp;总结目前最优解：设置两个指针，p1，p2，先让p2走k步，然后再一起走，直到p2为null时，p1即为倒数第k个节点。可行解：使用计数或者倒置链表的方法。 (5)反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 java12345678910public ListNode ReverseList(ListNode head) &#123; ListNode pre = null, cur = head; while(cur != null)&#123; ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; &#125; return pre;&#125; 思路&amp;&amp;总结熟记，略。 (6)合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 java12345678910111213141516171819202122232425//非递归public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode dummy = new ListNode(-1), index = dummy; while(list1!=null &amp;&amp; list2!=null)&#123; if(list1.val &lt; list2.val)&#123; index.next = new ListNode(list1.val); list1 = list1.next; &#125;else&#123; index.next = new ListNode(list2.val); list2 = list2.next; &#125; index = index.next; &#125; while(list1 != null)&#123; index.next = new ListNode(list1.val); list1 = list1.next; index = index.next; &#125; while(list2 != null)&#123; index.next = new ListNode(list2.val); list2 = list2.next; index = index.next; &#125; return dummy.next;&#125; 1234567891011121314//递归public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; if(list1.val &lt; list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125;&#125; 思路&amp;&amp;总结熟悉递归做法，略。 (7)树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） java12345678910111213141516171819public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root1==null || root2==null) return false; boolean res = false; if(root1.val == root2.val) res = Judge(root1,root2); if(res == false) res = HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2); return res;&#125;public boolean Judge(TreeNode node1, TreeNode node2)&#123; if(node2 == null) return true; if(node1 == null) return false; if(node1.val != node2.val) return false; return Judge(node1.left,node2.left) &amp;&amp; Judge(node1.right,node2.right);&#125; 思路&amp;&amp;总结注意题目是子结构，所以只要将root2对比完没有出现比对失败即可。两次递归，第一次递归寻找节点相同的头节点，调用方法进行第二次递归判断是否子结构。注意中间最好使用一个布尔类型res中间值进行结果记录。 (8)二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / 6 10 / \ / 5 7 9 11 镜像二叉树 8 / 10 6 / \ / 11 9 7 5 java123456789101112public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left==null &amp;&amp; root.right==null) return; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; Mirror(root.left); Mirror(root.right);&#125; 思路&amp;&amp;总结略。 (9)顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. java12345678910111213141516171819public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = matrix.length; if(n == 0) return res; int m = matrix[0].length; int k = (Math.min(n,m)-1)/2+1; //层数 for(int i=0; i&lt;k; i++)&#123; for(int a=i; a&lt;m-i; a++) res.add(matrix[i][a]); for(int a=i+1; a&lt;n-i; a++) res.add(matrix[a][m-i-1]); for(int a=m-2-i; a&gt;=i &amp;&amp; n-i-1!=i; a--) //注意重复判断 res.add(matrix[n-1-i][a]); for(int a=n-2-i; a&gt;i &amp;&amp; m-i-1!=i; a--) res.add(matrix[a][i]); &#125; return res;&#125; 思路&amp;&amp;总结（1）确定层数，注意奇数偶数情况（2）针对层数进行循环，循环体内是4个for遍历一组打印出当前层。tip：注意后面两个for的起始受前两次输出影响要多-1，然后要进行重复判断。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Sort&&Recursion]]></title>
    <url>%2F2020%2F02%2F19%2F20200219-offer%2F</url>
    <content type="text"><![CDATA[(1)旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0 java12345678910111213public int minNumberInRotateArray(int [] array) &#123; int low = 0, high = array.length-1; while(low &lt; high)&#123; int mid = (low+high)/2; if(array[mid] &gt; array[high]) low = mid+1; else if(array[mid] == array[high]) high--; else high = mid; &#125; return array[low];&#125; 思路&amp;&amp;总结摘牛课评论区大佬的总结，非常到位。链接：https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion来源：牛客网 采用二分法解答这个问题，mid = low + (high - low)/2需要考虑三种情况：(1)array[mid] &gt; array[high]:出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。low = mid + 1(2)array[mid] == array[high]:出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ，high = high - 1(3)array[mid] &lt; array[high]:出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。high = mid注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字比如 array = [4,6]array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;如果high = mid - 1，就会产生错误， 因此high = mid但情形(1)中low = mid + 1就不会错误 (2)斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 java1234567public int Fibonacci(int n) &#123; if(n == 1) return 1; if(n == 0) return 0; return Fibonacci(n-1)+Fibonacci(n-2);&#125; 1234567891011public int Fibonacci(int n) &#123; if(n == 0) return 0; if(n &lt;= 2) return 1; int f1 = 1, f2 = 1; for(int i=3; i&lt;=n; i++)&#123; int temp = f1+f2; f1 = f2; f2 = temp; &#125; return f2;&#125; 思路&amp;&amp;总结略。 (3)跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 java12345public int JumpFloor(int target) &#123; if(target==0 || target==1) return 1; return JumpFloor(target-1) + JumpFloor(target-2);&#125; 思路&amp;&amp;总结略。 (3)变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 java12345public int JumpFloorII(int n) &#123; if(n == 1) return 1; return 1 + 2*JumpFloorII(n-1) - 1;&#125; 思路&amp;&amp;总结跳n阶可能步骤 -&gt; 一次跳n阶【1种】 跳1阶 + 跳n-1阶【共JumpFloorII（n-1）种】 跳n-1阶 + 跳1阶【共JumpFloorII（n-1）种】所以递归公式：JumpFloorII(n) = 1 + 2*JumpFloorII(n-1) - 1减一是因为全跳1步被重复计算了一次 (4)矩阵覆盖题目描述我们可以用2&times;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&times;1的小矩形无重叠地覆盖一个2&times;n的大矩形，总共有多少种方法？ 比如n=3时，2*3的矩形块有3种覆盖方法： java123456789public int RectCover(int target) &#123; if(target == 2) return 2; if(target == 1) return 1; if(target == 0) return 0; return RectCover(target-1) + RectCover(target-2);&#125; 思路&amp;&amp;总结同（2）略。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-sort&amp;recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Stack&&Queue]]></title>
    <url>%2F2020%2F02%2F17%2F20200217-offer%2F</url>
    <content type="text"><![CDATA[(1)用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型 java1234567891011121314151617Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) &#123; stack1.push(node);&#125;public int pop() &#123; if(stack2.size() &gt; 0) return stack2.pop(); else&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125;&#125; 思路&amp;&amp;总结两个栈一个负责入队列一个负责出队列，注意stack2为空时要将stack1中的所有元素都依次拿过来。 (2)滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 java12345678910111213141516//代码简洁，复杂度高public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)&#123; if(num==null || num.length==0 || size==0 || size&gt;num.length) return new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0; i&lt;=num.length-size; i++) res.add(getMax(num,i,size)); return res;&#125;public int getMax(int[] num, int start, int size)&#123; int max = num[start]; for(int i=start; i&lt;start+size; i++) max = Math.max(num[i],max); return max;&#125; 123456789101112131415161718192021222324252627//经过优化，效率更高public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)&#123; if(num==null || num.length==0 || size==0 || size&gt;num.length) return new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int start = 0, end = size-1; int index = getMax(num,start,end); while(end &lt; num.length)&#123; if(index&gt;=start &amp;&amp; index&lt;=end)&#123; if(num[end] &gt; num[index]) index = end; &#125;else index = getMax(num,start,end); res.add(num[index]); start++; end++; &#125; return res;&#125;public int getMax(int[] num, int start, int end)&#123; int index = start; for(int i=start+1; i&lt;=end; i++) if(num[index] &lt; num[i]) index = i; return index;&#125; 思路&amp;&amp;总结略。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-stack&amp;&amp;queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Tree]]></title>
    <url>%2F2020%2F02%2F10%2F20200210-offer%2F</url>
    <content type="text"><![CDATA[(1)重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 java1234567891011121314151617//直接递归求解public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root = CreateTree(pre,0,pre.length-1,in,0); return root;&#125;public TreeNode CreateTree(int[] pre,int preStart,int preEnd,int[] in,int inStart)&#123; if(preStart &gt; preEnd) return null; TreeNode node = new TreeNode(pre[preStart]); int i; for(i=0;i&lt;in.length;i++) if(pre[preStart] == in[i]) break; node.left = CreateTree(pre,preStart+1,i-inStart+preStart,in,inStart); node.right = CreateTree(pre,i-inStart+preStart+1,preEnd,in,i+1); return node;&#125; 12345678910111213141516171819202122//借助一个Map存储中序序列求解import java.util.*;public class Solution &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; for(int i=0;i&lt;in.length;i++) map.put(in[i],i); TreeNode root = CreateTree(pre,0,pre.length-1,0); return root; &#125; public TreeNode CreateTree(int[] pre,int preStart,int preEnd,int inStart)&#123; if(preStart &gt; preEnd) return null; TreeNode node = new TreeNode(pre[preStart]); int index = map.get(pre[preStart]); int leftTree = index - inStart; node.left = CreateTree(pre,preStart+1,preStart+leftTree,inStart); node.right = CreateTree(pre,preStart+leftTree+1,preEnd,index+1); return node; &#125;&#125; 思路&amp;&amp;总结经典二叉树数据结构算法题，使用preOrder和inOrder的特性结合递归求解。 两种做法都可以，前者不需要辅助空间但是细节较多。 此题要多刷熟练掌握！Important (2)二叉树的下一个节点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 java1234567891011121314151617public TreeLinkNode GetNext(TreeLinkNode pNode)&#123; if(pNode == null) return null; if(pNode.right != null)&#123; //如果有右子树，则找右子树的最左节点 TreeLinkNode node = pNode.right; while(node.left != null) node = node.left; return node; &#125; while(pNode.next != null)&#123; //没右子树，则找向上找满足把当前节点作为左子树中节点的父节点（上面已经判断过了节点没有右子树） if(pNode.next.left == pNode) return pNode.next; pNode = pNode.next; &#125; return null; //退到了根节点仍没找到，则返回null&#125; 思路&amp;&amp;总结需要非常熟悉中序遍历的顺序和特点。中序遍历中一个节点root的下一个节点只有两种情况：（1）root右子树中的最左节点（2）一个节点node，他的左子树中最后遍历到的节点是root（在root不满足（1）的情况下这是自然的） (3)对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 java12345678910111213141516//递归方法boolean isSymmetrical(TreeNode pRoot)&#123; if(pRoot == null) return true; return JudgeTree(pRoot.left,pRoot.right);&#125;boolean JudgeTree(TreeNode node1, TreeNode node2)&#123; if(node1 == null) return node2 == null; else if(node2 == null) return false; if(node1.val != node2.val) return false; return JudgeTree(node1.left,node2.right) &amp;&amp; JudgeTree(node1.right,node2.left);&#125; 123456789101112131415161718192021//DFS非递归方法，借助栈实现（BFS借助Queue实现，类似，略）boolean isSymmetricalDFS(TreeNode pRoot)&#123; if(pRoot == null) return true; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(pRoot.left); s.push(pRoot.right); while(!s.empty()) &#123; TreeNode right = s.pop();//成对取出 TreeNode left = s.pop(); if(left == null &amp;&amp; right == null) continue; if(left == null || right == null) return false; if(left.val != right.val) return false; //成对插入 s.push(left.left); s.push(right.right); s.push(left.right); s.push(right.left); &#125; return true;&#125; 思路&amp;&amp;总结首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同左子树的右子树和右子树的左子树相同即可，采用递归非递归也可，采用栈或队列存取各级子树根节点 (4)按之字形次序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 java12345678910111213141516171819202122232425262728293031323334353637public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123; if(pRoot == null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); boolean flag = true; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); ArrayList&lt;TreeNode&gt; t = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; TreeNode tn = queue.poll(); if(tn != null)&#123; tmp.add(tn.val); t.add(tn); &#125; &#125; if(flag == true &amp;&amp; tmp.size()!=0)&#123; res.add(tmp); flag = false; &#125;else if(flag==false &amp;&amp; tmp.size()!=0)&#123; res.add(ReverseList(tmp)); flag = true; &#125; for(int i=0;i&lt;t.size();i++)&#123; queue.add(t.get(i).left); queue.add(t.get(i).right); &#125; &#125; return res;&#125;public ArrayList&lt;Integer&gt; ReverseList(ArrayList&lt;Integer&gt; list)&#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i=list.size()-1;i&gt;=0;i--) res.add(list.get(i)); return res;&#125; 思路&amp;&amp;总结层序遍历输出的基础上添加一个标志位在偶数行的情况下进行逆序即可，注意细节。 (5)把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 java12345678910111213141516171819202122232425//层序遍历方法ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; if(pRoot == null) return new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); ArrayList&lt;TreeNode&gt; t = new ArrayList&lt;TreeNode&gt;(); while(!queue.isEmpty())&#123; TreeNode tn = queue.poll(); if(tn != null) &#123; tmp.add(tn.val); t.add(tn); &#125; &#125; for(int i=0;i&lt;t.size();i++)&#123; queue.add(t.get(i).left); queue.add(t.get(i).right); &#125; if(tmp.size() &gt; 0) res.add(tmp); &#125; return res;&#125; 1234567891011121314//DFS方法ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); DFS(pRoot,res,1); return res;&#125;void DFS(TreeNode root,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,int depth)&#123; if(root == null) return; if(depth &gt; res.size()) res.add(new ArrayList&lt;Integer&gt;()); res.get(depth-1).add(root.val); DFS(root.left,res,depth+1); DFS(root.right,res,depth+1);&#125; 思路&amp;&amp;总结经典题，常规思维使用层序遍历可以解决，做法注意细节要牢记。还可以使用DFS的方法用递归做，比较巧妙，代码简洁。 (6)序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 java12345678910111213141516171819202122232425int index = -1; //计数器String Serialize(TreeNode root) &#123; StringBuffer sb = new StringBuffer(); if(root == null)&#123; sb.append("#,"); return sb.toString(); &#125; sb.append(root.val+","); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString();&#125;TreeNode Deserialize(String str) &#123; if(str == null || str.length()==0) return null; index++; String[] arr = str.split(","); TreeNode root = null; if(!arr[index].equals("#"))&#123; //String用equals切记 root = new TreeNode(Integer.valueOf(arr[index])); //类型转换 root.left = Deserialize(str); root.right = Deserialize(str); &#125; return root;&#125; 思路&amp;&amp;总结需要选择一种遍历二叉树的方式（我使用了先序，中后层也都可以），然后按照这种遍历方式去序列化二叉树，在空节点的地方要插入一个标识。反序列化时，按照遍历方式反相解析即可任意一种遍历方式加上空节点标识即可确定一棵二叉树 (7)二叉搜索树的第k个节点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 java1234567891011121314151617181920212223//递归中序遍历int n; //计数TreeNode res;TreeNode KthNode(TreeNode pRoot, int k)&#123; if(pRoot==null || k==0) return null; n = k; Judge(pRoot); if(res == null) return null; return res;&#125;public void Judge(TreeNode root)&#123; if(root == null) return;//递归终止条件 Judge(root.left); if(n == 1)&#123; res = root; n = -1; return; &#125; else n--; Judge(root.right);&#125; 12345678910111213141516171819TreeNode KthNode(TreeNode pRoot, int k) &#123; //非递归中序遍历，借助栈 if(pRoot==null || k==0) return null; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || pRoot!=null)&#123; if(pRoot != null)&#123; stack.push(pRoot); pRoot = pRoot.left; &#125;else&#123; pRoot = stack.pop(); if(--k == 0) return pRoot; pRoot = pRoot.right; &#125; &#125; return null; &#125; 思路&amp;&amp;总结充分利用二叉搜索树的条件，二叉搜索树的中序遍历序列是一个升序序列。 (8)数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 java1234567891011121314//使用一个list获取数据流，获取中位数时进行排序处理List&lt;Integer&gt; list = new ArrayList&lt;&gt;();public void Insert(Integer num) &#123; list.add(num);&#125;public Double GetMedian() &#123; Collections.sort(list); if(list.size()%2 == 1) return Double.valueOf(list.get(list.size()/2)); else return (list.get(list.size()/2-1)+list.get(list.size()/2))/2.0;&#125; 123456789101112131415161718192021//使用优先队列处理，效率更高private PriorityQueue&lt;Integer&gt; leftQ = new PriorityQueue&lt;&gt;();private PriorityQueue&lt;Integer&gt; rightQ = new PriorityQueue&lt;&gt;((o1,o2) -&gt; o2-o1);private boolean isOdd = false;public void Insert(Integer num) &#123; if(isOdd)&#123; leftQ.add(num); //左右互搏 rightQ.add(leftQ.poll()); &#125;else&#123; rightQ.add(num); leftQ.add(rightQ.poll()); &#125; isOdd = !isOdd;&#125;public Double GetMedian() &#123; if(isOdd) return Double.valueOf(leftQ.peek()); else return (leftQ.peek()+rightQ.peek())/2.0;&#125; 思路&amp;&amp;总结第一种方法不多说，只要注意index-1常识即可，比较容易。第二种利用优先队列的方法，是利用一个升序和一个降序优先队列（小顶堆和大顶堆）存储数据流，控制两个优先队列长度差不超过1（你加一来我加一）。从而将中位数一直暴露在两个堆的堆顶（注意奇偶情况）。注意有一个左右互搏的操作，是用来确保两个堆中的数据没有大小交错的情况产生]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Linkedlist]]></title>
    <url>%2F2020%2F02%2F08%2F20200208-offer%2F</url>
    <content type="text"><![CDATA[(1)从尾到头打印链表题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 java1234567891011121314151617181920import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ListNode pre = null; ListNode cur = listNode; while(cur != null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; ListNode i = pre; while(i != null)&#123; res.add(i.val); i = i.next; &#125; return res; &#125;&#125; 思路&amp;&amp;总结由于之前做过lc中的翻转链表的题目，第一反应就是把链表翻转了做。但其实利用栈的特性 或者存储list后翻转list也都是可以的。题目比较简单做法都比较容易，自己做的时候注意到返回值要求ArrayList用List去返回是不对的，lisk替换原则是不能倒过来用的，所以一定要用子类。 (2)链表中环的入口节点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 java123456789101112131415161718192021//利用辅助空间做法import java.util.*;public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null || pHead.next==null) return null; List&lt;ListNode&gt; helper = new ArrayList&lt;&gt;(); ListNode index = pHead; while(index != null)&#123; if(helper.contains(index)) return index; else helper.add(index); index = index.next; &#125; return null; &#125;&#125; 1234567891011121314151617181920212223//不利用辅助空间做法public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode fast = pHead; ListNode slow = pHead; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow) break; &#125; if(fast==null || fast.next==null) return null; slow = pHead; while(fast != slow)&#123; slow = slow.next; fast = fast.next; &#125; return fast; &#125;&#125; 思路&amp;&amp;总结利用辅助空间的做法比较常规很容易想到使用一个list来存储出现过的节点，第一个重复节点就是环的入口。 链接：https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4?f=discussion来源：牛客网不利用辅助空间的方法比较巧妙，用到两个结论：1、设置快慢指针，假如有环，他们最后一定相遇。2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇于环入口。结论1不解释，结论二是可以通过数学公式证明的： 链表头到环入口长度为–a环入口到相遇点长度为–b相遇点到环入口长度为–c 则：相遇时快指针路程=a+(b+c)k+b ，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。慢指针路程=a+b快指针走的路程是慢指针的两倍，所以：（a+b）*2=a+(b+c)k+b化简可得：a=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k&gt;=1,所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。 (3)删除链表中重复的节点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 java123456789101112131415161718192021public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; ListNode dummy = new ListNode(-1); dummy.next = pHead; ListNode pre = dummy, cur = pHead; while(cur != null)&#123; if(cur.next!=null &amp;&amp; cur.val==cur.next.val)&#123; while(cur.next!=null &amp;&amp; cur.val==cur.next.val)&#123; cur = cur.next; &#125; pre.next = cur.next; cur = pre.next; &#125;else&#123; pre = cur; cur = cur.next; &#125; &#125; return dummy.next; &#125;&#125; 思路&amp;&amp;总结 首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况 设置 pre ,cur 指针， pre指针指向当前确定不重复的那个节点，而cur指针相当于工作指针，一直往后面搜索。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打家劫舍 III-lc337]]></title>
    <url>%2F2020%2F01%2F09%2F20200109-lc337%2F</url>
    <content type="text"><![CDATA[题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 12345 3 / \2 3 \ \ 3 1 输出: 7解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.示例 2: 输入: [3,4,5,1,3,null,1] 12345 3 / \ 4 5 / \ \ 1 3 1 输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-iii java1234567891011121314151617class Solution &#123; public int rob(TreeNode root) &#123; int[] res = helper(root); return Math.max(res[0], res[1]); &#125; public int[] helper(TreeNode root)&#123; if(root == null) return new int[2]; int[] left = helper(root.left); int[] right = helper(root.right); //计算偷root和不偷root的情况 int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res; &#125;&#125; python3123456789101112class Solution: def rob(self, root: TreeNode) -&gt; int: res = self.helper(root) return max(res[0], res[1]) def helper(self, root: TreeNode) -&gt; list: if root is None: return [0,0] left, right, res = self.helper(root.left), self.helper(root.right), [0,0] res[0] = max(left[0],left[1]) + max(right[0],right[1]) res[1] = root.val + left[0] + right[0] return res 总结&amp;&amp;思路lc中等难度题，题目容易让人想到二叉树的层序遍历，但在这个题中一层偷一层不偷的两种情况是不完全的，因此不能用这种做法。取而代之的是使用动态规划的思想 对于每一个节点root，都保存一个长度为2的一维数组 数组中的第一个元素代表不偷root节点所能偷到的最大金额 数组中的第二个元素代表偷root节点所能偷到的最大金额 然后通过递归的方法自底向上获取每一个节点的数组，最后取跟节点数组中大的那个元素就是要求的值。这种方法非常巧妙利用动态规划的思想将求解。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-String]]></title>
    <url>%2F2020%2F01%2F07%2F20200107-offer%2F</url>
    <content type="text"><![CDATA[（1）替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 java123456789101112//use other spacepublic String replaceSpace(StringBuffer str) &#123; StringBuffer res = new StringBuffer(); char[] tmp = str.toString().toCharArray(); for(char x:tmp)&#123; if(x == ' ') res.append("%20"); else res.append(x); &#125; return res.toString();&#125; 12345678910111213141516171819202122//without other spacepublic String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==' ') spacenum++; &#125; int indexold = str.length()-1; //indexold为为替换前的str下标 int newlength = str.length() + spacenum*2; //计算空格转换成%20之后的str长度 int indexnew = newlength-1; //indexold为为把空格替换为%20后的str下标 str.setLength(newlength); //使str的长度扩大到转换成%20之后的长度,防止下标越界 for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == ' ')&#123; str.setCharAt(indexnew--, '0'); str.setCharAt(indexnew--, '2'); str.setCharAt(indexnew--, '%'); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125; 思路&amp;&amp;总结两种方法分别是使用辅助空间的和不使用辅助空间的，前者简单后者重要，另外要熟悉StringBuffer的使用。 （2）正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 java12345678910111213141516171819202122232425262728public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if(str==null || pattern==null) return false; int sIndex = 0; int pIndex = 0; return modelMatch(str, sIndex, pattern, pIndex); &#125; public boolean modelMatch(char[] str, int sIndex, char[] pattern, int pIndex) &#123; //匹配成功即双索引同时匹配到尾 if(sIndex==str.length &amp;&amp; pIndex==pattern.length) return true; //pIndex先到尾说明匹配失败 if(sIndex&lt;str.length &amp;&amp; pIndex==pattern.length) return false; if(pIndex+1&lt;pattern.length &amp;&amp; pattern[pIndex+1]=='*')&#123; if((sIndex&lt;str.length &amp;&amp; str[sIndex]==pattern[pIndex]) || (sIndex&lt;str.length&amp;&amp;pattern[pIndex]=='.')) return modelMatch(str, sIndex, pattern, pIndex+2)||modelMatch(str, sIndex+1, pattern, pIndex+2)||modelMatch(str, sIndex+1, pattern, pIndex); else return modelMatch(str, sIndex, pattern, pIndex+2); &#125; if((sIndex&lt;str.length &amp;&amp; str[sIndex]==pattern[pIndex]) || (pIndex&lt;pattern.length &amp;&amp; pattern[pIndex]=='.')) return modelMatch(str, sIndex+1, pattern, pIndex+1); return false; &#125;&#125; 思路&amp;&amp;总结这道题第一眼看上去没有思路，同样看了评论区大佬的思路才会写，可以通过双指针一次匹配进行判断，最重要的是pattern出现’*’时需要分成几种情况讨论，这里直接贴上评论区的精选思路：链接：https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?f=discussion来源：牛客网 当模式中的第二个字符不是“*”时：1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“”时：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：1、模式后移2字符，相当于x被忽略；2、字符串后移1字符，模式后移2字符；3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 这里需要注意的是：Java里，要时刻检验数组是否越界。 总结这题其实有思路后并不难，但是重要的是要非常的细致才行，一个细节错就满盘皆输，能够完全做对也是很有成就感的，string类型的题铺普遍如此，多练习。 （3）表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 java123456789101112131415//正则表达式解法public boolean isNumeric(char[] str) &#123; String string = String.valueOf(str); return string.matches("[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?");&#125;/*以下对正则进行解释:[\\+\\-]? -&gt; 正或负符号出现与否\\d* -&gt; 整数部分是否出现，如-.34 或 +3.34均符合(\\.\\d+)? -&gt; 如果出现小数点，那么小数点后面必须有数字； 否则一起不出现([eE][\\+\\-]?\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现， 紧接着必须跟着整数；或者整个部分都不出现*/ 123456789101112131415161718192021222324//逻辑判断方法public boolean isNumeric(char[] str) &#123; //标记符号，小数点，e是否出现过 boolean sign = false, decimal = false, hasE = false; for(int i=0; i&lt;str.length; i++)&#123; if(str[i]=='e' || str[i]=='E')&#123; if(hasE) return false;//e只能出现一次 if(i == str.length-1) return false;//e后面必须还有数字 hasE = true; &#125;else if(str[i]=='+' || str[i]=='-')&#123; // 第二次出现+-符号，则必须紧接在e之后 if(sign &amp;&amp; str[i-1]!='e' &amp;&amp; str[i-1]!='E') return false; // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后 if(!sign &amp;&amp; i&gt;0 &amp;&amp; str[i-1]!='e' &amp;&amp; str[i-1]!='E') return false; sign = true; &#125;else if(str[i] == '.')&#123; // e后面不能接小数点，小数点不能出现两次 if(hasE || decimal) return false; decimal = true; &#125;else if(str[i]&lt;'0' || str[i]&gt;'9') return false; &#125; return true;&#125; 思路&amp;&amp;总结正则表达式和另外一种catch异常的方法都算是比较巧妙的方法，并且我对正则表达式一点也不熟所以就贴上评论区大佬的方法和解释了，万一哪天我接触了呢（嘿嘿）常规的方法就是进行合理性的判断，将所有不合理的可能情况都if到即可，同样是string类题目的通病，比较繁琐细节较多，要非常细致才能做对。 （4）字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 java12345678910111213141516171819202122232425import java.util.*;public class Solution &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Character&gt; c = new ArrayList&lt;&gt;(); //Insert one char from stringstream public void Insert(char ch) &#123; if(map.containsKey(ch)) map.put(ch,map.get(ch)+1); else&#123; map.put(ch, 1); c.add(ch); &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for(char x:c)&#123; if(map.get(x)==1) return x; &#125; return '#'; &#125;&#125; 思路&amp;&amp;总结求出现次数这种类型的题很明显的可以借助Map来做计数处理，同时因为是要求输出第一个只出现一次的字符，所以再借助一个List来有序存储字符流即可。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STOffer-Array]]></title>
    <url>%2F2020%2F01%2F01%2F20200101-offer%2F</url>
    <content type="text"><![CDATA[（1）二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 java1234567891011121314151617public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array.length==0 || array[0].length==0) return false; int i = array.length-1; int j = 0; while(i&gt;=0 &amp;&amp; j&lt;array.length)&#123; if(array[i][j] == target) return true; else if(array[i][j] &gt; target) i--; else j++; &#125; return false; &#125;&#125; 思路&amp;&amp;总结 第一反应的通常做法是对二维数组的中每一个一维数组都做遍历进行查找，从上到下，从左到右进行遍历。可以实现但是不是最优。 讨论区大佬的更优思路：1、矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，2、因此从左下角开始查找，当要查找数字比左下角数字大时。右移3、要查找数字比左下角数字小时，上移 （2）数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 java123456789101112//借助辅助空间记录public boolean duplicate(int numbers[],int length,int[] duplication) &#123; boolean[] tmp = new boolean[length]; //初始化默认全false for(int i=0; i&lt;length; i++)&#123; if(tmp[numbers[i]] == true)&#123; duplication[0] = numbers[i]; return true; &#125; tmp[numbers[i]] = true; &#125; return false; &#125; 123456789101112//不借助辅助空间，在原数组中标记public boolean duplicate(int numbers[],int length,int [] duplication) &#123; for(int i=0; i&lt;length; i++)&#123; int index = numbers[i]&gt;=length? numbers[i]-length:numbers[i]; if(numbers[index] &gt;= length)&#123; duplication[0] = index; return true; &#125; numbers[index] += length; &#125; return false; &#125; 思路&amp;&amp;总结 常规做法是使用一个length长度的数组记录重复，boolean只占一位所以使用boolean[]占用空间较小，空间复杂度O(n),时间复杂度O(n)。 不借助辅助空间的思路是如果数组中存在两个A，那么他们的numbers[A]指向同一个元素，在遍历的时候每次都对number[number[i]]执行+length，那么在遇到number[i]重复时就会检测到number[number[i]] &gt;= length，而正常情况下数组元素是0～n-1。空间复杂度O(1),时间复杂度O(n)。 （3）构建乘积数组题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。 java123456789101112131415public class Solution &#123; public int[] multiply(int[] A) &#123; int[] B = new int[A.length]; if(B.length &gt; 0) B[0] = 1; for(int i=1; i&lt;A.length; i++) B[i] = B[i-1]*A[i-1]; int tmp = 1; for(int i=B.length-2; i&gt;=0; i--)&#123; tmp *= A[i+1]; B[i] *= tmp; &#125; return B; &#125;&#125; 思路&amp;&amp;总结每个B中元素可以看成由A中左右两边元素的积的积，分解为两次遍历分别求出左右两边的积最后合并是合适的思路，类似矩阵上三角的累积。取一个tmp=1，从A的最左边元素开始累乘，每次将值赋给B中对应的元素；再从A最右边累乘一遍，最后合并即可（第二遍顺便合并也可以）。]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair微信公众号的推送实现]]></title>
    <url>%2F2019%2F12%2F30%2F20191230-tec%2F</url>
    <content type="text"><![CDATA[前言2019的最后一次总结了，同学老哥在我准备面试的时候单独完成了这一次的开发任务，内容非常多也克服了很多的难点，即使作为一个划水人员还是要好好总结的。 这次主要实现的功能是调用微信提供的微信公众号推送api实现公众号的消息推送，并且在业务逻辑上需要多个微服务的数据进行通信完成功能。这次也是做好总结，方便回顾学习，温故而知新。 需求功能：调用wechat模块的推送接口，参数列表自定，推送的信息–&gt;代码逻辑业务功能如下：订单确认、发货、寄回、归还1)确认、发货、寄回：按照（orderId等等参数列表，越多越好）返回信息2)归还：接口判断日期如果是最后一天才按照orderId返回信息 学习总结腾讯提供的api功能腾讯提供的微信官方文档非常全面，本次开发涉及的公众号消息推送也做了非常详细的说明https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html首先公众号消息推送的大致流程是：在微信公众平台设定好所属行业（不同行业有不同的消息模板）–&gt; 获取模板列表 –&gt; 消息模板代码实现 –&gt; 将模板代码作为json数据推送到微信提供的url使用的推送类HttpClientUtils，将模板代码作为json数据推送到微信提供的url，可用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class HttpClientUtils &#123; private static Logger logger = LoggerFactory.getLogger(WechatProperties.class); //以jsonString形式发送HttpPost的Json请求，String形式返回响应结果 public static String sendPostJsonStr(String url, String jsonString) throws IOException &#123; if (jsonString == null || jsonString.isEmpty()) &#123; return sendPost(url); &#125; String resp = ""; StringEntity entityStr = new StringEntity(jsonString, ContentType.create("text/plain", "UTF-8")); CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); httpPost.setEntity(entityStr); CloseableHttpResponse response = null; try &#123; response = httpClient.execute(httpPost); HttpEntity entity = response.getEntity(); resp = EntityUtils.toString(entity, "UTF-8"); EntityUtils.consume(entity); &#125; catch (ClientProtocolException e) &#123; logger.error(e.getMessage()); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; &#125; &#125; if (resp == null || resp.equals("")) &#123; return ""; &#125; return resp; &#125; //发送不带参数的HttpPost请求 public static String sendPost(String url) throws IOException &#123; // 1.获得一个httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); // 2.生成一个post请求 HttpPost httppost = new HttpPost(url); CloseableHttpResponse response = null; try &#123; // 3.执行get请求并返回结果 response = httpclient.execute(httppost); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); &#125; // 4.处理结果，这里将结果返回为字符串 HttpEntity entity = response.getEntity(); String result = null; try &#123; result = EntityUtils.toString(entity); &#125; catch (ParseException | IOException e) &#123; logger.error(e.getMessage()); &#125; return result; &#125;&#125; 拼接模板消息的json代码和推送模板 12345678910111213141516171819202122232425262728293031JSONObject jsonObject = new JSONObject(); jsonObject.put("touser", wechat); // openid jsonObject.put("template_id",wechatmodel2); //jsonObject.put("url", "http://www.baidu.com");//optional JSONObject miniprogram = new JSONObject(); miniprogram.put("appid",wechattiaozhuanappid); miniprogram.put("pagepath",wechattiaozhuanpagepath+orderId); jsonObject.put("miniprogram",miniprogram); //optional JSONObject data = new JSONObject(); JSONObject first = new JSONObject(); first.put("value", "您好，您租赁的甲醛检测设备已发货。请注意查收"); first.put("color", "#173177"); JSONObject keyword1 = new JSONObject(); keyword1.put("value", expressOutNum); keyword1.put("color", "#173177"); JSONObject keyword2 = new JSONObject(); keyword2.put("value", expressOutCompany); keyword2.put("color", "#173177"); JSONObject remark = new JSONObject(); remark.put("value", "详情请查看果麦检测小程序"); remark.put("color", "#173177"); data.put("first",first); data.put("keyword1",keyword1); data.put("keyword2",keyword2); data.put("remark",remark); jsonObject.put("data", data); String string = HttpClientUtils.sendPostJsonStr(url, jsonObject.toJSONString()); 12345678910111213141516171819202122232425262728293031&#123; "touser":"OPENID", "template_id":"ngqIpbwh8bUfcSsECmogfXcV14J0tQlEpBO27izEYtY", "url":"http://weixin.qq.com/download", "miniprogram":&#123; "appid":"xiaochengxuappid12345", "pagepath":"index?foo=bar" &#125;, "data":&#123; "first": &#123; "value":"恭喜你购买成功！", "color":"#173177" &#125;, "keyword1":&#123; "value":"巧克力", "color":"#173177" &#125;, "keyword2": &#123; "value":"39.8元", "color":"#173177" &#125;, "keyword3": &#123; "value":"2014年9月22日", "color":"#173177" &#125;, "remark":&#123; "value":"欢迎再次购买！", "color":"#173177" &#125; &#125; &#125; 微服务之间的方法通信微信提供的api是通过一个微信用的微信号（并不是微信界面能看到的微信号，代码端的微信号是一串序列，与前者对应但是具有保密功能），但是本次开发的业务逻辑能够作为参数的是订单号。 所以业务流程需要我们先通过订单号（orderId）去「drift微服务」对应的db中获取用户的电话号码（phone_number），然后再拿着这个pn去「auth-consumer」微服务对应的db中获取用户的微信号（wechatId）+ 「wechat」微服务对应数据库中的token，最后调用推送的方法接口进行消息推送。总结各微服务模块的参与：drift微服务：开端，接口方法接收订单号（orderId），db中的数据查询返回：订单号（orderId）-&gt; 电话号码（phone_number）。然后调用其他微服务的方法服务。auth-consumer微服务：提供方法接口接收电话号码（phone_number），db中的数据查询返回：电话号码（phone_number）-&gt; 微信号（wechatId）wechatId微服务：提供方法接口接收微信号（wechatId），db中获取token（不用在意token刷新，刷新由其他模块负责），将微信提供的推送api与token拼接成目标接口url，最后调用推送类向接口url发送需要微信公众号推送的请求。 微服务之间的通信可以通过 @FeignClient注解实现，拿推送模块举例 123456789101112@FeignClient("wechat-agent")public interface WechatService &#123; @GetMapping("/wechat/message/confirmedMessage") ResultData confirmMessage(@RequestParam("orderId")String orderId); @GetMapping("/wechat/message/deliverMessage") ResultData deliverMessage(@RequestParam("orderId")String orderId,@RequestParam("wechat")String wechat,@RequestParam("expressOutNum")String expressOutNum,@RequestParam("expressOutCompany")String expressOutCompany); @GetMapping("/wechat/message/returnMessage") ResultData returnMessage(@RequestParam("orderId")String orderId,@RequestParam("wechat")String wechat,@RequestParam("activityName")String activityName,@RequestParam("expectDate")String expectDate);&#125; 结果展示 总结再次感谢同学，老哥是用一周的时间就学会了微信公众号的推送，并且通过交流请教我也因此受益，花费比较少的时间成本少走了很多弯路就大致搞懂了功能的实现。对于一线互联网公司的面试让我了解到，很多技术光会使用还是差得很远，还要了解背后的原理，不然难以成长为一个优秀的开发者，希望自己能多了解原理，收获更多真正的知识。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分发糖果-lc135]]></title>
    <url>%2F2019%2F12%2F28%2F20191228-lc135%2F</url>
    <content type="text"><![CDATA[题目描述老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 输入: [1,0,2]输出: 5解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。示例 2: 输入: [1,2,2]输出: 4解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/candy java1234567891011121314151617class Solution &#123; public int candy(int[] ratings) &#123; int res = 0; int[] candy1 = new int[ratings.length]; int[] candy2 = new int[ratings.length]; candy1[0] = 1; candy2[candy2.length-1] = 1; for(int i=1; i&lt;candy1.length; i++) candy1[i] = ratings[i]&gt;ratings[i-1]?candy1[i-1]+1:1; for(int i=candy1.length-2; i&gt;=0; i--) candy2[i] = ratings[i]&gt;ratings[i+1]?candy2[i+1]+1:1; for(int i=0;i&lt;ratings.length;i++) res += Math.max(candy1[i],candy2[i]); return res; &#125;&#125; python31234567891011class Solution: def candy(self, ratings: List[int]) -&gt; int: can1, can2 = [1]*len(ratings), [1 for _ in range(len(ratings))] //两种赋值方法有相同的效果，但是前者消耗更小 res = 0 for i in range(1,len(ratings)): can1[i] = can1[i-1]+1 if ratings[i]&gt;ratings[i-1] else 1 for i in range(len(ratings)-2,-1,-1): can2[i] = can2[i+1]+1 if ratings[i]&gt;ratings[i+1] else 1 for i in range(len(ratings)): res = res + max(can1[i],can2[i]) return res 总结&amp;&amp;思路lc困难题，难点在于思路。要求中“相邻的孩子中，评分高的孩子必须获得更多的糖果。”这一点要求一个孩子获得的糖果数与左右两边的孩子的评分有关：1、如果一个孩子的评分小于等于两边的孩子，那么给他一个糖果即可。2、如果一个孩子的评分大于左边（右边）的孩子，小于等于右边（左边）的孩子，那么要分给这个孩子“左边孩子糖果数+1”的糖果。3、如果一个孩子的评分大于左右两边的孩子，那么要分配给这个孩子“相邻孩子中更大评分的孩子的糖果数+1”的糖果。 总结来说，对于一个节点的值需要与左右两个节点的关系决定的这一类题型可以尝试分解为1、先从头至尾只考虑与左边节点的关系做一次遍历2、后从尾至头只考虑与右边节点的关系做一次遍历3、2可以建立在1的基础上直接完成，也可以做第三次遍历综合1和2生成最终的结果。这样的分解方式可以简化问题，在上学期的高级算法课程的练习中也有题用到类似的思想，希望自己牢记，作为自己的工具在以后遇见时可以敏感并且灵活运用。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K 个一组翻转链表-lc25]]></title>
    <url>%2F2019%2F12%2F25%2F20191225-lc25%2F</url>
    <content type="text"><![CDATA[题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group java123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while(end != null)&#123; for(int i=0; i&lt;k&amp;&amp;end!=null; i++) end = end.next; if(end == null) break; ListNode start = pre.next; ListNode nxt = end.next; end.next = null;//necessary for function reverse! pre.next = reverse(start); start.next = nxt; pre = start; end = start; &#125; return dummy.next; &#125; //reverse public ListNode reverse(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; python312345678910111213141516171819202122232425= Definition for singly-linked list.= class ListNode:= def __init__(self, x):= self.val = x= self.next = Noneclass Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next, pre, end = head, dummy, dummy while end: for _ in range(k): end = None if end == None else end.next if not end: break; start, nxt, end.next = pre.next, end.next, None pre.next = self.reverse(start) start.next, pre, end = nxt, start, start return dummy.next def reverse(self, head: ListNode) -&gt; ListNode: pre, cur = None, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre 总结&amp;&amp;思路lc困难题，参考了lc评论区大佬的解法，主要是链表的细节要非常注意。以及null值的判断一定要全面。步骤分解:1、链表分区为已翻转部分+待翻转部分+未翻转部分2、每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定3、需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来4、初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾5、经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next6、翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环7、特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可作者：reals链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/来源：力扣（LeetCode） 积累基本操作反转链表，作为基本操作一定要牢记并灵活运用，同时也是一道lc简单题 反转链表-lc206 12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; 123456class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: pre, cur = None, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前 K 个高频元素-lc347]]></title>
    <url>%2F2019%2F12%2F16%2F20191216-lc347%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例 2: 输入: nums = [1], k = 1输出: [1]说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/top-k-frequent-elements java12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; if(map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i])+1); else map.put(nums[i],1); &#125; int[][] res = new int[map.size()][2]; int index = 0; for(int x:map.keySet())&#123; res[index][0] = x; res[index][1] = map.get(x); index++; &#125; Arrays.sort(res,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0]?o1[0]-o2[0]:o2[1]-o1[1]; &#125; &#125;); for(int i=0;i&lt;k;i++) list.add(res[i][0]); return list; &#125;&#125; python31234from collections import Counterclass Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: return [item[0] for item in Counter(nums).most_common(k)] 总结&amp;&amp;思路lc中等难度题，java中通过两步实现1、计数，java中通过map的key存储值，value计数。python中则通过Counter函数进行计数直接生成dict。 2、Java中通过比较器实现按照value值降序排列。python中则通过most_common()方法实现前k个数的截取。 积累python3Counter计数器 12345import collectionsobj = collections.Counter('aabbccc')print(obj)=输出：Counter(&#123;'c': 3, 'a': 2, 'b': 2&#125;) most_common(指定一个参数n，列出前n个元素，不指定参数，则列出所有) 12345import collectionsobj = collections.Counter('aabbbcccc')print(obj.most_common(2))=输出：[('c', 4), ('b', 3)] items(从dict类中继承的方法) 1234567891011import collectionsobj = collections.Counter('aabbbcccc')print(obj.items())for k,v in obj.items(): print(k,v)=输出：dict_items([('b', 3), ('c', 4), ('a', 2)])= b 3= c 4= a 2]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是否能通过考试（背包问题）]]></title>
    <url>%2F2019%2F12%2F15%2F20191215-LCS%2F</url>
    <content type="text"><![CDATA[Description小张想要通过明天的考试。他知道考题的分值分布，也知道考试中要拿到每一个题目需要耗费的时间。假设考试时长为h，共n个题目，需要拿到p分才能通过考试。现在已知每个考题的得分与耗时，请你判断小张能否通过合理安排时间，而通过考试，并给出通过考试的最短时间。 Input输入第一行为测试用例个数.每一个用例有若干行，第一行为任务数量n、考试时常h、通过分数p，下面的n行是每一个题目的耗时和得分。所有数值用空格分开。 Output对每一个用例输出一行，如果能够通过考试，则输出“YES”和做法消耗时间，用空格隔开。 否则，输出“NO”。 SampleSample Input 135 40 2112 1016 1020 1024 108 31 41 1719 145 37 1617 1410 59 103 710 12 Sample Output 1YES 36NOYES 12 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;class T1&#123; static void deal(int n, int h, int p, int[][] num)&#123; int[][] dp = new int[n+1][h+1]; int time = 0;//记录题目用时 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=h;j++)&#123; if(j-num[i-1][0]&gt;=0)&#123; if(dp[i-1][j] &gt; dp[i-1][(j-num[i-1][0])]+num[i-1][1]) dp[i][j] = dp[i-1][j];//不做这题 else dp[i][j] = dp[i-1][(j-num[i-1][0])]+num[i-1][1];//做这题 &#125; &#125; int j = h; for(int i=n;i&gt;0;i--)&#123; if(dp[i][j]!=dp[i-1][j])&#123; time+=num[i-1][0]; j-=num[i-1][1]; &#125; &#125; if(dp[n][h]&lt;p) System.out.println("NO"); else System.out.println("YES"+" "+time); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; int[] nph = StrTurnInt(scan.nextLine().trim().split(" ")); int[][] num = new int[nph[0]][]; for(int i=0;i&lt;nph[0];i++) num[i] = StrTurnInt(scan.nextLine().trim().split(" ")); deal(nph[0],nph[1],nph[2],num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路本题是非常典型的背包问题，是经典的dp算法题型，思路如下1、首先创建dp[][]二维数组，其中行为问题，列为时间限制（对应背包问题的物品和背包容量），然后通过动态规划填充整个dp[][]数组，数组最后一位dp[n][h]保存的是给定时间下的最大分数。2、要求做法消耗的时间需要使用回溯法，从dp[n][h]开始往回回溯，如果碰到满足动态规划递推公式的关系就存储下这一时间（其实就是这一道题是做了的意思，所以记录下做这道题的时间）。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort方法总结]]></title>
    <url>%2F2019%2F12%2F15%2F20191215-sortSummary%2F</url>
    <content type="text"><![CDATA[八种经典排序算法总结算法类型 算法时间，空间，稳定性时间复杂度函数]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell排序]]></title>
    <url>%2F2019%2F12%2F15%2F20191215%2F</url>
    <content type="text"><![CDATA[java-实现Shell排序123456789101112131415161718192021222324class shellSort&#123; public static void main(String[] args) &#123; int[] num = new int[]&#123;23,3,11,34,45,43,67,56,22,33,11,2,8,75,26&#125;; int[] gap = new int[]&#123;5,3,1&#125;; for(int x:gap) shell(num,x); for(int x:num) System.out.print(x+" "); System.out.println(); &#125; static void shell(int[] num,int gap)&#123; int j; for(int i=gap; i&lt;num.length; i++)&#123; int temp = num[i]; for(j=i-gap; j&gt;=0; j-=gap)&#123; if(num[j] &gt; temp) num[j+gap] = num[j]; else break;//注意一定要加，不然下一步每次都遍历回第一位，然后把第一位换掉 &#125; num[j+gap] = temp; &#125; &#125;&#125; 总结&amp;思路八大经典排序算法之一，是插入排序的升级版，核心思想是按照gap将序列划分，每次对划分出来的部分进行插入排序 随着gap慢慢减小到1，排序完成]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分配问题-T4-1]]></title>
    <url>%2F2019%2F11%2F24%2F20191124-T4-1%2F</url>
    <content type="text"><![CDATA[Description对给定的n个任务与n个人之间的成本矩阵完成成本最低的任务分配策略。 Input输入：第一行为用例个数，之后为每一个用例；用例的第一行为任务个数，即n；用例的第二行为使用逗号隔开的人员完成任务的成本；每一个成本描述包括人员序号、任务序号和成本，使用空格隔开。人员序号和任务序号都是从1到n的整数，序号出现的次序没有固定规则。 Output输出：每一个用例输出一行，从序号为1的人员开始，给出其分配的任务序号，使用空格隔开；使用逗号将多个解隔开。结果按照人员分配的任务序号大小排，第一个人员的任务序号大的放在前面，如果相同则看第二个人员的任务，以此类推。 SampleSample Input 1142 1 6,1 2 2,1 3 7,1 4 8,1 1 9,2 2 4,2 3 3,2 4 7,3 1 5,3 2 8,3 3 1,3 4 8,4 1 7,4 2 6,4 3 9,4 4 4 Sample Output 12 1 3 4 java-回溯+基本数据操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.*;public class T1 &#123; static void distribute(List&lt;int[]&gt; t, int n) &#123; int[][] matrix = new int[n][n]; int[] temp = new int[n]; int minCount = Integer.MAX_VALUE; for(int i=0;i&lt;n;i++) temp[i] = i; for(int[] x:t) matrix[x[0]-1][x[1]-1] = x[2]; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); change(list,temp,0); for(int[] tmp:list) &#123; int count = 0; for(int i=0;i&lt;n;i++) count+=matrix[i][tmp[i]]; minCount = Math.min(minCount, count); &#125; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); for(int[] tmp:list) &#123; int count = 0; for(int i=0;i&lt;n;i++) count+=matrix[i][tmp[i]]; if(count == minCount) &#123; int[] t1 = Arrays.copyOf(tmp, tmp.length); res.add(t1); &#125; &#125; //print List&lt;String&gt; res1 = new ArrayList&lt;&gt;(); for(int[] x:res) &#123; StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;x.length-1;i++) sb.append((x[i]+1)+" "); sb.append(x[x.length-1]+1); res1.add(sb.toString()); &#125; Collections.sort(res1,Collections.reverseOrder()); String p =""; if(res1.size() == 1) p += res1.get(0); else &#123; for(int i=0;i&lt;res1.size()-1;i++) p+=res1.get(i)+","; p+=res1.get(res1.size()-1); &#125; System.out.println(p); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int testcase = Integer.parseInt(scan.nextLine()); for(int z=0; z&lt;testcase; z++) &#123; //scan.nextLine(); int n = Integer.parseInt(scan.nextLine()); String[] tmp = scan.nextLine().split(","); List&lt;int[]&gt; t = deal(tmp); distribute(t,n); &#125; scan.close(); &#125; static List deal(String[] tmp)&#123; List&lt;int[]&gt; t = new ArrayList&lt;&gt;(); for(String s:tmp) &#123; String[] a = s.split(" "); t.add(StrTurnInt(a)); &#125; return t; &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; //回溯全排列 static void change(List&lt;int[]&gt; list, int[] temp,int start)&#123; if(start == temp.length)&#123; int[] z = Arrays.copyOf(temp, temp.length); list.add(z); return; &#125; for(int i=start;i&lt;temp.length;i++)&#123; int t = temp[i]; temp[i] = temp[start]; temp[start] = t; change(list,temp,start+1); t = temp[i]; temp[i] = temp[start]; temp[start] = t; &#125; &#125;&#125; 总结&amp;思路本题主要考察回溯法和基本数据操作，较难。我们需要通过创建一个n*n的矩阵用来存储分配成本，然后考察所有的分配情况并获取其中的最小成本值。 难点在于考察所有的分配情况，这里我们通过回溯法获取人员任务分配的全排列可能情况，然后帮助进行查找最小成本值。 找到最小成本值后再遍历一遍找出所有最小成本的方案。 最后还要注意输出格式问题，校园oj格式比较麻烦，要细致注意输出格式。 附上回溯法获得数组全排列，可作为模板熟记 12345678910111213141516void change(List&lt;int[]&gt; list, int[] temp,int start)&#123; if(start == temp.length)&#123; int[] z = Arrays.copyOf(temp, temp.length);//数组作为基本数据结构可以用这种方法进行深拷贝 list.add(z); return; &#125; for(int i=start;i&lt;temp.length;i++)&#123; int t = temp[i]; temp[i] = temp[start]; temp[start] = t; change(list,temp,start+1); t = temp[i]; temp[i] = temp[start]; temp[start] = t; &#125; &#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序（递归&非递归）-T3-8]]></title>
    <url>%2F2019%2F11%2F18%2F20191118-T3-8%2F</url>
    <content type="text"><![CDATA[Description实现归并排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java——递归&amp;非递归12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class R8&#123; //二分递归体 static void mergeSort(int[] num, int low, int high)&#123; if(low &lt; high)&#123; int mid = (low+high)/2; mergeSort(num, low, mid); mergeSort(num, mid+1, high); merge(num, low, mid, high); &#125; &#125; //归并操作 static void merge(int[] num, int low, int mid, int high)&#123; int[] tmp = new int[high-low+1]; int i=low,j=mid+1,index=0; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(num[i]&lt;num[j]) tmp[index++] = num[i++]; else tmp[index++] = num[j++]; &#125; while(i&lt;=mid)&#123; tmp[index++] = num[i++]; &#125; while(j&lt;=high)&#123; tmp[index++] = num[j++]; &#125; for(i=0;i&lt;tmp.length;i++) num[low+i]=tmp[i]; &#125; //程序入口 public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); for(int i=0; i&lt;n; i++)&#123; scan.nextLine(); int len = scan.nextInt(); int[] num = new int[len]; for(int j=0;j&lt;len;j++) num[j] = scan.nextInt(); mergeSort(num,0,num.length-1); for(int j=0;j&lt;num.length-1;j++) System.out.print(num[j]+" "); System.out.println(num[num.length-1]); &#125; scan.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class R8pro&#123; //循环增长gap——1，2，4，8～ static void mergeSort(int[] num)&#123; int gap = 1; while(gap &lt; num.length)&#123; mergePass(num, gap); gap*=2; &#125; &#125; //按照此时的gap循环排序序列的每一个gap区间——low～mid～high static void mergePass(int[] num, int gap)&#123; int i = 0; while(i+2*gap &lt; num.length)&#123; merge(num, i, i+gap-1, i+2*gap-1);//注意mid可以和low重叠，这取决于merge方法的具体代码逻辑 i = i+2*gap; &#125; if(i+gap &lt; num.length) merge(num, i, i+gap-1, num.length-1); &#125; //归并操作 static void merge(int[] num, int low, int mid, int high)&#123; int[] tmp = new int[high-low+1]; int i=low,j=mid+1,index=0; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(num[i]&lt;num[j]) tmp[index++] = num[i++]; else tmp[index++] = num[j++]; &#125; while(i&lt;=mid)&#123; tmp[index++] = num[i++]; &#125; while(j&lt;=high)&#123; tmp[index++] = num[j++]; &#125; for(i=0;i&lt;tmp.length;i++) num[low+i]=tmp[i]; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); for(int i=0; i&lt;n; i++)&#123; scan.nextLine(); int len = scan.nextInt(); int[] num = new int[len]; for(int j=0;j&lt;len;j++) num[j] = scan.nextInt(); mergeSort(num); for(int j=0;j&lt;num.length-1;j++) System.out.print(num[j]+" "); System.out.println(num[num.length-1]); &#125; scan.close(); &#125;&#125; 总结&amp;思路八大算法之一 递归版本比较经典 非递归版本需要通过控制gap增长（对应递归的二分操作），并且按照此时的gap循环排序序列的每一个gap区间——low～mid～high注意mid和low，high的关系要前后一致，类似与向上取整还是向下取整一定要统一的思想]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序（递归&非递归）-T3-7]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-7%2F</url>
    <content type="text"><![CDATA[Description实现快速排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.*;class Main&#123; public static int partition(int[] a, int low, int high) &#123; // 三数取中,将中间元素放在第一个位置（优化效率操作） if (a[low] &gt; a[high]) swap(a, low, high); if (a[(low + high) / 2] &gt; a[high]) swap(a, (low + high) / 2, high); if (a[low] &lt; a[(low + high) / 2]) swap(a, (low + high) / 2, low); int pivotKey = a[low]; // 用第一个元素作为基准元素 while (low &lt; high) &#123; // 两侧交替向中间扫描 while (low &lt; high &amp;&amp; a[high] &gt;= pivotKey) high--; a[low] = a[high]; // swap(a, low, high); //比基准小的元素放到低端 while (low &lt; high &amp;&amp; a[low] &lt;= pivotKey) low++; a[high] = a[low]; // swap(a, low, high); //比基准大的元素放到高端 &#125; a[low] = pivotKey; // 在中间位置放回基准值 return low; // 返回基准元素所在位置 &#125; static void deal(int[] a, int low, int high)&#123; int pivot; if (low &gt;= high) return; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(low); stack.push(high); while (!stack.empty()) &#123; // 先弹出high,再弹出low high = stack.pop(); low = stack.pop(); pivot = partition(a, low, high); // 先压low,再压high if (low &lt; pivot - 1) &#123; stack.push(low); stack.push(pivot - 1); &#125; if (pivot + 1 &lt; high) &#123; stack.push(pivot + 1); stack.push(high); &#125; &#125; //deal with the print for(int i=0;i&lt;a.length-1;i++) System.out.print(Integer.toString(a[i])+" "); System.out.println(Integer.toString(a[a.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num, 0, num.length-1); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; //swap public static void swap(int[] a, int i, int j) &#123; int temp; temp = a[j]; a[j] = a[i]; a[i] = temp; &#125;&#125; 总结&amp;思路八大算法之一，利用栈实现非递归的版本，首先需要掌握常规的递归实现，将递归语句替换成符合运算顺序逻辑的入栈出栈操作即可，需要注意的是入栈出栈顺序。附上常规递归版本 123456789101112131415161718192021222324//快排递归体static void quickSort(int[] num,int low,int high)&#123; if(low &gt; high) return; int mid = partition(num,low,high); quickSort(num, low, mid-1); quickSort(num, mid+1, high);&#125;//每次将一个元素放到它的准确位置上，返回它的indexstatic int partition(int[] num,int low,int high)&#123; int tmp = num[low]; while(low &lt; high)&#123; while(low&lt;high &amp;&amp; num[high]&gt;=tmp)&#123; high--; &#125; num[low] = num[high]; while(low&lt;high &amp;&amp; num[low]&lt;=tmp)&#123; low++; &#125; num[high] = num[low]; &#125; num[low] = tmp; return low;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序-T3-6]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-6%2F</url>
    <content type="text"><![CDATA[Description实现计数排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;class Main&#123; static void deal(int[] num)&#123; int[] tnum = new int[num.length]; for(int i=0;i&lt;num.length;i++) tnum[i] = num[i]; for(int i=0; i&lt;tnum.length; i++)&#123; int count = 0; int same = 0; for(int j=0; j&lt;tnum.length; j++) if(tnum[j]&lt;tnum[i]) count++; else if(tnum[j]==tnum[i]) same++; for(int y = 0 ; y &lt; same ; y++) num[count+y]=tnum[i]; &#125; //deal with the print for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路顾名思义按照每个元素大于（小于）所有元素的个数确定该元素的位置，用count记录，然后直接将该元素放到最终位置，需要注意有重复值的情况，用same记录。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序-T3-5]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-5%2F</url>
    <content type="text"><![CDATA[Description实现冒泡排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main&#123; static void deal(int[] num)&#123; for(int i=0; i&lt;num.length; i++) for(int j=num.length-1; j&gt;i; j--) if(num[j]&lt;num[j-1])&#123; int temp = num[j]; num[j] = num[j-1]; num[j-1] = temp; &#125; //deal with the print for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路八大排序之一，比较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序-T3-4]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-4%2F</url>
    <content type="text"><![CDATA[Description实现插入排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;class Main&#123; static void deal(int[] num)&#123; for(int i=1; i&lt;num.length; i++)&#123; int tmp = num[i]; int j=i; while(j-1&gt;=0&amp;&amp;num[j-1]&gt;tmp)&#123; num[j] = num[j-1]; j--; &#125; num[j] = tmp; &#125; for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路八大排序之一，比较简单，每次选定一个序列元素，向前找到合适自己的位置将它原来位置前的元素都后移一位后插入到合适位置即可。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表区间逆序-T3-3]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-3%2F</url>
    <content type="text"><![CDATA[Description将单个链表的每K个节点之间逆序，打印出新链表；最后不足K的节点数不需要逆序；要求时间复杂度为O(n)，额外空间复杂度为O(1)。 Input输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个表示链表长度，中间为节点值，最后代表K。 Output输出的每一行为新的链表，节点值用空格隔开，末尾不要空格。 SampleSample Input 128 1 2 3 4 5 6 7 8 38 a b c d e f g h 4 Sample Output 13 2 1 6 5 4 7 8d c b a h g f e java123456789101112131415161718192021222324252627282930313233343536import java.util.*;class Main&#123; static void deal(String[] str, int n)&#123; int flag = 0; while(flag+n-1 &lt; str.length)&#123; swap(str, flag, flag+n-1); flag+=n; &#125; for(int i=0;i&lt;str.length-1;i++) System.out.print(str[i]+" "); System.out.println(str[str.length-1]); &#125; static void swap(String[] str, int start, int end)&#123; while(start&lt;end)&#123; String tmp = str[start]; str[start] = str[end]; str[end] = tmp; start++; end--; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] tool = scan.nextLine().split(" "); String[] str = new String[tool.length-2]; for(int i=0;i&lt;str.length;i++) str[i] = tool[i+1]; deal(str, Integer.parseInt(tool[tool.length-1])); &#125; scan.close(); &#125;&#125; 总结&amp;思路按照题意需要两个指针每次一个不动一个移动K位然后逆转这部分链表，如果剩余链表长度不足以第二个指针移动K位则不进行逆置并结束操作。 但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表回文-T3-2]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-2%2F</url>
    <content type="text"><![CDATA[Description判断一个单向链表是否为回文结构。自定义链表数据结构，要求时间复杂度为O(n)，额外空间复杂度为O(1)。 Input输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个值为节点个数，后面为每一个节点值 Output是回文则输出true，不是则输出false，一行表示一个链表的结果。 SampleSample Input 143 1 2 14 1 2 2 13 3 5 36 a b c d c a Sample Output 1truetruetruefalse java1234567891011121314151617181920212223242526272829303132import java.util.*;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing int n = scan.nextInt(); String res = scan.nextLine().trim(); if(res.equals(reverseString(res))) System.out.println("true"); else System.out.println("false"); &#125; scan.close(); &#125; //reverse the String public static String reverseString(String str) &#123; char[] arr=str.toCharArray(); int middle = arr.length&gt;&gt;1;//EQ length/2 int limit = arr.length-1; for (int i = 0; i &lt; middle; i++) &#123; char tmp = arr[i]; arr[i]=arr[limit-i]; arr[limit-i]=tmp; &#125; return new String(arr); &#125;&#125; 总结&amp;思路按照题意单向链表解决本题，则需要先用一个快慢指针找到单向链表的中间结点，然后逆向前半段链表后一一比对。同时也是一道lc的原题。 但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列-T3-1]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-1%2F</url>
    <content type="text"><![CDATA[Description给定两个字符串，返回两个字符串的最长公共子序列（不是最长公共子字符串），可能是多个。 Input输入第一行为用例个数， 每个测试用例输入为两行，一行一个字符串 Output如果没有公共子序列，不输出，如果有多个则分为多行，按字典序排序。 SampleSample Input 111A2BD3G4H56JK23EFG4I5J6K7 Sample Output 123G456K23G45JK java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.*;class Main&#123; //recall and get the LCS public static void printLCS(String[] num1, int[][] path, int row, int col, String cur, List&lt;String&gt; res)&#123; //the end condition if(path[row][col] == 0)&#123; if(!res.contains(reverseString(cur))) res.add(reverseString(cur)); return; &#125; if(path[row][col] == path[row-1][col]) printLCS(num1, path, row-1, col, cur, res); if(path[row][col] == path[row][col-1]) printLCS(num1, path, row, col-1, cur, res); if(path[row][col]!=path[row-1][col] &amp;&amp; path[row][col]!=path[row][col-1])&#123; cur += num1[row-1]; printLCS(num1, path, row-1, col-1, cur, res); &#125; &#125; //caculate the len of LCS by dp and recall the LCS public static void deal(String[] num1, String[] num2)&#123; int[][] path = new int[num1.length+1][num2.length+1]; //take care of the length of the res for(int i=1; i&lt;=num1.length; i++) for(int j=1; j&lt;=num2.length; j++) if(num1[i-1].equals(num2[j-1])) //the length is different path[i][j] = path[i-1][j-1]+1; else path[i][j] = Math.max(path[i-1][j],path[i][j-1]); //caculate the len of LCS //int len = path[path.length-1][path[0].length-1]; //System.out.println(len); String cur = ""; List&lt;String&gt; res = new ArrayList&lt;&gt;(); printLCS(num1, path, num1.length, num2.length, cur, res); // Set t = new HashSet(res); // res.clear(); // res.addAll(t); Collections.sort(res); for(String s:res) System.out.println(s); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing String[] num1 = scan.nextLine().trim().split(""); String[] num2 = scan.nextLine().trim().split(""); deal(num1,num2); &#125; scan.close(); &#125; //reverse the String public static String reverseString(String str) &#123; char[] arr=str.toCharArray(); int middle = arr.length&gt;&gt;1;//EQ length/2 int limit = arr.length-1; for (int i = 0; i &lt; middle; i++) &#123; char tmp = arr[i]; arr[i]=arr[limit-i]; arr[limit-i]=tmp; &#125; return new String(arr); &#125;&#125; 总结&amp;思路本题是同类型题目中扩展的比较大的情况，比较通常的情况是求LCS的长度或者一种情况。 所有情况的解法可以看成两个部分：1、创建二维数组path[][]通过动态规划存储从path[0][0]——path[n][m]的所有情况（LCS的长度信息就存储在path[n][m]中）2、通过回溯法从后往前回溯path数组，并在过程中维护一个str用于存储LSC（具体方法是在path增长的那一个结点获取原字符串中对应index的字符）注意点：（1）从后往前回溯获得的LCS是反的，需要在存入时进行反转处理。（2）要避免LCS重复的情况，保险起见对结果list去重。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列-lc1143]]></title>
    <url>%2F2019%2F11%2F07%2F20191107-lc1143%2F</url>
    <content type="text"><![CDATA[题目描述给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace”，它的长度为 3。示例 2: 输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc”，它的长度为 3。示例 3: 输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-subsequence 思路&amp;实现本题属于典型的动态规划题型，可以通过动态规划快速解决 java12345678910111213class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int[][] res = new int[text1.length()+1][text2.length()+1]; for(int i=1; i&lt;res.length; i++) for(int j=1; j&lt;res[0].length; j++)&#123; if(text1.charAt(i-1)==text2.charAt(j-1)) res[i][j]=res[i-1][j-1]+1; else res[i][j]=Math.max(res[i][j-1],res[i-1][j]); &#125; return res[res.length-1][res[0].length-1]; &#125;&#125; python31234567891011class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: n, m = len(text1), len(text2) res = [[0]*(m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): if text1[i-1]==text2[j-1]: res[i][j] = res[i-1][j-1]+1 else: res[i][j] = max(res[i-1][j], res[i][j-1]) return res[n][m] 总结lc中等难度题，主要考察动态规划。思路清晰注意好递推条件可以快速解决。 本题还有变体包括：1、输出公共子序列（任一）2、输出所有公共子序列，并按照字典顺序排序（dp+回溯法） 其中2为高级算法课的课后练习，还涉及回溯法，很有学习必要。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair install&management&auth admin]]></title>
    <url>%2F2019%2F11%2F05%2F20191105-tec%2F</url>
    <content type="text"><![CDATA[前言开学第三个月的时间，经历了在私募公司两个月需求不明的实习，回归果麦项目的第一个周期任务也结束了。经过了一段时间的熟悉又上手了spring boot+spring cloud项目。还好有之前的项目总结，上手熟悉没有花费太多的时间，同样，这次也做好总结，方便回顾学习，温故而知新。 这次是果麦新风install模块的功能开发，先贴上学长的要求和我的完成结果： 我说下前端显示的情况：（1）首先我会与一个负责人列表，这个你要去查team_member里role为1的用户返回给我（2）点击每一个member我要知道它所关注的所有团队，要能删除这个团队，或者添加一个新的关注团队。（3）另外，你还需要给我提供一个根据团队id查看所有相关负责人的接口 完成（1）installdesk/MemberController.java–&gt;leaderList()（2）installdesk/TeamWatchController.java–&gt;watches() block() watch()（3）installdesk/TeamWatchController.java–&gt;list() 本来以为只是常规的service/dao/db curd，但还是有比较多的新内容，installdesk模块的接口需求涉及mybatis的多表连接（有问题也有发现），完成后将接口调用加到management里面，并且想要通过管理员权限调用接口进行测试还需要启动auth admin模块调用接口获取token。总之，我又踩了很多坑。。。 踩坑经历1、由于自己的鱼唇首先浪费掉最多时间的永远是自己的愚蠢。一开始进行多表连接由于一开始流程没通过我将结果语句注释掉了，为了能在先验证mybatis的多表连接有没有打通，结果在最后都实现了却忘记了改回来，导致浪费了巨量的时间（自己永远意识不到自己的主动错误），最后还是通过断点debug的过程中发现结果正确却没返回出来才解决。 然而事情还没有完，后面本地运行auth admin报错数据源错误，一开始是配置文件propertise中的数据源没有更新成本地的导致了这样的问题，在改正之后却依旧报错数据源错误，我反复的检查代码逻辑的可能错误，又浪费了大量的时间并且期间陷入了自我怀疑，最后发现是macbook的touchbar启动的并不是更新后的启动类（我一直在运行之前错误的启动类），又是自己的行为导致的问题，以后在更新过启动类后一定要手动找到真实的启动类启动，不能自然的依赖touch bar去运行程序。。 2、枚举类型的查询枚举类型的查询除了需要实现handler以外还需要注意要通过真实值来查询。例如又如下枚举对应关系{ordinary(0),leader(1)}，那么如果想要从数据库中搜索所有这一项为leader的表项，那么我们需要用1这个int类型去传如参数给mybatis的sql语句才能正确执行查询，如果使用ordinary或者leader，那么这个值会默认为0。 新学到的东西1、mybatis多表连接查询由于自己的鱼唇，这一部分多做了很多工作，但是也算是把两种多表连接都学习了一下吧。 1、一对一连接————通过association标签xml文件内容如下 123456789101112131415161718192021222324252627282930&lt;resultMap id="memberTeamVo" type="finley.gmair.model.installation.MemberTeam"&gt; &lt;id property="memberId" column="member_id"/&gt; &lt;association property="member" javaType="finley.gmair.model.installation.Member"&gt; &lt;result property="memberId" column="member_id"/&gt; &lt;result property="teamId" column="team_id"/&gt; &lt;result property="memberPhone" column="member_phone"/&gt; &lt;result property="memberName" column="member_name"/&gt; &lt;result property="wechatId" column="wechat_id"/&gt; &lt;result property="memberRole" column="member_role" typeHandler="finley.gmair.mybatis.handler.MemberRoleHandler"/&gt; &lt;result property="blockFlag" column="block_flag"/&gt; &lt;result property="createAt" column="create_time"/&gt; &lt;/association&gt; &lt;select id="queryMemberTeam" parameterType="java.util.Map" resultMap="memberTeamVo"&gt; SELECT a.member_id, a.team_id, a.member_phone, a.wechat_id, a.member_name, a.member_role FROM gmair_install.team_member a LEFT JOIN gmair_install.team_watch b ON a.member_id = b.member_id WHERE 1 = 1 &lt;if test="watchId != null"&gt; AND b.watch_id = #&#123;watchId&#125; &lt;/if&gt; &lt;if test="memberId != null"&gt; AND b.member_id = #&#123;memberId&#125; &lt;/if&gt; &lt;if test="teamId != null"&gt; AND b.team_id = #&#123;teamId&#125; &lt;/if&gt; &lt;/select&gt; &lt;/resultMap&gt; 这里用到的是MemberTeam和Member两个实体类，注意association中的Member类需要作为属性写在MemberTeam里面 123456789101112public class MemberTeam &#123; private String memberId;//不加get set方法使这一项没有返回值减少表连接的数据冗余 private Member member; public MemberTeam()&#123;&#125; public Member getMember() &#123; return member; &#125; public void setMember(Member member) &#123; this.member = member; &#125;&#125; 最后返回的结果将是这个外层标签的MemberTeam类型，而表连接中另一个表的内容将会通过MemberTeam.member返回出来。 最终返回的将是一个完整的MemberTeam类型，sql语句只能保证MemberTeam的哪些属性是非null的，如果想要控制返回的MemberTeam，可以通过限制它属性的get&amp;set方法来达成，如果不加get&amp;set方法，这个属性就不会出现在返回值中，但是不会影响数据库查询时的逻辑 2、一对多连接————通过collection标签整体使用与association标签的使用类似，只是一个实体类在另一个主实体类中的不再表现为唯一属性值，而是list&lt;属性值&gt;，同样最后会通过主实体类返回。 我在项目中使用的是一对一连接，多对多代码使用参考以下博客————————————————版权声明：本文为CSDN博主「hyhcloud」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Huangyuhua068/article/details/83176160 1234567891011121314151617181920&lt;resultMap id="userMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;!--配置1对多关系映射 property：在User里面的List&lt;Account&gt;的属性名 column:外键 ofType:当前account表的java类型 --&gt; &lt;collection property="accountList" ofType="account"&gt; &lt;id property="accountId" column="accountId"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="userMap"&gt; SELECT * FROM USER LEFT JOIN account on account.uid=user.id &lt;/select&gt; 2、将接口调用加到management这一部分涉及management中的service和controller两个部分 首先我们需要将接口加到management下的service中，需要注意的是1、url的不同。2、参数要添加注释。3、接口名可以自定义 1234567891011@GetMapping("/install/teamwatch/watch/teamList") ResultData queryWatchTeam(@RequestParam("memberId") String memberId); @PostMapping("/install/teamwatch/block") ResultData blockWatchTeam(@RequestParam("memberId") String memberId, @RequestParam("teamId") String teamId); @GetMapping("/install/teamwatch/list") ResultData getLeaderListByTeamid(@RequestParam("teamId") String teamId); @GetMapping("/install/member/leader/list") ResultData getLeaderList(); 然后要在controller中调用接口 3、获取token进行测试management模块的测试需要管理员权限，需要持有token才能调用management模块的http接口。 而想要获取token需要先启动auth-admin模块然后发出请求获取token，这里由于数据源异常踩了很久的坑，前面踩坑经历有提到就不多说了。 总结这半个月的任务量其实不大，新接触的内容有mybatis多表连接查询，management实现接口调用，获取token得到管理员权限。可以说还是比较有收获的，期间碰到的问题也不少但是都解决了，debug能力++，希望下半个月的新任务能顺利也能有收获，少拖延多做事！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从前序与中序遍历序列构造二叉树-lc105]]></title>
    <url>%2F2019%2F10%2F27%2F20191027-lc105%2F</url>
    <content type="text"><![CDATA[题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / 9 20 / 15 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 思路&amp;实现通过前序遍历序列确定root结点，然后根据这个root去中序遍历序列中找到它的位置p，将中序遍历序列按照p分成左右两段，这两段就是以p为根结点的左右子树的中序遍历序列，继续在前序遍历序列中往下找root子树的根结点递归解决即可。 java12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int pre_index = 0; int[] preorder; int[] inorder; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; this.inorder = inorder; int i = 0; for(int x:inorder) map.put(x,i++); return help(0,inorder.length); &#125; public TreeNode help(int l, int r)&#123; //l和r只用作递归终止条件 if(l==r) return null; TreeNode root = new TreeNode(preorder[pre_index]); pre_index++; int mid = map.get(root.val); root.left = help(l,mid); root.right = help(mid+1,r); return root; &#125;&#125; python3123456789101112131415161718192021222324252627= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: pre_index = 0 preorder, inorder = [], [] f_inorder = &#123;&#125; def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: self.preorder, self.inorder = preorder, inorder i = 0 for x in inorder: self.f_inorder[x], i = i, i+1 return self.help(0, len(inorder)) def help(self, left, right) -&gt; TreeNode: if left == right: return None root, self.pre_index = TreeNode(self.preorder[self.pre_index]), self.pre_index+1 mid = self.f_inorder[root.val] root.left = self.help(left,mid) root.right = self.help(mid+1,right) return root 总结lc中等难度题，其实是数据结构书籍介绍树部分三序遍历必定会提到的经典问题。 解题思路比较清晰就是借助先序和中序序列的特性进行递归处理。 代码实现方法比较多，我参考lc题解借助map（dict–&gt;python3）能够比较快速的解决，并且时间效率较好。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[固定和的元素对-T2.6]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-6%2F</url>
    <content type="text"><![CDATA[Description输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，统计这样两个数的对数。 Input输入第一行为用例个数， 每个测试用例输入第一行是数组，每一个数用空格隔开；第二行是数字和。 Output输出这样两个数有几对。 SampleSample Input 111 2 4 7 11 0 9 1511 Sample Input 23 java1234567891011121314151617181920212223242526272829303132333435import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a; a = scan.nextInt(); scan.nextLine(); while(a&gt;0)&#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int num=0; a--; String[] s = scan.nextLine().split(" "); int[] group = new int[s.length]; for(int j=0;j&lt;s.length;j++)&#123; group[j] = Integer.parseInt(s[j]); &#125; int b = scan.nextInt(); scan.nextLine(); for(int k = 0 ; k &lt; group.length ; k++)&#123; if(map.get(group[k])==null)&#123; map.put(b-group[k],group[k]); &#125; else&#123; num++; &#125; &#125; System.out.println(num); &#125; scan.close(); &#125;&#125; 总结&amp;思路lc原题，可以蛮力法简单粗暴，想要比较好的时间复杂度就用1、双指针法。2、借用map。原题就不多赘述了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间第k最小-T2.5]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-5%2F</url>
    <content type="text"><![CDATA[Description找到给定数组的给定区间内的第K小的数值。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个数用空格隔开；第二行是区间（第几个数到第几个数，两头均包含），两个值用空格隔开；第三行为K值。 Output结果。 SampleSample Input 111 2 3 4 5 6 73 52 Sample Input 24 java12345678910111213141516171819202122232425262728293031323334353637import java.util.*;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int start = scan.nextInt(); int end = scan.nextInt(); scan.nextLine(); //int k = scan.nextInt(); //scan.nextLine(); //String[] num2 = scan.nextLine().split(" "); //int start = Integer.parseInt(num2[0]); //int end = Integer.parseInt(num2[1]); int k = Integer.parseInt(scan.nextLine()); System.out.println(Run(num,start-1,end-1,k)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int Run(int[] num, int start, int end, int k)&#123; int[] n = new int[end-start+1]; for(int i=start;i&lt;=end;i++) n[i-start]=num[i]; Arrays.sort(n); return n[k-1]; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔-T2.4]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-4%2F</url>
    <content type="text"><![CDATA[Description汉诺塔问题中限制不能将一层塔直接从最左侧移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间。求当有N层塔的时候移动步数。 Input输入第一行为用例个数， 每个测试用例输入的第一行为N。 Output移动步数。 SampleSample Input 112 Sample Input 28 java12345678910111213141516171819import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; int num = Integer.parseInt(scan.nextLine()); System.out.println(hanoi(num)); &#125; scan.close(); &#125; static int hanoi(int n)&#123; if(n == 1) return 2; else return hanoi(n-1)*3+2; &#125;&#125; 总结&amp;思路题目描述其实不太准确，给出的sample的要求其实不太一样，但是也不是很困难。 当筹码只有一个的时候需要移动两次，而n个筹码移动的次数N(n)=N(n-1)*3+2： 即先将n-1个筹码放到最右边–将第n个筹码放到中间–将n-1个筹码放到最左边–将第n个筹码放到最右边–将n-1个筹码放到最右边。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和窗口-T2.3]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-3%2F</url>
    <content type="text"><![CDATA[Description给定一个整型数组arr和一个大小为w的窗口，窗口从数组最左边滑动到最右边，每次向右滑动一个位置，求出每一次滑动时窗口内最大元素的和。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个元素使用空格隔开；第二行为窗口大小。 Output输出每个测试用例结果。 SampleSample Input 114 3 5 4 3 3 6 73 Sample Input 232 java123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int win = Integer.parseInt(scan.nextLine()); System.out.println(countWin(num,win)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int countWin(int[] num,int win)&#123; int res = 0; for(int i=0;i&lt;num.length-win+1;i++) res+=max(num,i,win+i-1); return res; &#125; static int max(int[] num,int start,int end)&#123; int res = Integer.MIN_VALUE; for(int i=start;i&lt;=end;i++) if(res&lt;num[i]) res = num[i]; return res; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子矩阵问题-T2.2]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-2%2F</url>
    <content type="text"><![CDATA[Description给定一个矩形区域，每一个位置上都是1或0，求该矩阵中每一个位置上都是1的最大子矩形区域中的1的个数。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为矩阵行数n和列数m，下面的n行每一行是用空格隔开的0或1。 Output输出一个值。 SampleSample Input 113 41 0 1 11 1 1 11 1 1 0 Sample Input 26 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;class T2&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = scan.nextInt(); for(int i = 0;i &lt; count; i++)&#123; scan.nextLine();//pass the /0 String[] two = scan.nextLine().split(" "); int n = Integer.parseInt(two[0]); int m = Integer.parseInt(two[1]); int[][] matrix = new int[n][m]; for(int k1=0;k1&lt;n;k1++) for(int k2=0;k2&lt;m;k2++) matrix[k1][k2] = scan.nextInt(); System.out.println(Deal(matrix)); &#125; scan.close(); &#125; //deal with the matrix and produce arrays to deal static int Deal(int[][] matrix)&#123; if(matrix == null||matrix.length == 0||matrix[0].length == 0) return 0; int res = 0; int[] arr = new int[matrix[0].length]; for(int i=0;i&lt;matrix.length;i++)&#123; for(int j=0;j&lt;matrix[0].length;j++) arr[j] = (matrix[i][j]==0?0:arr[j]+1); res = Math.max(res, dealArra(arr)); &#125; return res; &#125; //deal with the arr and return the max area static int dealArra(int[] arr)&#123; if(arr == null||arr.length == 0) return 0; int maxArea = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;arr.length;i++)&#123; while(!stack.empty()&amp;&amp;arr[i]&lt;arr[stack.peek()])&#123; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (i-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; stack.push(i); &#125; while(!stack.isEmpty())&#123; // while the arr is finished int right = arr.length; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (right-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; return maxArea; &#125;&#125; 总结&amp;思路解决这题需要先了解直方图最大面积的求法初次理解花了比较多时间，说起来比较复杂就留个连接：https://www.cnblogs.com/CodeCafe/p/7634233.html 了解做法以后只要将矩阵读入成int[][]后每次读一行，并将那一行的数值当作一个直方图进行处理得出一个最大值存储起来 然后每次读下一行（需要通过上一行的值进行更新），又作为直方图得到一个最大值，并和之前存储的最大值进行比较留较大的。 循环遍历矩阵的每一行后最后留下的值就是最大值。 本题难度主要在直方图最大面积的理解，并通过辅助Stack进行代码层次的实现。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子数组的取值范围-T2.1]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-1%2F</url>
    <content type="text"><![CDATA[Description给定数组arr和整数num，求arr的连续子数组中满足：其最大值减去最小值的结果大于num的个数。请实现一个时间复杂度为O(length(arr))的算法。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为数组，每一个数用空格隔开，第二行为num。 Output输出一个值。 SampleSample Input 113 6 4 3 22 Sample Output 16 java123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int i=0;i&lt;count;i++)&#123; int res = 0,p = 0,q = 1; String[] num = scan.nextLine().split(" "); int target = Integer.parseInt(scan.nextLine()); while(p!=num.length&amp;&amp;q!=num.length)&#123; if(p==q)&#123; q++; continue; &#125; int c = run(num,p,q); if(c&gt;target)&#123; res+=num.length-q; p++; continue; &#125; else&#123; q++; continue; &#125; &#125; System.out.println(res); &#125; scan.close(); &#125; public static int run(String[] num, int p, int q)&#123; int max=Integer.parseInt(num[p]),min=Integer.parseInt(num[p]); for(int i=p;i&lt;=q;i++)&#123; int t = Integer.parseInt(num[i]); if(t&gt;max) max=t; if(t&lt;min) min=t; &#125; return max-min; &#125;&#125; 总结&amp;思路做法是滑动窗口一次遍历数组做到时间复杂度O(N)，具体做法如下： 用两个指针l, r确定窗口边界，初始窗口大小为2只包含数组的前两位，然后对每次窗口做如下判断 1、如果窗口内的最大数-最小数&gt;num，则包含当前窗口的所有窗口必然满足条件，count += arr.length-count，然后l指针向右移一位； 2、如果窗口内的最大数-最小数&lt;num，则当前窗口不满足要求，指针l向右移一位扩大窗口后再进行判断； 3、注意窗口大小一定要&gt;=2，所以要处理l,r重合的情况； 高级算法课的课后练习和平时刷lc有较大差别，不止要想出解决的做法，还要处理好输入输出，之前一味刷lc忽略了输入输出的处理导致一开始做题真的很难受，nextInt() nextLine()换行符问题都困扰了一段时间。自己写完整程序时也要多考虑合理的模块化，方便错误定位和代码清晰性。还是要多多学习，多多练习。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据身高重建队列-lc406]]></title>
    <url>%2F2019%2F10%2F14%2F20191014-lc406%2F</url>
    <content type="text"><![CDATA[题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height 思路&amp;实现本题题目逻辑没有很清楚，需要了解到最终的排序要求是对于每个身处最终位置的人，他前面有且仅有k个h大于他的人。 我们用排序思路理清我们要做的就是，首先将所有人按照1、身高顺序降序排序2、身高相同则k升序排序3、遍历排序后的数组，根据K插入到K的位置上 核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求 在代码实现方面，使用java的比较器实现，并用匿名函数Lambda表达式优化代码结构，以下是实现降序排序的比较器Comparator的使用方法（Collections.reverseOrder()的实现） 1234567891011public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2)&#123; return o2-o1; &#125; &#125;); for(int x:num) System.out.println(x); &#125; 然后是使用Lambda表达式优化后的做法 123456public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,(o1,o2)-&gt;o2-o1); for(int x:num) System.out.println(x); &#125; 可以看到代码大大简化，可读性提升。 java比较器传统实现 1234567891011121314class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0]? o1[1]-o2[1]:o2[0]-o1[0]; &#125; &#125;); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; Lambda实现 123456789class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,(o1,o2)-&gt;o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; python3-Lambda1234567class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key = lambda x: [-x[0], x[1]]) res = [] for p in people: res.insert(p[1], p) return res 总结本题是一道lc中等难度题,题目要求转换成解法比较绕弯不易想到，而且比较器和Lambda函数对我来说算是新知识了，花了些时间学习了一下，比较有收获，需要注意的是，Lambda表达式虽然可以优化代码结构，但是运行速度在lc编译器中显示没有传统比较器实现来的快。 java比较器使用： 1234567Arrays.sort(object o,new Comparator&lt;sonDataType&gt;()&#123; @Override public sonDataType compare(sonDataType o1, sonDataType o2)&#123; //排序顺序o1-o2为升序，o2-o1为降序 return o1-o2; &#125;&#125;); java Lambda表达式用法： 12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); python3 Lambda表达式用法： 12345//按照people中的子list的第二个元素大小升序排序people.sort(key=Lambda x:x[1])//按照people中的子list的第一个元素的大小降序排序，第一个元素同样大的情况下按照第二个元素大小升序排序people.sort(key=Lambda x:[-x[0],x[1]])]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序链表-lc148]]></title>
    <url>%2F2019%2F10%2F07%2F20191007-lc148%2F</url>
    <content type="text"><![CDATA[题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-list 思路&amp;实现题目要求逻辑很清晰，其实就是基于链表的排序，主要是限制了时间复杂度，再加上链表的特性，限制了排序方法的选择，这里我觉得用归并排序的方法解决这个题比较容易。 java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head == null||head.next == null) return head; ListNode left = head; ListNode right = head.next; while(right!=null&amp;&amp;right.next!=null)&#123; left = left.next; right = right.next.next; &#125; ListNode tmp = left.next; left.next = null;//以中点断开链表以免相互影响 left = sortList(head); right = sortList(tmp); ListNode dummy = new ListNode(-1); ListNode res = dummy; while(left!=null&amp;&amp;right!=null)&#123; if(left.val &gt; right.val)&#123; dummy.next = right; right = right.next; &#125;else&#123; dummy.next = left; left = left.next; &#125; dummy = dummy.next; &#125; dummy.next = left!=null?left:right; return res.next; &#125;&#125; python31234567891011121314151617181920class Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head left, right = head, head.next while right and right.next: left, right = left.next, right.next.next tmp ,left.next = left.next, None left, right = self.sortList(head), self.sortList(tmp) m = res = ListNode(-1) while left and right: if left.val &lt; right.val: m.next = left left = left.next else: m.next = right right = right.next m = m.next m.next = left if left else right return res.next 总结本题是一道lc中等难度题，主要考察限制条件的sort算法，使用归并递归的方式比较好解决，但是这样会使用一些额外空间，如果想要使得空间复杂度保持O(1)，那么就需要用到非递归的归并算法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除自身以外数组的乘积-238]]></title>
    <url>%2F2019%2F09%2F25%2F20190925-238%2F</url>
    <content type="text"><![CDATA[题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self 思路&amp;实现题目其实比较简单，直观的第一想法应该是先将nums数组的元素总乘机求出然后遍历一遍数组，每个元素都对总乘机做一次除法即可。时间复杂度为O(N)但是题目要求限制使用除法，并且要求相同的复杂度。题目使坏导致我们没法那么舒适的做出这道题但是其实也可以用乘法思路解决。 对于res数组的每个元素都可以将他看成是 [该元素左边所有元素的乘积]*[该元素右边所有元素的乘积] 所以我们可以采用两次循环遍历解决这个题第一遍循环遍历解决所有左边元素的乘积（因为可以累乘所以这并不难）第二便循环遍历解决所有右边元素的乘积（相同思路） java1234567891011121314151617class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; int k = 1; for(int i = 0; i &lt; nums.length; i++)&#123; res[i] = k; k *= nums[i]; &#125; k = 1; for(int i = nums.length-1; i &gt;= 0; i--)&#123; res[i] *= k; k *= nums[i]; &#125; return res; &#125;&#125; python312345678910class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: res, k, k1 = [1]*len(nums), 1, 1 for i in range(len(nums)): res[i] *= k k *= nums[i] for i in range(len(nums)-1, -1, -1): res[i] *= k1 k1 *= nums[i] return res 总结本题是一道lc中等难度题，主要考察对线性表的基本数据操作，通过限制条件加大难度，思路理清后较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树展开为链表-lc114]]></title>
    <url>%2F2019%2F09%2F23%2F20190923-lc114%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / 2 5 / \ 3 4 6将其展开为： 1 2 3 4 5 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list 思路看题目以及给的例子可以看出题目要求，即将一颗二叉树的全部节点都放置到顺序的右子树，左子树为空。形似一根单链表。 有这样的思路步骤：1、将二叉树的右子树暂存起来，记为y2、将二叉树的左子树移到右子树位置，然后遍历现在这棵树的右节点直到尽头，然后将y接在后面3、递归处理所有的右子节点 java12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null) return; TreeNode temp = root.right; root.right = root.left; root.left = null; TreeNode t = root; while(t.right != null) t = t.right; t.right = temp; flatten(root.right); &#125;&#125; python312345678910111213141516171819\# Definition for a binary tree node.\# class TreeNode:\# def __init__(self, x):\# self.val = x\# self.left = None\# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return t1, t2 = root.right, root root.right, root.left = root.left, None while t2.right: t2 = t2.right t2.right = t1 self.flatten(root.right) 总结本题是一道lc中等难度题，主要考察二叉树的处理结合递归操作，思路清晰后代码实现比较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特位计数-lc338]]></title>
    <url>%2F2019%2F09%2F18%2F20190918-lc338%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2输出: [0,1,1]示例 2: 输入: 5输出: [0,1,1,2,1,2]进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits java python3–位运算&amp;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++)//要从1开始，第0位在数组初始化时default值为0满足要求 res[i] = res[i &amp; (i - 1)] + 1; return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0]*(num+1) for i in range(1, num+1): res[i] = res[i&amp;(i-1)] + 1 return res 这种做法运用了位运算符 a&amp;b————两个数a b都转换成二进制编码进行位比较，当且仅当两位同时为1则该位结果为1，否则为0。 技巧在于i &amp; (i-1)这个操作可以去掉i的二进制编码的最右边的一个1（被-1后的数二进制表现为最右边的1右移一位，而不影响其他1位），因此（1）i &amp; (i-1)的结果十进制数的1的个数+1就是我们要的结果。（2）i &amp; (i-1)由于最右边一位1被去掉了十进制数大小要比i小，所以已经被我们在前面计算过了并存储在了结果数组中。（3）通过这种做法不断迭代计算后面的值即可。 java python3–位运算&gt;&gt;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++) res[i] = res[i&gt;&gt;1] + (i&amp;1);//注意括号一定要，&amp;和加减乘除的优先级是一样的 return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0] for i in range(1, num+1): res.append(res[i&gt;&gt;1] + (i&amp;1)) return res 这种做法运用了位运算符 a&gt;&gt;b————将十进制数a的二进制形式右移b位（最右边b位去掉），然后返回处理后的二进制数的十进制结果。 技巧在于 i&gt;&gt;1 这个操作可以去掉i的二进制编码的最右边一位（不管是0还是1），因此（1）i&gt;&gt;1的结果（十进制）一定比i小，所以i&gt;&gt;1的1的个数的值已经被我们在前面计算过了并存储在了结果数组中。（2）如果被去掉的最后一位是0，那么我们要的值就是res[i&gt;&gt;1]； 如果是1，那么我们要的值就是res[i&gt;&gt;1]+1. 综合一下就是res[i&gt;&gt;1]+(1&amp;i)不是吗(3)通过这种做法不断迭代计算后面的值即可。 总结本题是lc中等难度的一道题，禁止使用java或是python中基本库包含的直接计数函数，考察的是对二进制以及位运算方面的知识，当然也可以将十进制数化成二进制以后再操作而不是用位运算，简单粗暴但是这样的话代码会复杂很多而且十分不优雅，所以还是要好好学习下如何用位运算来处理这样的题。在lc评论区学习一番之后总结了两种代码比较优雅时间复杂度也比较优秀的做法。 附上位运算的一些基础介绍，以后忘了可以回来看看（java,python3的位运算符用法相同）]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集-lc78]]></title>
    <url>%2F2019%2F09%2F16%2F20190916-lc78%2F</url>
    <content type="text"><![CDATA[题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subsets java–迭代123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); res.add(new ArrayList()); for(int i = 0; i &lt; nums.length; i++)&#123; int count = res.size();//记录下当前res的长度，否则res空间跟着程序变化就会死循环 for(int j = 0; j &lt; count; j++)&#123; List&lt;Integer&gt; temp = new ArrayList(res.get(j)); temp.add(nums[i]); res.add(temp); &#125; &#125; return res; &#125;&#125; 程序思路是一开始创建一个[[]]，然后针对nums中的每个元素（以nums[0] = 1为例）进行：1、取出res中的每个子list–[]2、加上nums[0] = 1–[1]3、将这个新list加入到res中–res = [[],[1]]4、以此类推遍历nums中的所有元素 java–回溯123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); back(res, 0, nums, new ArrayList()); return res; &#125; public void back(List&lt;List&lt;Integer&gt;&gt; res, int n, int[] nums, List&lt;Integer&gt; temp)&#123; res.add(temp); for(int i = n; i &lt; nums.length; i++)&#123; List&lt;Integer&gt; t = new ArrayList(temp);//基础类型所以可以做到深拷贝 t.add(nums[i]); back(res, i+1, nums, t); &#125; &#125;&#125; python3–迭代12345678class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: count = len(res) for j in range(count): res.append([i]+res[j]) return res 123456class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: res = res + [[i] + num for num in res] return res 总结本题是一道lc中等难度题，主要学习了回溯和迭代两种做法，其中回溯法只要想像出递归树那么就能解决，主要注意的是避免因为细节问题出现重复项或多余项；迭代法思路比较巧妙，每次都在前一次迭代的基础上添加一个新元素，直到nums遍历完成。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到字符串中所有字母异位词-lc438]]></title>
    <url>%2F2019%2F09%2F11%2F20190911-lc438%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。不考虑答案输出的顺序。示例 1: 输入:s: “cbaebabacd” p: “abc” 输出:[0, 6] 解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。 示例 2: 输入:s: “abab” p: “ab” 输出:[0, 1, 2] 解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string java–滑动窗口123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res=new ArrayList(); if(s.length()==0||s.length()&lt;p.length()) return res; int[] pnum=new int[26]; int[] snum=new int[26]; for(char c:p.toCharArray()) pnum[c-'a']++; for(int i=0; i&lt;p.length()-1; i++) snum[s.charAt(i)-'a']++; for(int i=p.length()-1; i&lt;s.length(); i++)&#123; snum[s.charAt(i)-'a']++; if(Arrays.equals(pnum, snum)) res.add(i-p.length()+1); snum[s.charAt(i-p.length()+1)-'a']--; &#125; return res; &#125;&#125; python3–滑动窗口123456789101112131415161718class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: if len(s) &lt; len(p): return [] Num = [] n = len(p) A = [0] * 26 for i in range(n): A[ord(p[i]) - ord('a')] += 1 A[ord(s[i]) - ord('a')] -= 1 if A == [0] * 26: Num.append(0) for i in range(n, len(s)): A[ord(s[i]) - ord('a')] -= 1 A[ord(s[i - n]) - ord('a')] += 1 if A == [0] * 26: Num.append(i + 1 - n) return Num ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。实例如下 12345&gt;&gt;&gt;ord('a')97&gt;&gt;&gt; ord('€')8364&gt;&gt;&gt; 总结又是一道扮猪吃老虎的简单题，如果对于滑动窗口的使用不够熟练，那么这个题是有些难度的，我在空闲时间想刷一下简单题一下子就卡住了，花了些时间搞懂了滑动窗口逻辑处理的方式就很简单了。这题主要在于在窗口的移动中要维护好窗口，并且每次移动窗口都进行判断是否配对。python3和java是两种做法，但是都是基于的滑动窗口的维护，刚好可以帮助我们更好的多角度的掌握滑动窗口的使用。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Level Order Traversal-lc102]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc102%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / 9 20 / 15 7返回其层次遍历结果： [ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal java–BFS123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); if(root == null) return res; Queue&lt;TreeNode&gt; queue=new LinkedList(); queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); List&lt;Integer&gt; temp = new ArrayList(); for(int i=0;i&lt;len;i++)&#123; TreeNode t = queue.poll(); temp.add(t.val); if(t.left!=null) queue.add(t.left); if(t.right!=null) queue.add(t.right); &#125; res.add(temp); &#125; return res; &#125;&#125; python3–BFS1234567891011121314151617181920212223242526272829= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result=[] queue=collections.deque() queue.append(root) \#visited=set(root) 在二叉树的层序遍历中可省，但是在图中这句是必须的，否则会访问重复的节点 while queue: level_size=len(queue) cur_level=[] for _ in range(level_size): node = queue.popleft() cur_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(cur_level) return result python3–DFS123456789101112131415class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] self.result = [] self._dfs(root,0) return self.result def _dfs(self, root: TreeNode, level): if not root: return if len(self.result)&lt;level+1: self.result.append([]) self.result[level].append(root.val) self._dfs(root.left,level+1) self._dfs(root.right,level+1) 总结非常经典的题，以至于在数据结构这门专业课中都有专门介绍的经典算法，但是即使在已经学习过思想的情况下，写起来依旧有很多值得注意的点。经典的solution是我们的BFS，也顺应我们的通常思维，通过一个队列来一层一层的存储树中的节点，每次内层循环都是每层的长度，值得注意的是图的层序遍历也可以这么做，不过需要多加一个visited的set用于判断是否重复（这是树中没有的操作因为树不会有循环结构） 另一方面，发现了DFS的做法，说实话DFS非常的反正常思维，但是确实可行，而且利用递归代码还显得更为简洁，我参考视频中大牛的思路写了python3的版本，将java版本留下以后复习再写。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House Robber lc198]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc198%2F</url>
    <content type="text"><![CDATA[题目描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber python31234567class Solution: def rob(self, nums: List[int]) -&gt; int: pre = 0 cur = 0 for i in nums: cur, pre = max(pre+i,cur),cur return cur java123456789101112class Solution &#123; public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int i:nums)&#123; int temp = curMax; curMax = Math.max(preMax+i,curMax); preMax = temp; &#125; return curMax; &#125;&#125; 总结个人感觉又是一道扮猪吃老虎的lc简单题，看到easy的标签让人觉得可以通过循环遍历来处理解决它，但其实通常的循环遍历并不能解决这个题，它其实是个典型的动态规划思想的题，通过从数组长度1开始拓展，每次规划取最优解。没错这种不使用递归的简单动态规划似乎又可以被想成一种数学归纳的方法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diameter of Binary Tree lc543]]></title>
    <url>%2F2019%2F09%2F07%2F20190907-lc543%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/diameter-of-binary-tree python3–递归123456789101112131415161718192021222324= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: res = 0 def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: if root == None: return 0 self.depth(root) return self.res def depth(self, root: TreeNode): if root == None: return 0; l = self.depth(root.left) r = self.depth(root.right) if l + r &gt; self.res: self.res = l + r return max(l, r) + 1 java–递归12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res=0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; depth(root); return res; &#125; public int depth(TreeNode root)&#123; if(root == null) return 0; int r = depth(root.right); int l = depth(root.left); if(r + l &gt; res) res = r + l; return Math.max(r, l)+1; &#125;&#125; 总结本题是一道leetcode简单难度的题，思路比较明确那就是利用递归的思想每次对于一个节点都要获取它的左右子树的最大深度然后暂存这两个值的和，并且每次返回的是两者中的较大的值供上层递归使用，这题比较奇特的地方在于它虽然利用递归但是并不能靠递归的返回值累加来获得最终的结果，需要创建一个全局变量并且在整个递归的过程中维护这个全局变量的值，它才是我们最终的res，所以我抱着传统的递归思路去做这个题的时候总感觉思路很清晰却总有点问题，最后看了评论区大佬的思路才恍然大悟，所以说思路不能固化，即使是递归也有不同的用法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 teaching experience]]></title>
    <url>%2F2019%2F08%2F30%2F20190830%2F</url>
    <content type="text"><![CDATA[前言由于这周回了一条天国的微信消息被老师派遣去干苦力教一名高中生python3编程，并且自己的python3也就是个半吊子于是乎一周都沉浸在现学现卖赶制第二天ppt的劳累生活之中，算是尝试了一把新人老师的心酸生活。 但是，另一个角度来说我也又过了一遍python3的基础语法，可以说收获还是有的。由于本科是c语言作为第一门编程语言学习语法，所以母语思维就是静态语言类型，后来学c++，java可以说由于同是静态语言差别并不大。而python是在大三的时候企业工程实践老师在介绍Jquery和Flask时提到让我们学，当时也没有系统的教我们，只是在用到的部分就去查这样的填补式学习，而这一周算是让我补上了以前缺失的基础部分知识。 安装与使用自己用的macos所以有自带python2.7，但是教学需要还是重新下载覆盖了python3.7，使用的是python3.7版本的anaconda，记得以前本科时使用opencv2踩过坑，当时傻白甜的下载了官网python并自己导入包，老师就说过可以用anaconda。如今才知道anaconda是个python开源版本&amp;包管理工具，如果可以回到从前我一定拍死自己= =。 下载anaconda就意味着python3.7和一些IDE都已经下载好了，配置一下环境变量即可覆盖2.7并使用，python环境变量配置比较简单就略过吧。值得一题的是Jupyter notebook这个IDE，作为新手的IDE来说确实不错，不需要适应新的客户端，网页端就可以用，基础功能也比较全面，非常时候新手学习使用。而且anaconda自带，也不需要另外下了。 动态语言python的优势作为我接触的第一个动态编程语言，python给我的第一感觉是不可思议的，相比之下java就显得严格且死板。 首先接触到的区别在于python对于基础类型的自动转换，使得我们不需要通过基础类型关键字去创建变量，并且可以批量赋值十分灵活。 12345678910===python3x, y=1, 1.2x, y='1', '1.2'===javaint x=1;float y=1.2char z='1'String x="1.2"//......wdnmd 其次python灵活丰富的方法以及运算符重载使得可操作性极其强大，你不仅可以用+号去拼接字符串，还可以去拼接list，set等，用-号去操作set等。而这些高级数据结构的重载在java中是没有的，你只能手动去实现。。。 python与java在看了一周python的基础语法后我发现作为一门OOP语言python与java其实在基础语法方面基本是一致的，只是形式不同，python使用冒号：以及严格的缩进区分方法体，类内容等，同时加不加分号；作为结束都是不影响的。而java使用大括号{}区分方法体和类的内部，并且严格的要求在变量定义和创建参数列表时使用基础类型关键字，并且每一条语句需要分号；结束。 当然除了格式的不同，它们在基础语法的部分也是有一定差别的第一、python中没有char类型的概念，全部使用string类型，也没有数组int[]的概念全部使用list。可以说更加简洁方便 第二、python中没有java中的这种常用for循环用法 123for(int i=0;i&lt;nums.length;i++)&#123; ......&#125; 取而代之的是配合range的for循环，两者功能一致，而且都非常好用 12for i in range(nums): ...... 第三、python的类变量区分为class variables 和 instance variables。而java中与之对应的是static关键字修饰的静态成员变量以及普通成员变量。两种语言的变量相互对应起来功能类似，但是又有细微的区别。 1234567891011===pythonclass Shark(): \# class variable type="fish" def __init__(self, name): \# instance variable self.name = names1=Shark("Lucy")s2=Shark("Lily")s1.type="food" 如果我执行以上的语句，如果是java的静态成员变量，那么s2的type属性会同步成”food”，但是在python中不会，python会认为s1并没有权限修改class variable因此在执行修改时将s1的type属性降级成instance variable从而成为s1专属的成员变量，而不会影响其他Shark对象的type属性。简单说来python拒绝类对象对类变量执行重新赋值“=”的操作，会导致变量类型的转换（我理解为权限的降级），但是以下的修改语句是被允许的 123456class Shark(): num=[1,2,3]s1=Shark()s2=Shark()s1.num.append(4) 可以理解为类对象可以修改但不能重新赋值类变量，这种行为比较奇特也是java中没有的，我暂时还不知道为什么python会有这样的特性。 总结这一周时间都贡献给了python，既没有新技术栈的学习，也没有踩坑解惑的经历，只是回顾了以前的知识并补ß上一些空白，最初的两天我是很不爽的，我觉得这完全是浪费时间，然而现在我觉得这还是有意义的，而且是我以前很少做的事，知识在回顾的时候可能学到更多，而且可以加深自己以前的理解。总的来说这一周不亏。马上后天研究生开学了，期待一个新的生活吧。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ+Mqtt enable publisher/subscriber]]></title>
    <url>%2F2019%2F08%2F17%2F20190817-tec%2F</url>
    <content type="text"><![CDATA[前言这周有空余时间于是补了一下上周的week4任务中的ActiveMQ使用，本来想下载apache apollo的，但是发现apache官网已经没有了apollo的下载提供，短暂的尝试寻找资源后放弃了，反正一脉相承，又是官网主推的，那么就用ActiveMQ代替学习吧。但是不得不说最新版本东西的可借鉴博客真的少的可怜，基本都是讲apollo的，我结合apollo类似部分以及啃官方文档总算是大概用起来了。 经历安装与启用本来还在官网下载了一下ActiveMQ的最新版本然后手动移动解压文件后来一拍脑袋，有homebrew不用的都是傻子，于是删掉后shell里一行装好，不得不说homebrew是真的香啊，不枉我上周踩了好久坑才装好。 1brew install activemq 安装好以后直接用activemq命令就可以开启和关闭服务 12activemq startactivemq stop 这里有一点，启动后官方文档说shell中会有启动的web页面端口号，但是我自己启动并没有发现有端口号提示，一开始是看网上的博主的默认端口号打开的网页端，后来知道activemq的文件家中/../conf文件夹中有activemq的所有配置文件，包括默认用户名密码，网页默认端口，各种连接方式端口等等，都可供修改。 启动服务后，打开网页url输入用户名密码就可以登陆服务端管理界面了里面有topic，queue创建管理以及连接上服务端的客户端的管理，已有订阅者的管理等等。 实现subscriber/publisher在上一步开启服务进入服务页面后，我还使用了两个客户端和它进行连接，分别是：1、mqttfx，之前学mqtt的时候下的，当时没用上现在用了，通过activemq提供的mqtt端口接入，填好mqttfx的信息后connect建立连接。就可以实现订阅topic和向topic publish信息。2、下载的activemq文件夹中有提供相应的简易客户端用于test，我使用了example文件夹下mqtt/websocket的客户端，就一个html页面，页面极度简单，填完连接信息connect后就一个输入框一个按钮一个显示框，像极了刚学C# winform时拖控件的我做出的第一个界面= =，不过这也算是有基本功能了，可以说是易用性极强。 两个客户端都连接上服务端后，就可以动手创建topic，订阅消息发布消息，查看mqtt这种中间件的运作模式了，动了手以后会让理论上的理解更上一层楼。 总结mqtt确实是提供了一个双向交互的中间消息队列服务，其中服务端只是做一个中转站，只要是连接上服务端的客户端，并且订阅了同一个topic，那么他们就可以通过服务端进行双向的交互，可以说非常方便。还记得以前企业工程实践课的老师让我们学socket的时候，说用socket就可以很快的实现类似qq这样的聊天软件功能，现在知道了mqtt这种中间件，看看都是封装tcp协议的东西，如果只是实现聊天的话mqtt这边用现成的客户端一行代码都不用敲= =。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair drift]]></title>
    <url>%2F2019%2F08%2F16%2F20190816-tec%2F</url>
    <content type="text"><![CDATA[前言暑假提前来到学校也跟着学长的开发任务做了些事，大概是一周前还做着开发任务，隔了一周配置本地项目又是不知所措，好多熟悉的bug又遗忘了怎么处理，关键是自己寻找问题解决方案的能力还很有待提高总是浪费很多时间才能解决，总是去问学长又太麻烦他，以后我会将每一段时间的项目经验总结在这里，方便回顾学习，温故而知新。 这次主要是springboot+springcloude+mybatis的果麦新风drift模块的开发，需要给订单order对应的快递单号express功能接口的实现，中间碰了很多坑。 踩坑经历1、本地与服务器的配置不同与冲突这一部分是每次git pull整合本地代码以后都要做的事，已经习惯了如何处理倒是没有花费太多的时间，首先检查eureka-server端的properties文件，写一个自己想用的端口号，并且做一些常规的处理 1234567#spring.profiles.active=test 这一行是服务端代码，用于选择需要的properties版本server.port=8080eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 然后检查需要开发的drift模块的properties文件 12345678910111213server.port=8000spring.application.name=drift-agenteureka.client.healthcheck=trueeureka.client.service-url.defaultZone=http://127.0.0.1:8080/eureka/mybatis.config-location=classpath:mybatis-config.xmlspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/gmair_drift?useLegacyDatetimeCode=false&amp;serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=shuge888 以及pom文件中的架包依赖，这主要是修改本地与服务端使用的不同版本的架包依赖，例如我们服务端中mysql的drive驱动版本是6.0.6，但是我本地的mysql版本较新需要使用新一些的drive驱动例如8.0.11否则本地运行会报错。 这里要着重说的是common模块中lombok版本不匹配问题影响了我很长时间，最后是麻烦学长才解决的，lombok是用于自动添加实体类get()/set()方法的工具，但是服务器上的java9版本的lombok版本却与我本地的java11冲突，导致maven重新生成target文件夹失败，进而导致mybatis的XML文件中引用枚举类型enum的handler失败，需要修改lombok架包版本才能解决这一系列的问题。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--这条语句是老版本lombok没有的，但是缺少这条语句又是不行的--&gt;&lt;/dependency&gt; Addition:我对maven的命令使用也不熟悉，常用命令还是要牢记的，例如清理maven后重新安装项目以及依赖的命令；maven打包命令 123mvn -U clean installmvn package 2、总体项目进度带来的对其他模块的依赖在一周前还可以本地运行的项目一周后就不行了，因为总的项目进度在向前，开发的模块可能加入了对其他开发者模块的依赖，例如我这次添加的wechat.properties以及sesame.properties。这两个配置文件缺失的话就无法运行项目，前者是微信模块，可以直接创建一个新的文件里面的内容部分留空也可以运行；后者则是alipay相关模块，里面需要内容，这一部分问学长要了一下填上也就解决了。 3、自己编程造成的bug这一部分我是没有想到的，由于昨天是12点前开始写到1点半写完的接口（别问我之前干嘛去了，我也不知道我的时间去哪儿了= =），在第二天提交后测试的时候发现两处致命的错误。。。（没错有一处还是拼写错误），这两处错误精妙的没有引起编译报错，又确实的造成了软件错误，因为这两处错误一处出在xml文件中的拼写错误，另一处是写Express实体类的时候忘记extend Entity基础类了导致实体缺了两个公共属性。 回想起来这是真的蠢，再次提醒自己编码一定要细致，尽量在自己精力充沛的时候进行开发任务，不然会出很多错。 新学到的东西java中的枚举类型enum早就知道有这么个东西了，但是一直都没有自己用过，这次在开发任务中碰到也算是学习了一下，首先枚举类型的构造十分简单，和class类似。 123456789101112131415161718192021public enum ExpressStatus implements EnumValue &#123; DELIVERED(0),BACk(1); private int value; ExpressStatus(int value)&#123;this.value=value;&#125; public static ExpressStatus valueOf(int value)&#123; //这个方法是重载的，用于枚举值和实际值int转换 switch (value)&#123; case 0: return DELIVERED; case 1: return BACk; default: return null; &#125; &#125; @Override public int getValue()&#123;return value;&#125;&#125; 定义后在后端代码中正常使用即可，主要的不同在于mybatis的xml文件中与数据库表的映射需要调用一个handler处理，在insert方法中调用系统的EnumOrdinalTypeHandler即可正常转换插入 123456789&lt;insert id="insert" parameterType="finley.gmair.model.drift.Express" useGeneratedKeys="false"&gt; insert into gmair_drift.order_express (order_id, express_id, express_status, company, block_flag, create_time) VALUES (#&#123;orderId&#125;, #&#123;expressId&#125;, #&#123;status, typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;company&#125;, #&#123;blockFlag&#125;, #&#123;createAt&#125;)&lt;/insert&gt; 这样可以保证数据插入的正常，但是想要正常的获取数据还需要我们自己写一个handler用于数据的检验和转换，这个handler类的编写是继承并实现系统提供的abstract class，第一眼看上去好像代码很复杂但是其实都是根据实际情况overwrite，而且逻辑简单，只是抽象类的方法体比较陌生，但是其实并不难。这个ExpressStatusHandler的代码较长而且就是实现抽象类就不贴了，写好以后在mybatis中的xml文件中的”resultMap”映射标签中提供这个handler就ok了 1234567&lt;resultMap id="expressVo" type="finley.gmair.model.drift.Express"&gt; &lt;result property="orderId" column="order_id"&gt;&lt;/result&gt; &lt;result property="expressId" column="express_id"&gt;&lt;/result&gt; &lt;result property="company" column="company"&gt;&lt;/result&gt; &lt;result property="status" column="express_status" typeHandler="finley.gmair.mybatis.handler.ExpressStatusHandler"&gt;&lt;/result&gt;&lt;/resultMap&gt; 这样就实现了枚举类与数据库交互的转换。 总结学习总是难受的过程，拿到任务我也总是会畏难，拖啊拖的，但是其实碰到的困难有多难克服并总结后的收获就有多大。今天是8月16号，离开学也就剩两周时间了，希望自己能好好抓紧时间少摸鱼多锄地！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree lc538]]></title>
    <url>%2F2019%2F08%2F14%2F20190814-lc538%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / 2 13 Output: The root of a Greater Tree like this: 18 / 20 13 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree python3–lastOrder递归1234567891011121314151617= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: count=0; def convertBST(self, root: TreeNode) -&gt; TreeNode: if root: root.right=self.convertBST(root.right); root.val=root.val+self.count; self.count=root.val; root.left=self.convertBST(root.left); return root; return None; java–lastOrder非递归12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int count=0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack(); //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考 TreeNode node=root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.add(node); node=node.right; &#125; node=stack.pop(); node.val+=count; count=node.val; if(node.left!=null) node=node.left; else node=null; &#125; return root; &#125;&#125; 总结本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求众数 lc169]]></title>
    <url>%2F2019%2F08%2F07%2F20190807-lc169%2F</url>
    <content type="text"><![CDATA[题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element java–sort+map+摩尔投票法sort后一次遍历处理，时间复杂度O(NlogN)12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; //if(nums==null)return 0;题目保证不会出现的情况 if(nums.length==1)return nums[0]; int count=1; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i++) &#123; if(nums[i]==nums[i+1]) count++; else &#123; if(count&gt;nums.length/2) return nums[i]; else count=1; &#125; &#125; return count&gt;nums.length/2?nums[nums.length-1]:0; &#125;&#125; map一次遍历存储后输出即可，时间复杂度O(N)123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int x:nums)&#123; if(map.containsKey(x)) map.put(x,map.get(x)+1); else map.put(x,1); &#125; for(int x:map.keySet())//keySet方法返回key的集合set if(map.get(x)&gt;nums.length/2) return x; return 0; &#125;&#125; 摩尔投票法O(N)1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int maj = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (maj == nums[i]) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; &#125; return maj; &#125;&#125; python本题投机取巧法（如果有唯一众数，那一定是排序后的中位数） 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2]; 总结本题是leetcode中的简单难度题，只是求解的话比较容易。 但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好 而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pow(x,n) lc50]]></title>
    <url>%2F2019%2F08%2F06%2F20190806-lc50%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000 示例 2:输入: 2.10000, 3输出: 9.26100 示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n java–非递归分治循环123456789101112class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i=i/2) &#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; python–递归123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x, n = 1/x, -n; if not n: #recursion termination return 1; if n % 2: return x*self.myPow(x, n-1); return self.myPow(x*x, n/2); 总结本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。需要注意的有两点：一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n = 1/x, -n」比较方便。二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。tip：注意递归写法的重要习惯————递归终止语句]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯理解+实例]]></title>
    <url>%2F2019%2F08%2F05%2F20190805%2F</url>
    <content type="text"><![CDATA[什么是贝叶斯英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。 在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2/10）而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。 贝叶斯案例有两个一模一样的碗1号碗里有：30个巧克力和10个水果糖2号碗里有：20个巧克力和20个水果糖然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率） 第1步，分解问题1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？来自1号碗记为事件A1，来自2号碗记为事件A2取出的是巧克力，记为事件B，那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率 2）已知信息：1号碗里有30个巧克力和10个水果糖2号碗里有20个巧克力和20个水果糖取出的是巧克力 第2步，应用贝叶斯定理1）求先验概率由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)=P(A2)=0.5,(其中A1表示来自1号碗，A2表示来自2号碗)这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。 2）求可能性函数P(B|A1)/P(B)其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)=30/(30+10)=75%P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)=0.75*0.5+20/(20+20)*0.5=62.5%所以，可能性函数P(A1|B)/P(B)=75%/62.5%=1.2可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。 3）带入贝叶斯公式求后验概率将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)=60%这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
