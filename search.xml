<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
