<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A New Attempt</title>
    <url>/2019/07/28/20190728/</url>
    <content><![CDATA[<p>I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here! </p>
]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
  <entry>
    <title>Some Daliy Complaint</title>
    <url>/2019/08/01/20190801/</url>
    <content><![CDATA[<p>Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.<br>I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.<br>Wish a good morning. </p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先 lc236</title>
    <url>/2019/08/02/20190802-lc236/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a></p>
<p><img src="/images/20190802lc236/binarytree.png" alt="图1"></p>
<h3 id="java–递归"><a href="#java–递归" class="headerlink" title="java–递归"></a>java–递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null||root==p||root==q) <span class="built_in">return</span> root;</span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left==null) <span class="built_in">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==null) <span class="built_in">return</span> left;</span><br><span class="line">        <span class="built_in">return</span> root;</span><br><span class="line">        //return left==null?right:right==null?left:root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路：<br>1、如果root就是p或q则root必定就是最近公共祖先<br>2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先<br>3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。</p>
<h2 id="拓展-lc235二叉搜索树的最近公共祖先"><a href="#拓展-lc235二叉搜索树的最近公共祖先" class="headerlink" title="拓展 lc235二叉搜索树的最近公共祖先"></a>拓展 lc235二叉搜索树的最近公共祖先</h2><p>与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)</span><br><span class="line">            <span class="built_in">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)</span><br><span class="line">            <span class="built_in">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="built_in">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树 lc98</title>
    <url>/2019/07/30/20190730-lc98/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree">https://leetcode-cn.com/problems/validate-binary-search-tree</a></p>
<p>思路1:中序遍历二叉树，生成序列如果升序则true，else false<br>思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归</p>
<h3 id="python3–语言优势递归生成中序序列"><a href="#python3–语言优势递归生成中序序列" class="headerlink" title="python3–语言优势递归生成中序序列"></a>python3–语言优势递归生成中序序列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">‘’‘</span><br><span class="line"> Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> class TreeNode:</span><br><span class="line">     def __init__(self, x):</span><br><span class="line">         self.val = x</span><br><span class="line">         self.left = None</span><br><span class="line">         self.right = None</span><br><span class="line">’‘’</span><br><span class="line">class Solution:</span><br><span class="line">    def isValidBST(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        o=self.inorder(root);</span><br><span class="line">        <span class="built_in">return</span> o==list(sorted(<span class="built_in">set</span>(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树</span><br><span class="line">        </span><br><span class="line">    def inorder(self,root: TreeNode) -&gt; list:</span><br><span class="line">        <span class="keyword">if</span> root is None:</span><br><span class="line">            <span class="built_in">return</span> [];</span><br><span class="line">        <span class="built_in">return</span> self.inorder(root.left)+[root.val]+self.inorder(root.right);</span><br></pre></td></tr></table></figure>

<h3 id="java–经典的非递归中序遍历，使用前一项判断"><a href="#java–经典的非递归中序遍历，使用前一项判断" class="headerlink" title="java–经典的非递归中序遍历，使用前一项判断"></a>java–经典的非递归中序遍历，使用前一项判断</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();</span><br><span class="line">        double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()||root!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=null)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;=pre)</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre=root.val;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Pow(x,n) lc50</title>
    <url>/2019/08/06/20190806-lc50/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。<br>示例 1:<br>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>示例 2:<br>输入: 2.10000, 3<br>输出: 9.26100</p>
<p>示例 3:<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</p>
<p>说明:<br>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/powx-n">https://leetcode-cn.com/problems/powx-n</a></p>
<h3 id="java–非递归分治循环"><a href="#java–非递归分治循环" class="headerlink" title="java–非递归分治循环"></a>java–非递归分治循环</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public double myPow(double x, int n) &#123;</span><br><span class="line">        double res=1.0;</span><br><span class="line">        <span class="keyword">for</span>(int i=n;i!=0;i=i/2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%2!=0)</span><br><span class="line">                res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> n&gt;0?res:1/res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python–递归"><a href="#python–递归" class="headerlink" title="python–递归"></a>python–递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myPow(self, x: <span class="built_in">float</span>, n: int) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; 0:</span><br><span class="line">            x, n = 1/x, -n;</span><br><span class="line">        <span class="keyword">if</span> not n:      <span class="comment">#recursion termination</span></span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        <span class="keyword">if</span> n % 2:</span><br><span class="line">            <span class="built_in">return</span> x*self.myPow(x, n-1);</span><br><span class="line">        <span class="built_in">return</span> self.myPow(x*x, n/2);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。<br>需要注意的有两点：<br>一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n &#x3D; 1&#x2F;x, -n」比较方便。<br>二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。<br>tip：注意递归写法的重要习惯————递归终止语句</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯理解+实例</title>
    <url>/2019/08/05/20190805/</url>
    <content><![CDATA[<h3 id="什么是贝叶斯"><a href="#什么是贝叶斯" class="headerlink" title="什么是贝叶斯"></a>什么是贝叶斯</h3><p>英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。</p>
<p>在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2&#x2F;10）<br>而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。<br><img src="/images/20190805/bys.jpg" alt="贝叶斯公式"></p>
<h3 id="贝叶斯案例"><a href="#贝叶斯案例" class="headerlink" title="贝叶斯案例"></a>贝叶斯案例</h3><p>有两个一模一样的碗<br>1号碗里有：30个巧克力和10个水果糖<br>2号碗里有：20个巧克力和20个水果糖<br><img src="/images/20190805/wan.jpg"><br>然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。<br>问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率）</p>
<h4 id="第1步，分解问题"><a href="#第1步，分解问题" class="headerlink" title="第1步，分解问题"></a>第1步，分解问题</h4><p>1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？<br>来自1号碗记为事件A1，来自2号碗记为事件A2<br>取出的是巧克力，记为事件B，<br>那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率</p>
<p>2）已知信息：<br>1号碗里有30个巧克力和10个水果糖<br>2号碗里有20个巧克力和20个水果糖<br>取出的是巧克力</p>
<h4 id="第2步，应用贝叶斯定理"><a href="#第2步，应用贝叶斯定理" class="headerlink" title="第2步，应用贝叶斯定理"></a>第2步，应用贝叶斯定理</h4><p><img src="/images/20190805/bys1.jpg"><br>1）求先验概率<br>由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)&#x3D;P(A2)&#x3D;0.5,(其中A1表示来自1号碗，A2表示来自2号碗)<br>这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。</p>
<p>2）求可能性函数<br>P(B|A1)&#x2F;P(B)<br>其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。<br>因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)&#x3D;30&#x2F;(30+10)&#x3D;75%<br><img src="/images/20190805/bys3.jpg"><br>P(B)&#x3D;P(B|A1)P(A1)+P(B|A2)P(A2)&#x3D;0.75*0.5+20&#x2F;(20+20)*0.5&#x3D;62.5%<br>所以，可能性函数P(A1|B)&#x2F;P(B)&#x3D;75%&#x2F;62.5%&#x3D;1.2<br>可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。</p>
<p>3）带入贝叶斯公式求后验概率<br>将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)&#x3D;60%<br>这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。<br><img src="/images/20190805/bys2.jpg"></p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>求众数 lc169</title>
    <url>/2019/08/07/20190807-lc169/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element">https://leetcode-cn.com/problems/majority-element</a></p>
<h3 id="java–sort-map-摩尔投票法"><a href="#java–sort-map-摩尔投票法" class="headerlink" title="java–sort+map+摩尔投票法"></a>java–sort+map+摩尔投票法</h3><h4 id="sort后一次遍历处理，时间复杂度O-NlogN"><a href="#sort后一次遍历处理，时间复杂度O-NlogN" class="headerlink" title="sort后一次遍历处理，时间复杂度O(NlogN)"></a>sort后一次遍历处理，时间复杂度O(NlogN)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        //if(nums==null)<span class="built_in">return</span> 0;题目保证不会出现的情况</span><br><span class="line">        <span class="keyword">if</span>(nums.length==1)<span class="built_in">return</span> nums[0];</span><br><span class="line">        </span><br><span class="line">        int count=1;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+1])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;nums.length/2)</span><br><span class="line">                    <span class="built_in">return</span> nums[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> count&gt;nums.length/2?nums[nums.length-1]:0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map一次遍历存储后输出即可，时间复杂度O-N"><a href="#map一次遍历存储后输出即可，时间复杂度O-N" class="headerlink" title="map一次遍历存储后输出即可，时间复杂度O(N)"></a>map一次遍历存储后输出即可，时间复杂度O(N)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=new HashMap();</span><br><span class="line">        <span class="keyword">for</span>(int x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))</span><br><span class="line">                map.put(x,map.get(x)+1);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(x,1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int x:map.keySet())//keySet方法返回key的集合<span class="built_in">set</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(x)&gt;nums.length/2)</span><br><span class="line">                <span class="built_in">return</span> x;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="摩尔投票法O-N"><a href="#摩尔投票法O-N" class="headerlink" title="摩尔投票法O(N)"></a>摩尔投票法O(N)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int majorityElement(int[] nums) &#123;</span><br><span class="line">        int count = 1;</span><br><span class="line">		int maj = nums[0];</span><br><span class="line">		<span class="keyword">for</span> (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (maj == nums[i])</span><br><span class="line">				count++;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				count--;</span><br><span class="line">				<span class="keyword">if</span> (count == 0) &#123;</span><br><span class="line">					maj = nums[i + 1];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> maj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python本题投机取巧法"><a href="#python本题投机取巧法" class="headerlink" title="python本题投机取巧法"></a>python本题投机取巧法</h3><p>（如果有唯一众数，那一定是排序后的中位数）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def majorityElement(self, nums: List[int]) -&gt; int:</span><br><span class="line">        <span class="built_in">return</span> sorted(nums)[len(nums)//2];</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是leetcode中的简单难度题，只是求解的话比较容易。</p>
<p>但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好</p>
<p>而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title>Convert BST to Greater Tree lc538</title>
    <url>/2019/08/14/20190814-lc538/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p>Example:</p>
<p>Input: The root of a Binary Search Tree like this:<br>              5<br>            &#x2F;   <br>           2     13</p>
<p>Output: The root of a Greater Tree like this:<br>             18<br>            &#x2F;   <br>          20     13</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a></p>
<h3 id="python3–lastOrder递归"><a href="#python3–lastOrder递归" class="headerlink" title="python3–lastOrder递归"></a>python3–lastOrder递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">= Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line">= class TreeNode:</span><br><span class="line">=     def __init__(self, x):</span><br><span class="line">=        self.val = x</span><br><span class="line">=        self.left = None</span><br><span class="line">=        self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    count=0;</span><br><span class="line">    def convertBST(self, root: TreeNode) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.right=self.convertBST(root.right);</span><br><span class="line">            root.val=root.val+self.count;</span><br><span class="line">            self.count=root.val;</span><br><span class="line">            root.left=self.convertBST(root.left);</span><br><span class="line">            <span class="built_in">return</span> root;</span><br><span class="line">        <span class="built_in">return</span> None;</span><br></pre></td></tr></table></figure>
<h3 id="java–lastOrder非递归"><a href="#java–lastOrder非递归" class="headerlink" title="java–lastOrder非递归"></a>java–lastOrder非递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int count=0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=new Stack();</span><br><span class="line">        //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考</span><br><span class="line">        TreeNode node=root;</span><br><span class="line">        <span class="keyword">while</span>(node!=null||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=null)&#123;</span><br><span class="line">                stack.add(node);</span><br><span class="line">                node=node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node=stack.pop();</span><br><span class="line">            node.val+=count;</span><br><span class="line">            count=node.val;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=null)</span><br><span class="line">                node=node.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node=null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>PES-Gmair drift</title>
    <url>/2019/08/16/20190816-tec/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c43ec22bbbe040f8b500ce1d331e33c568888368e18cbf2b9bba255da1d92418">4d94d3e2ea964a9497276ed6e2e3b252f7448996904b2d22e4065ed40f4d7e9820f3762c45d6cbdf9bdce19c3334dec7958c66ab6f6a69930450e914b93ff12edc2be17e8f1bb535973f5b066adf452a76c30c784439363132764048afb28ef0aa5da0a1425784ed9a46e92797ac210ffa3d252e33e5454b777daee1ae4cac6ab345ad2e53e613da99f109665add7ce69894df32eea6647e03f1214c99a28d9e09831a3d64530b6cd54642207cc2e6a66e719c54bf3b853032381a33b9500db8dc2c8d37214c59228799a3451416e2eccb8c41840949d899a461a8e2d1dab30ea32b3f61e3d9e2b6cd6b19dc720519d6a331500657019ad53b3ee0c4148e5f089cc4988175388950d526be45f240818e574fbb5352370b5954b0cc16f0c627ea2b477f5f7fdaed65e24106b8caf1efef3aae207dde88d9465e3c206e277dbb1ee9e94d400bf97813a20728c9cda9b9206f02a8474ec1d17bf9538b5b24356244ffbcdd9b8bb06f9333b08a87e012828a5789b2364a16463afdb4044c43854e734abe4dbc4abcb777dc4d2825b8e2279963ef7eb17eb0a1f191b3da6003aee7d5cbfab97c659378767802f620a088ba46c71909a3788a838fa689a29d985140c2dbfeacc7ce82da0e67c488c71a02a815ed95d7a56dc108f48667ce4f5d5bbbfa6d3a0c8aa7e716ab287b424c3d41cd0a0f4c4dae1d72b9c623cef10dc11f61e8b13e65c542f0d213e546a5d002effd19630eed66b3e499ee675056ca32726fa84bad2fce5c822ab468918f436316194e32a3398ae5fcafb449eefb8be352a842568022b4ae0c46a37637e440387d4ab8e6be9d58a9352581fc53d7291200a6db3884d7f1d6898d2b05c501ed5988ef82dba7fade15566376a138392b57c3326ffd6714a8577f6ccef9548c1234a2e513fc42af636e70ca130ac3f8a47a7911f54d74cb41c93344966453caa682e6176308b27f9436c84f5a888f40f2b7b4e6776aaf32724ea8a288dbda60e76e431008569c3b3fa88471282fa1e21ed464d9a8f6c98642c9941022ef1741eee4ada3b056c448e6c4bca2ef455d4aea7793d24227c1c1c12eda2519c29e2506775e8748aaceb50c6e92237be72da7cf9cca1115c49b16981ac82cef7b4ee1e5aef04b28339a9cd489d057b4eb9695dfcb23586a903c078873e1178615e122b8aa74d5b41f21284c436432733e4352ec3b91c767dd545bc2b94f1dd8811da16cfea46555fe132314a9f63828fb009b97b7d5fa73e8c97d225fe888c45165ee55e4d3855b327909628e156a7a7002dda7a52fa4ad8c627b465cd137e252498e65183d4f97884aee3c46b89a23c80790bc5e6a01d622a5cc74c54063cf8f82a86eb562572330314743f146a3598a60b5304571f425ce5667183e6828ca5acae3debd87047f7d56f687daf539d89324ecbdc02bab34994d8cb3386c785169407accfcc4ba2f2faf7713dcf51f04f529af24b6737045dc9b63fbfe3e8e3dfca590e0e50fe1501f3d49312519ed65ad0eaefc07a85df6b2c667fd1a7df9a0de5e06b4f371525bddce7f220fcd794c981dde9b682e2105d71f534f52a1605675d3a2981698658d35ba894f636f3bfd4283c7e805ea91439c3b448c2a7b5bccd0db22c7f04a57b64a6284f44ec3a1b217d1db37643f88e6e33efbb6aab2c12fff3d0eead905ca21cfae4bb0a8ba294d379a92597685410e078533017b48809f2ee44c628c18c5eb1b44a8f753a3ef94dad54a90d842507b9a044ebf4961cbcde0788ab3e432652ede12d59add3a48a7d956cd63db5c8cc51a160a2f170bd6e0b8c24adb61d55e5d6d84c8157edd0a1647df351db7756acf426d954fa4b8b24f3a88a95a83436b82d2e2c0f9c58957d3ff22eafeb324ffb8721f40adfa707f6b670fa54680c120b39a2cc3e847eb6bc9a64d035fd9e7610d69666dffa874e66515dc535d18f3840a7baa3c8e7f68da48a12442dfc86ddb51928899cd78e5eac2b8cbe12f1334db5dc765b0125b71062c71b439dbfb055bdf7983aafb42b5e3b3e4fd603b107dd74423f45a2cfd939484b84265087193fa3dda0d94f65b6172e7cf0aacec173eedc5be723ce28c0167dc44b7cdbce8ac78975a0e5c19e73177c4dd98b93456639606f4e37dab0e08d7f8480e2917468323071148fbdc10ae0c198ca308faccd2d2687ad5c580ef32c9a578ea24d975492bc294942a463449100063ec608046f48d2af673329a047a446c24c6f213c4dcce3eedb3892cb637cef3ede24841f17b20d7d10bf58d9f3e9b0c342bd346dd9cf2e2757a3a334049e6b395557be86163085ee0069b1224b37d8af4b914f9c26cfc4440d058f0c697cd7026a5120e0318b7cbb9ff69134d0756b21b99e0ee844b8bc19f51137f809cd9e8b5b60da4c3965aca6f3fc5df29d0616abff4e927d8cbf462e22082d9ca4be11cad6d508c6c817b89a395b161fc8e99a2c45dd154ebf1915b37ee730a48235d7cb7ba34729300db7efd8fb6bcb135902fb3c52c3aeaaec348352cdfdc3630189a73eb4ad6db69e76ba9ed5a5ffd85812c0cdd002013642409b6f798b451ee8bcc134629cac44bc04fa167d8564e909d1776e919860c51e41ff1c2a889d6509f5276ae6e9637fd8d696458ada3f80fb081603de93c84e5863e17f19ed0250e17d3b60d2946ca08505f3d5fac3d1b93fbf22cd02c389afb8d02715bfcdba10910594a2f4a702a81ec8ecfb8df90a8944bde546b5eca674589ae9a9bb51cfdbd1369498351b29360afeb8e80a1cbcafb54335dc3c08e78aa4368c030fcc289d26ff74473e9486d3e7b1e76f3d153a07766ad03adb8b77fe2891f50002972ca2487a4d525c88f8aff6d96ad9c3b7d68e2fe54d12a98f05eb800e7575f3c1263eafa65faae5d90a655cb8ea50adbdc1aa1e4571359449fef6b0be5d76253920faa9d6514fc7c29404dbb9b1e84b2965a98f5889570f86085c05cd114b97574c315463e84eb6efb1f50ca4c5887b11dff3a03dc90d8f4cb9294545829b8ce50e4e39539b09b48a0224c2e4c9eb610e74006fcf65bc4f0fa22b02056c37be9e2c5baa4bd63aead12c2c9033e5c916d0204b0743c582634df3461420b9fa1535450f4249ebea552f20ca92ecdbad4cd1e5298be98e67c920ed106dfbedf974f247ce2dd24bfb2adddc0d502a279a385ce65874a69328e69f710479f6052c47df68a4fd0fb69a145467b5dead4258b4326c4ecf1845a3369552bb187d1cb6feddacb47f3d8abbd303d66a0439ff77bfeea6cc8dbe487e87442cd3cfaa732cdbacb1b941834c570e5661c93b9f07f164f04e7ced928d6c29ceaf471a7deec1fbc9d2294fe0f0334d541532dd40c28d82c75c904ecde158953c705f16a93057ab4f15339932e31441840fe664b9180cd238aaba622ee334cfd17d59f2f3ec56f92e4220d3cff5bfabc95fae27346f82b8f8ce187f167bf612e45084723e1d2d763c4d86c02349cb01de4616d6560c188a0267768dd482f79685479274bcfebfce403a10300b16143950ec4bcb9e94f22c6b4798f96a477b348455bb66e2756f978d892a269b522534462c1f52cee580df5a4a22d01008fe287e4714ee1fb5890595d2164d9e3ff85078f7637ad4bdc660b6db0e10c1f8bdeab010c9cc40a3e678459ce8a29dac70aceb0354ac79deae208c98f979569e382a79a5cd96058243a08df11ecbd2be287298a74f8a011ed50ab727a44c3164240311a0df1717b79aa4a2725022c33d7474ca431dd8dacc5b6acca3755458fc958bcf461dbb9710c5925759ba40ddc131ee8cbc6e2d3804694501f7f9ef0b0ea94a959d5516f4a7504a4fc16af58d1ed237b915f3ee26cc0ef961aa89ae9b3c82b914ab0729eb36453c641df4657de506ccbb6ab2f9de686fa584324e67610f7e90f43131bacaee42b814aa77abe568b6f83cbfee269dfbb40cccb2cda3e49aa08f6ba1ab3c86e26626117e4c221c4f01ee583adf79e0424d3978a207c304bd2096fe6eca58695cde1800c7af1618f5c52c619e2f791cdfb347eb2a30393ed5e4c0a02df3d9ee9703e17879ca7141e91ee3ba4df75613d71cbd1165ec09f89b8a8fb70c61478b4580b0b973ce74339799e2e0be5843634ad3fcf00017ecf8d4e53f0166f93a98071c636765352366de279af127d6227ac945edbdfecfa64ec3c341bb5420062fec6d47ea949b6a4ad1600ef9403e3e9a69e817580c0470d1d24d93a0e8a10dbf4ff21415ad9d635fbf351ebd68db733e6fa394f0f4ee15c93706c67b39aeec43fd4fbfd772058089843d55a08f26cf19c5f2f84478697bbece70bfba2224601af68e95c44f53726089cd10a716a8b604ecc52e49b52156b71a7d92d2aff1982743f9ca383ebab027e960654808998ee8da91f7503e8e81839d789f06c369a5e15af5b4e6caf99fddb70149b4af75c60cdd1929a14a4c2824bc4f10aec01200958847525f51f031963b07c34e30e92381b6de2759cbc3dbe142b7a8e07162222ffd18338d1fdfc0a52634fb989839644db5a4d51bc3b529f6f9a29b5b92f28b49c965fda15c2a6eb2257da536f2e228b156eff0d0c2dce5e1f91480cbd4b663981a4121d9f59b2bc848fb980cd0588f56bd9f4564366b5faf0ff094e168b2c2e11dc34fa27ccd85c567a951f12721d1b0bd6e9ebc6b6c8d001aca44243d86985f72a8a8a918decd81c08f9c03983c83ae87aa5392382d5bb1f8d182223f4649a72f99154aa5881246f7087bb82ab6a71ff1eca2acf39502fe53fae028b01f8c98cbfcb26792b90c5bf4a5f3be5585890d77642dc99b63f5a4b4590db9c6383963a952ebfc3fe903ba0055485837d93c030561be52ee2c2a964335f1253004e4f9a5bd497dc3d58c4bc248dd4de6a2ff21df5a44d7943d866507b9624134312b6cb4c60bbe63256e8a827de32aee320810d52f3c962640fd49106f9f8eeacb3126ec7cb29a8aead715981087fdb216d1f5f6826c6a7dc7c73720b48c46c834585a054351f4343194d8503a028a7370343fc93800a36523aaca8bef60830d187a6e0cd1a923cd3fecd675475337ccbbebbe602408fa88b083fbc2210f9868fbcf7a8813cffea68a9cdcea68d557742f4d62bf796879ef0855ea2a53fcd4e20d028507ecea3feed4ef7078ac7b2794c32e9ee40f8eda1f72f9b32c822a3f6b10f661617e7312b829051c605246f812887b948d018368e66119492a3c62b04f8f483878c66f5557b5f042c1d7ac626de5f92ab4e76aedd5dbe9b909251686ebe3ab1ce2442b3f6750c12f50b8ffddacf53c4e6d43b1667a03ec2f15f6caa6ac206e9390d3de49dce24b6488c074a3f2dd894314a9c6d721c737137885ff61e741c74761a03edeb9034acc575e23847f6503d2525230f72a6098c09d4e26c43bcc479f9a8d551cbe2b8104118d76d6614dd3cf103aa43826dc2d34833da6f0c1ef6ececc4d0090ee604a2e30ef0cde125de7c97dfbf64c48b1a95a635c6f197d7bae432e15ac8a1cff8df9c0960a88fce1a54722437d5c9d2daae1c4b34496c8db84a64cc1e72c72725bfa169703eb4cabab3b588c3dc92f1179f43d852ed6808c4fa005d8ea3799ec959d7371252f2a182f38259bc0fa5e2c93230cf5b67a1a4977bd037b89631b4cab9d51bdae5f5f06be0696de86d5578575b0626538a3cda2079a4487ab48af8e5ab9dc5629985f1815d778060fe986df123b77c9e29b5c7329b1780a0c904ac2403e5130fefe92b443586e0be527930b3a5fcd43d1634ec55c09bb8d42607aba0f0abd3dad556ac42c35890fc2f6c2f11476154cecd50d1a865aadfae9d82d62f9c8876dbe1cb92d4f2ab6941ad9cd4f21a332501c1348dbd0f52f7bf77ee0c8508996bac39c89a1bcdc264fafc57a5d4c50b58b271456243e95b858755b66e4bdbad0b0b0d409ea91ca3fd7c68a860dde9ec5cda101ede63284d6a9174d777bf76f5ea11b1c67bd56cd17a974b4c506bc47762569dbc4e567362b332391f94822eba1f70602be3f68ca0d764682f07d6eaeef0bc1e895794564cd4c955b8172154eb48a2769031e0223ab306a7b2328a87a7067efc75af070a9faedc77a8e1a9b2099b972dfeb0d5cce592fb45153144b6b61ed3a04a7c26d50503d2864787554ec040f21182e0fd8f4ace6c3c48cf8d5b56a7ffd21d679f40affb6297006b1589ea717956c2cc6fd8d74433ecaa7d623dc2e992407a72c2230732d4383be817335ce1163a223e2f1f40a33244822a43d2485718f6a37004225a66c603c87f14c393c8c6d5b9564ab7e57ec261a7141b7e482c6c63b51bc8862278fa23248353b0db90d582420ebc1c858f4b46399e3ab6bd5badf046d7fd726cfddbfe7de092d11f728edab44f848d718f7a76fa41f031b78ee0a1ce6d49ece95caa5d7e2386e6d9b42346b750b019773ce3b788eb437fd37c9eaf63bcfb6f17f58ce5470f887ec68db70c58ebdf66dd7fa5dfd17fa178f74be1c0afd17d795c33ae859aaae60fc549d820041489be5dd8bdd573ffe3af1a4925396fc469999dce2053501012bdd4cdb9b4f62512b9b8d32a036804a2a4ecac0f654bf472b376a24ceaad25793fe3a07d28adc50ea62e646c1e27c685ea518dd6e0414afebc60ff3c4e2a178e2693321067f2807e68d23cc8199d4623dbb75b8f5eb67e0b282f3728c5e36167aa39e1ae228e6e7403773e9d2e60d106337d52e7b97e7a3ad111216f9ee2dab0c758f6970503c1ad8f8feb06c859f8e6d274e19637e0c8336b041f66a92507dfcb6218cd8c7ce716f6323cad5f2e67fccc7eb9bb954b14f75949e020838fcf9454fd1f4db1319916b3bf312975bd4b75f849bcaa90a9d340912f4605ec7f3697a706240067fb417b193f2c4970e281ed53ab0022c2b3594cd74ed6dc77d239b906e4c9024c669dbd45b41fdbab436e7834fe0f1a014fffc0f2a3c2570e5605afb910677069704144561f0f9c66369fcb8fdd24fe012238f2c955332d2956a1ccf75ab51f2942067e3187ae400828021d96509a3d2e5d3a4d42a2ad069d8523fd9129dbc8a83f084342c933271a61dee9bd0056550c70278ad40076ac1289d1e7ffe1e4ce47c298a45e06c3e9644afd8409589f506f219e20b2c3db2e49cde50fa266e6fe6727134c1fbccb10f1d90911618e767b2f104a0b0a497b3babc89bb96ae5e75d69efac023241b2c7c74d5d5b382d2b126a325e430ce4cce5ae7d926722ad675e8f1e6f0bfa0c6549018068cca127e69203dfc42d5dfe71455dbbdca4017a518ec93b3397ad930fee8abe1126e0a588d34cb6f7855402f0afa7a83bc5762bebe3792f4a58b0cc00548f9a15b14e90aa1d7eb12b963d8c8c11368e815826fddeb4ba1acf6283d8c8ccd64b21b3809f38f1c8352d8c60235a3efd84fc6606170c87127ca3ddfd4b23f92d736dc66b55b6457b3bb61446cbe31b78098ed06c0d04b328a5ae63c556846203577814c9cc6390a6d5a06341a8174b10f37f4a626f43801a20e2b8949d64c7f7b64fc5a091232c37ccdf09dc7c2fbd460aa3e389d5ae5c55884c3bd07d8fc8997134fe7c6eee67a7f5dca526fdc35ebf38ba7ac34ec933d06c848b46d87faff3ce3315df7707491d9603cf6b876075959dc30a1e0a93f41e39b796dc17a2fe1924cdee972c51a04e5ede221e7378658317d91d859db401d2c06c9cd104c93f649052bfc70b7148594ded42f7efbed76b4b8585a9683e0054b1827ddf1a1de9dc4950b7b41178900c8f005e7106e4d88f560235dfbbbeed0937aef3db951e1f38027d7b996d7eb238d8b26663c2b5425d1eb82099f8d9405aae559fa232dbf340bd1b8beef538293db87929657c65e52565266e8ac2798c4bb1679023f78a57238585f9485912e12179685d65b700ac82611beeccf0a5088d51935df1d19bf7176a88b5fdfcc7f5db1a45b23ac23d0c4174140f2d40bfa62cc55e0db725a4fc32f2bf7b5f3851cf2760cc788a06a04a51194bea049675b46224abf305fb2a3286a73f95692ac35056b03705330073c5062d891fe93e7f5bc28c30bfd3940f8da8abac8a2888d0a0926668aa3670df8b017ae83f0d9c893ca5a4d719d6f7df0a3eefe6b85bf4c3906ff5711bff1b9c7582bd2844f860996ff25af1238321821e61fdd7c3b537a8320f47c7375049a25dec61ae52ed9f1b43debc98db502eeb1d903b440877cf73812fc52d0e42478aebe63f4197d2ab028c8601de04d89d59cef52bf3ff091e899c884d2623b696b0ab7c64a26d4665164c35ed299775878d5b96e239c2f8273a04d9cab13a3560e9488135b04b1a467f2128797209ae16515f53b2f33b25177ef84897b9a08cffbd46418499626e8f265c8cfacc4413bb40dd00807e7921d036965c559d10ed72cc341522d82db3a1247f3013d1b9078282bff1cf0f6c3945ef30c01bfe4ca645491bb560a855935500100be9d6134cd62329f2a1f56785ca77aa7ff38ca4b4c7ccf427c8a2e710eddaaf7fc801c69f0e0de49ea819cb8d8650c376bdd59c64ca4effdc5f05a5b3b8409a1e8718a8117f86672e59793474d4236d1579dc024fe6cf38919e4f62b87ee93bcd1140e17b90f57568002332d9d326acc0dff6ed677d820a66e8c26f8ada4c8b2f84d53dd6939c4922d74fd8c8ed3e7de5b7661f5b2686772a4925a6e6d523fe0040d48f4e44e46959e21859ca50b924c08fa6f5f43c3d9a76665699928bf876108762521cfe58a2041501e916f5ddbe9f960b5fc1d9f033e70e61a1831a610660831d070db07e0d095273c667618eb6c66938d03646a89714a9c617085403abdd754f6ec04663cbc402f08de8845fde5dfbbc833a61db7f29bb2eb2771af7ab0d9646d3ab31b2da9bbffacbe690ebab3eb9441f7a1382c2fd7160c210f53b24dd85dfdfb7c31013bf9d10201ed3325f154ed9c2218cc10b4c01b2fba0b7b80e22f136af2da385154a8231bd363c57141f5a30b95fd7545e71039cfde54399102df71a7933a048bde67b9cfd1f524bf8929eebdab7fdc34a0ec10f8d4dcff70b22bb0fe5dabc21da7f7912ca941bcbf397055502072292d332b51dc3aade4f6bf1c0788aa4a21b7c6fa03a4168738e0da60a56021399e6041309c0b7e9891162c3ba17f0c067e38ecc663343fa3cff278b40043d06ddfc25d9877bfcffddb80575542866c1215216d2ed27641fd31bc8c4373c0fc6371c6796562f1874efb9d63e1eae2c07b62493c937be41f374a476ad59d293dbd6910b10286649a41b03ad9e9bdc8374bd8ca9988afaae60ae5985c436e22c5a3c9fe7bee1dd7af30d1b3464dd33fd6e97ffe9aa3244823ddb6954c523708076331ee15410e77600bcb8578b56568ac550bdfccec490247f828304e2ae41ec0c10b8123d54e4388ec40d7019e0f2d11ae0ecf38caa2358bfe4e7ff19519f71d8ae7b312089ee6391e4c85686fe9e36c30e2b2c2914a3955432a3a8f701af91aa9dcd26fb3c0f43c9183820ad5d2b9c67b1fb5eba1f21bb8d815a8296932eb72fdce6cb2df11acd2c91bf97841eb1eccb5ef09906604a29afc412e2115dd2ea7364a1f4fcfe0f8a6cb9ab03043adaa404cff8995c842068d7192e0f5d7457996af4860bc4fbac38c72ed73c6041f9438d2cb0171ba485da6b43b6901a1c04d84568a3df1415b64eb451b79d23865c137bc69f53b756611b5c132d3715ca42fb5a17db04a1501c5fa6861ab8e8721d7e11df509bd1f357b614d6418f0daa900df7e5c596f31a5b4f7e6105d7c0b59ad620dcdb4748bf1e8a89403309f831fffd7c6b97eb8d2f9a2b8adc55396471f1d580bc724001639c6e90cb0966b3e2e994f6c00c33109057b1d51b6079e0046e44ff8651512c83a66868590d74a6dd8c69552073169a74e7909c6a966bd9946d2a9f6e183c6659680879ca27c8a1e8647b56b6e9f25ba09aaa461b8bd1cf51ca2323fa8a381e98ef3182502037d26c29b872230552066fe9b8f9f5ffe8366e78ad702b3be86e01a6508228a2c7edf7649f03267ead063bf90615e9f3c7e2e13cc079e6dc5833054298bcc4be780e7b4553775b1eaf46939ba58911819fdff54f0325a70b21350209f3555264b9280633beb9b1963c78b6e68e5a43feb009a205e20fd95ffc32fd2dba4ade05ae66a6d816826f4b711eabea42c30afc4c482e850de68a925db01df71f77babb661c598486a47cd81292d2efec91ca4a91fa2bebc2598e966b4fd2930de7daa902754298ef85fa69e3e3e24087b4dc895ac6926b7ce8b79d55fba66ab7d7db2c921a9a98267310860617cd34f812d6147c096a7a60449af469886df3eedf3e1f4b014f92fbe3b245082581fe6a3af5dd6ef7a4658838602daa49ba555c91e22fcd3eb23207f9d693073021e128abd00ef9a7563fc51ff117fcc82f63dc1f3ba18c4a26ee1746b801580451981b4d5364c51be688f9b9711920a2c2e27820a63c2c8ad71094a097b7d83b681f72ff134c340070acfce7061b4b07736f230084e1518ec53bbade17126869b4e8f3e72dc344c79aac8b7615d5f214de57b9bb351ab6939bf65941704169fa0b7c1762101701241c7d48776c246883de4d0835b6998a25acc15ba698cbd6860729fe98bae7e03f56bc9d4ce79729132b6e9096efc17cffc2ce0fad4825adcc4e944b9d6943979cbc062e79f74f9e3863759e507384059c647daba82b69b1c834626638e6c73e9ccc1a6d5b3c80b77fd23d0a66d9af24bebcc68a863f51312645bd5fe0f3d1c9d7c7653ec9d8c810f2c84f0f6953b2cd48a16e31ffabe30c78432d0129a34d5cf3a7952d74b97f995b993bae81dad6b5ada8d2c219beb1df888cace365fdc0435a58417e8edcbec4b8fecefa35a2d770a23770365cb713f1bc57a2bfcfa615fa332e3538929911a1441b781050d67ec4a856809360e5d246a21e0524c9e8c350b2a7370104d6df07a5b660af15ebdf5b48118d9b249174a44c9082669edcb1fb321a124b9482ff8029c83a3154f34dacd7677243d16138db0294684311a803e435f874083eba8bddd2024d99208b1ba01929941131214c3d9c883b8b4a0c8c74b27daeb5966ca6417b76db2dad2ce7690a7dd090d00a102c5c9eb5d4a84eb0ecdfcda6d953351bd794a6ae384a298c5862d1f7d18e19060c70f883f913d45b1de5e128f9242677016d84efeaa17c1d38b0ef6f00a17ca0145126a1b5a9451b9810e3dacbeb6779bba3605c5fd2e91229dd38f560efde2108d12368d15f8f90016bc6b767f32fe29905ba0e2e648d92f636e7e3bd73db071939875b6f826e6b52b364b4e9a77427f38431b1dfee7d93eba6e930297960d70732dfb918c591ebeae847a73b5904d03ef556d0fb7c6fd4d0e8550bc123d90e71a49514d6c80d3e2429ae8e9be0e840da7fe35fe7cdbc76850b4969e64d00b65222c558014de19c0cc4a42e682c352f1743fe6f558e279e8cde48f197756ad16b51d4c154c1ad493c61e6902a28f30db916d03b9ccb816eaedc47055a4fe16069ed227e2f36658988247afc0daa63525adad776c50230c01a2b7898a5a2ea46edb2d8478e5ae511654c5edf9ffd5adbfef1c8a8b2ab5c972907748f0379b46ae797457a369d4674a831c624f23fc297d86c8eabf157de5970cadddb017ed0f56b9cad947b23ad1272c41945036c293a0863580a2fac85ff06e06bf344d57515a95f1d2a532dc9e3ff8245c8c838db8aea5474618eb67de40f548122adb5f9728b6c15b68dfcf74ce3f139dddb02653bd69b302996a0d7326188651cb49dc55df0f9f01d4dd58d43315c8573ef507a67ecdfe0ed557b1ee56c0c05be6b04ae21357d75836d8e36d211d952bf8f93a8582fa3f72361b25739e47211d1051fa3b03c8b48db3092e39dc00f331c9c6c93ead37dc0645130c44bd990c1ce95cb757daca3f316bebc0e7799321a90bb152c324a096ec12853ef44dabe4b579d1c303e0335247d5e0770109a17c5667025a84ffe8d8800b63d1f3e12a172c6b0a52af245afb1dc088a3ea48bb4130b09307ddecd76e24440dcd292ef9ff698996c181a38faf93df22aeeac22b83781e241b15fc52781b668cae017644dd2411672c78f36c95769c9ae89082e56ea5c684de7458707beb20a879ec074173e0ce47fe8c579dc0e29b38a90d20062c253c19c33ed1c9f9dc15b2f946405087152c7356cb9021ae54bb315043ac7899cd7fe0e2fd43176fe23c879958e1f0c676937e85f65978013f4a20baf65cdb358e93eacbb0a9f8cfc17c5b9a60fdb86c0f9d88b944c29f74313ef7de4f5c39060eb24cd45bb580784de162d1496f24692bc6a03a7fcc408b071d973845ecd4d4c5a2a70bb236d563c5ba55a4d4db5315b2097c002558bc57fd380a2148dc89540eec209638d774c5720fa82315beedb4a1f406f96abf6cd209b5d755e08a01a5e189abe5aec141fecb9d6701a453277baa52eaa94a2fb17602f6998926e86fb0ecec66f07a00d3f50423dbfb84abeac0c0a41255d43115e18db6ca8929fb2ceb0f2251da89f8e4cf2e8f0e01be9337542812b0048cc7c948339e5bfd90aa97283fe1e231f1c9496a9297c5bb111edf79aa16cb2918b37588646eb6bf46c4e9daa12d8f028515b0f3ecc2b11dfe8c4852d5ff4d8b604b06ccb69f1efc3fbc5adf75e50f4221b9c2c8e699d26f758ca46c8ad253b971410aa06609ca3f4c503affb366a1146518fd66cdf26c8cc535bdb7861fba083158ec9112bade1dbe4117a25e9142c3e4b6df13d010f4d1b27bf037035ba0318350c8eefd957cd53a8de48c566a77ffd5796a7104f98154ab9429739739744192db0ae0d264161f1c7ba8e8258085ee0e0de69ea010a4d73d2b1e98fc392b573be2c9da1e40fa2a63d2ad82b70c670a1c78128c78e9bfd603c9343f725fa8c98ea5f60e695e081055253523f6105c72a468a79c6b846e206045d5ff79a5c251d26fcbfc20f4ae8441bf18d8d854bb87b0f01b275d560e742876d84edeed05c385f266362ed17c346743099ab05f07459e066564bbb05faf6284288ed7e33096411f5126b941932be7449eaeffd0914efc9b5d354f5b11dc273cf64fa9e0744a3eae633d258583783bd15d37ae363850a5e12b7b190399334954ccdf4c086bd5f74268a41c16b70a69890350e7a864d56d3e789d6e00de4c5e86f25e22447d935caf5952fc7772c2ef164e74d86cd69e2aea2e7a4f8e7360266969472c0bdedb07ba74c3b7c18e6d7e782709aa9a033764fb138f3b7b08d353e5c7266166e4abc0ccb82d64b133276ef859ef1508850fec6478d9c669ec01bf5e4d8652ff7b482c43dc87ca8a17485a12f8a7983406092f001d323534f553feabc3303787f4c2d53436124364fc6d6c5235c718953f9ed75114dd11b66420cc3bc17737aebbacbf94bbca946166b3723b4a572405ac812f8b426d383fa332b612e580d0820edbccff1c42e41d004b9dbdb7d8f4e7cda8864191e4a8906d08fa8b0f5496c7af2930542b79e75611b8ef099895920338e0c8ad332472a326fccb4c6e66bb5eb42604dbf22b2c8184d1ac96e219bd93c97ec6e731e1e5e5406bb6b31e85e5a3335ca2d11206fecf31e66470f28768bd2b73b9245f53d2a973fb9292ef301b8dbca4cd804ec21d742e7f4aa79a12408b3346e8c3fe4457847df7ecaaecba27d8e1cd8b6f5993aa7400e3531600f8c642e8f03f02ee08f3a7da40ec2f17d45704c52daed4083672fd2cd692b6c41bff2705c01a769eacd5e043221776440af9c01c0aba4fbc7bbcf49683efbbbe029f16b329c8a545ff13912643cd2ecadad42f0cdc200f1d12c47f1a02729795029f724a8bd488841811c1c2deb10bf8eca4527a9a3661976c0f48d0af745837cfd8f2a560a95c3ced7d5b2f674aa9af3915e579b9febf7e767c7b12c2199f3afd78a4caad13fba7a9f01ef1ee79b072c4082bf01ac95d5e592ad90c8fe4e00b30ef4ab49c8af2a7efa078d3f46c37e6f41e807427bff874cf3058a5dff7d0c49d0fa34dab7b2a683daac530f7d5138f2a1fe8a71ce0ac4cba31244042279a28cc7260faedab9e05e537c3d2c913e419974b4c30e2212b44b85ab07498351fe938b6d6d471f70888491787dcf40034bcdd99b4fafaef03cb73a2c97d1e500445f69643578a0a3be5681230c4cc159a8a894b2be2f73fc2f09869f86ad78bb128482adb98d4ec481eb24a10ca297a96bbea3e8a164fc90df2f7989c77fe32aa71b9b750e3dbd20f4e1865e43b54687f7e855e9a130211b3e3f5617ca1bcb1078e198a5c9551966dd206cb519adf79fb60f5b1931d889bb3e9eb2835ce129bbb0f16c1e82b574cff24f498d3788e82734573dac0da6526b375771d42caf135e6a59a3875fb8a52bb4039861b4a4674830d1968e276874a8f4a5f858fd50cbcb2f177fc036485add361102b1fc7d0c5dcf93152beee711a5ad05787d264a169781e949772e2b543d38c4eb6052be2cb75523e461dbf84703c4730d96e996a243496fea1940b1719fe3251983db5a236a47e79957d0d3d9e0de8657b23ec89423e6a4841a28c2186ac39c9ebebb9819bb1c68ad02b0c45ea8d144078259c7fbfe9a19ffeb94b107ed751106cb5aa489203d6508ad6b9e1395b42c41aa5d4b0de6ff3ce1199305cdf1afdf9796ea5fa745eb011637c3d581a408079fd76297e78563c23538b440bdd330690e24576a75d21553b00d5306d9d45fa9dcace685d34328cb2d4082cad1e179125cfaf412cb96c712f337d8533111e5cc4eb0cd6e1ea09c4a8ca43242d8100b679ec72322091c5d2be12f14ffbeff0ffa396bc04d0f66c443bf41ceff3c0290ecaa1449606af472a9214a246440a41dd560b8d1b54055680851dd187b62ac459ae36098c4d1a2a8c1c9c80a3bcf95d86b3aebdacc31c54a1f21baf7c64c0a870d3d9a7c00f09dccea008e07f206308d610ca8332f301ab0fe5b69e71e3d8ed6acae9ded790258eca3becd951df61d17918ddf5e24282ff323e5b25f106adf38b5e2c8493a7c57ace7e2602a769955134ab8947fc22d5a08902710c594bce8b01b32bbbf67babc2f7678d53e987d057e8cb22548c5104f19cba5473a22462b7625a63142517a7be4e888ce4d3661d053e8f090d813306c8dff056950cb93cf945f41f88332c3b4c1e019f7343d0842b6a0d55d1b8e34681dfb51d4089fdbeb55eead4eff29e3379f9243bfa2ba7a5fbd63b5aa6773c2d574618d480407847a5cf8343e7eb874684d93f1b076b77e33633240a8d2c4f9200abb8787e99c9d77da77f5fe9061bc2977eb8c9ffc9d58c6c4cd0321fca7442ed5250d84eeafa4f190eff8c4edfa72508fbfc704d10542148a5f0c79a98c831531dfdead64316afb6ad2df32bfa50a47424540ab73e65054f06da33a75e84b98de8f953d2c0e289d9cc3fec8aaed88de8c84912d54dbeb6e6528f191112289b1a5c75c8dc36d4f811be8471354efb032f5881fdce04ac046245be5fdab918b71af4920eb706c24745fa2d3acfccdd3afbca3a75b4aa8900bdef774dff58f58675ce5a671a42d946c6194cdd1e2974860e84ffad1ba2c4755e1d63e0ed66334b820306ff4784e17d612098a10705eae73c300836704c364a309acd4b53980a31a82cb7046ce468840ad785a1f2280720e2a0fa7b47e2c5fdc72e9152f58d6b0ef692778427b42e7d57296f9348cdced1d6d71c0b2f2f1d5e9518a5e239cb712298a3c36a1f3368f01c2abaf2e7f0ae8d8ed23ce2f1e5539477bcbb2e44862e6c11cf552f07619d890b70755cd328211e01db31dbfe22d93c54b8887a3103d164e85bfe0a0e4e35307a61bfd5eb08b9e459b286d5753adf412b857c972f93edd739636ead1d31885bc95f3c45d2d84a9ac8dff80581edb1e57accfe864587706aa9a8841720e9e95bb830db06aa210a4b92fdde7f2d1e784928a8f647007e43d5ae1a06f75a526480160557203cc32463431024059dc7674588dcb335e134888590b35e5c0ced277849e5cdfdeb64488e85b99bc0be98cfaefa98161c2cea221c8515aee5d284eee285343d3615048e2d07587503a88d07aa46a0acbdc7d72b8cdaef807104d6c8d29beb64a08f9a0fa793fee65a9e882d04c43c659e02b180d3011fb7960ed2c324c42c3669bd64e9b613cb099d411c463af45c93e837f60f04d64026eeb43d90c145519f99a806e8b03a1f81132c4e6dc23692c0db683fb9fce68937e090d190525300bcf9f10b224bc56466793ec724dadf00f4913648e92e52802bc76bdb0cedf8d160ef9b8046717595605b1d8833369a986555d92b507f7ec622c1b0848ff5a124bce032004602b933ee56610d2c12aa80187ab51966679b71c6329a5d98601849bc26854c1315ac7edad2b0499d1e816472f2bb08cce5276e03a7037e505e302a0d1c3d73afe8053091d76ebc8da4a729a43a471f842bd853142fdeb6fe0f2c8b51f62b4bd1adf939ac519b80593eca3d2a98a0223a896d7d7f4639ad26b7f44b2d913dfc590096dd46586ed126bb1eb934cf0c4374c1df65be7dc4cdff37d8a5674b7831cd2c02f2781f2a3b8099d33fb9e1ad0269f32b125df114814d4b689ba046dcec1517121a67bf9224039dee7d8e82e2fb17df255ba4126447aa0f76a6479df0c314b8cbe9cb2ca1d822494b7d0185c62af4f423c34b194f57a5140b3b823f2d0b786c0c7cb27f3fae83ecec7d523996521a29f70fee69692def44bab311fbd25844d0a483a4ea4a02b6394766bbec7be1d7ccbc6e11130c147ed24df4eccaec1aa49dfe405d58746ce365c0f6b704a4162a5d70d73063ddfb037ba0acf46aac2cb643f9c8f23a7894eb53709429ce2c80f4653840f521dfc8baedda976e48d07efb01e8aecf1e4feaa87024efc6ecb19d1cb534fb7621c5d82895a4b4c7bd44006dd1f05d333c500aa204342a95bc3b35aa4137daa3199593fbfb055a40229491ea256dc7740edad4a0f4205e269d8f7f54d3ff020c33d61ba7a6c22f9dccc63b1422c45b6c483dc37e453c89aea1a4b9491e4e437fbfab7f0960d1128d8c853d0a1f8f698344cf8529d1a58a5d13e8039c1be972aee670a219ce075fe84e84a3b2709359be429f98b82af470fd2151cd73a1be468abf0e993db83841a1a3e3f6e7c6ae676fb0260991827e496ec63447eef627c886f57ca83ab8744a0fe330209ce3f084f2344dd78b96fe56283c2efd39b134660d0b4177df0874b45727edf5940a41393064aa16fe9f97b2c3e04c7c43c7622146378c3b371947e66b3afd4beb2cecc6be9ec9315e9ec010ce42d1002e91f8b347b8f8284a86f5aee341acf84d93ad8c7ea8ddf3316f38cf55dbd1d8864691ac82909ae73a6e441f043930ad98e5785c8f1343bcd4c7ebcf6bb78ab33d7c5b7837e13c1352139b2dee9388ddfadb07de06ca9078edf224743ae793d483608a9279c4dfeb4632118b04c02cb7ad29aec5f8276aa7dbe77ef2c292cd62122c16db56fc030e262645e1d5ae7c0de3090c18146c11d97e956035ef29a91b49a364c3138036f2aee5ae151a28887dca119af3946e17401fa6f29e65f879cfd4fc80152e78ba2209c02670ef4c47c2a1752f24b766c6e355f1aa4fd0bd1754d4a79862d32012bac3f2d54b363683cfa6d72430c7e0332ab6468ec678c5293cf82161e577e058d5f9b81e914718f2737e6e53fe0c7207c4dcff4bc875269462541e34df7ab68d02b75ddf119fbd47a4e4d9d94e59533ab2eb2e2d51b6e07ee0b83301c6f0bb8d0ed8d2e6498bb52a2b8a1d5fd260e1c2768ca093839653133e1ee9b40cd4593d07a3f4685d7b8725f5d970593ee3dd02075fb96daa8892c1ed7bace8e4490b39a9c2320fe9769f4019d92660f7e851d54645d6db2b43ad2e5793211ef83673ec9aee827f7e2dafe34df7625dba65e5a07163f933ef0aa44fe1336ceec8123b4e5afcc3ed480301d9c83f524ac39fe2f51370b64b47b3d993b64b33d768703967800e3e557ed9a3094437f1d2d4bd52fab2a6177a105c272bb9272d83a91e646f8bed2e3d22394c186c4b62abdd55f28c862f79b04788273a47e68297d872ac192c273e531a379482566bc1410cce47ea49c7925add5fe427ec18ce11a3e0dd8e25b97fc183878134d090e94badf6cf9df913b69d849a26ffb8ea1020732133ff880f3533a22f11fc2020e340bd2f93e29027aa7c9bf2780ef581fb685a34a3a8d51a599809d14952096db181eb90ffa93e0ac8986e39df792c88200a3b21b68202a1a9bce83d9b9d56f6b41c724797b4548b2f13fcef1bf07c862c662af9e3f80a8c1177922daeb2d033dda586534d12da88b80b2ee94838128e59339d74657a6b41905e79a81ac7f300c54233e889180d32a226ebe0a19887989efd0dde789c6df305b928505d989c51cb968a687d10ed6d85a562e4e8ccec2b858ae09f90302b0f426921403a7f1145da97f62f49694cc48b1f431de5dcafe867d5273f137c0004d4c87522bc31b2bfce0bc971ed41d4cebdd42e081917c8dc2e30a955b8280d2b70784fa09c2de9cbd88c637f5595d60e095d423dc69f1181dbba32c1cc5b57b3ba44b5ebcc360e5d4d92cb09541b2abfe12522f87454337a40f91e01a5ce61d6e9bf45ae14fb80ec3a1fa4b7131b1461a45b3be47c1a3e93b9d2110ba56ab1524bbf74ea17a6353f86f6e6addd88869e8b2556f2e913681b0160ed68f42b41c60121da86db93227c48a24d0229f57b29bd88af967b125cbb40054a8bc07b9d5b107ac46b8642fe60b8957bdfaad53c6384759228db74bf7666acb7beace197b92df88eb327458f56963e576c71bbfcf1a19c2e11f08aa63de8c357b4e8bab27814447f8dcdafd42c32029996e168e3ad3da958c389d7381188ed641e78371413f36dca0e511938b9fd949634cbccee322fb46d9c26cd9dae87a3ce7c82a3a2d578715e26556adf147e6311771833a3ddcc4dcabc5d207122680fb6fb1c3d2d9ead18464e5c5561b20ea3a422d6b3cdb846b5b14f9e090c386e7766d8e579277ce0dfede0e7f533a62c6a409f50c0d5d839728e82546d80dd814e2c643d051c5c5bc34201f80f65999bf3244238ed421489e3a501e4b35a3b8019212744a24b17135e248e6e827154d2d5077c1342c33fade8e6f2fb919ee38222ae844678f6e645413eec5e1a536754bca87293a0578a6f92378866d8135eb9abcfda0be7f23365cffa162e0873d71ebf1c00c5409d4a658d43e03528573b7f74ec550636456852abff9e2be1ae4e49794aef43ab6eddc6dd1f68a5ffc2ce2b97c61d0e2864a04b65b2854ea9b3be7bf04815e9b06ea9e045b5b16dd57a8e7b2476123eb5396d4fb7cee3a2c9c10dddbfc8881bbeeddea2f7ddcbd2bd0b1980a8f1521de6303622bc3ec4040dfd03c9a930ea18bd558a0fd04b7cb19efa37f9a270268467416269cc6f8ec328b07c4a5cb7afd278718a75191a72238737bd22ca6bb3a3350615bc6ec36ea582493ef45aab67830697fba36e6a4941e811074fa0b7870c7e3d4a7743465f9e8422cfb06abadc4a1816174bfa1bcf9f197d8696baeeba8616a40d126786c271c76669338a9737adf4669b0dab5a1f24dec0fc7028bd343fc64706247574488d523486a2c7fcaa06043631bc62f5b1908960136b90af4a9494d50915963b207a2372c6e0f4ccec42caec7c9ef6985e7f8c554ed4caa705f542f46e3c7103ab5390e1a5bcca9d42215279182b63af9ddd7ef2eb111370c8618bb3a2cfe3097ee7f8c6f577e6098b1274a2f03148c73b86503013806ca21427451a03a833c5dd5bad740ddbd4d6a619ef3b36aa6fa1320d1b9afd4969927b40b2b29d013a9b741df5a5518b932f49db1f006677f9090c23116a8f60b4b11647a34438062ed3d5a39daa6889c35a7c4316e08b8d381e91dfd1c24df8b20a4b05f549a1bd36b0373714a813254b223256d92f531c421a10fa7256d154bebfcafda0bade19a2e8765be5ba014d6dab87155fee480f7dbf532b5ed7ef91ae23a1dd66e0c261f7bd08ed3ade2fddb2a18b1c4ea5cb0ab27eeb569dbe40cec68f983004934c388e847b2af70db0dfe7b5e2de9d4a57970def04a74084a179b0c82498044ec8e1ef289f69d8f3af6e550f43bcfa2c9b0da2b6e5312121643ce3c304435aaa5f68db9dd3ba43e4cfeac178ea58fed55078fc22121be84f2af7985e4f3f6adfed3b65cc929bc5b0d91759f18a31babf07e03036d2169af81c715cd451576f5c9a6a42ae1a13c9db99bb51cdbaf25a2dbf1f30dfb399acfe1722d91117968a827812fa867f5735e50a4ca1819f5e29ef41138b70bedad207b18b98add0f41852bfd4d1cd093d8c265cab7e544725d8ad82866f7487bfd51103acda9fa6662af0c6299595f05f0fcdfa9691e636766cdfdd800c595cff1796d32099c8e794ceeb10273c66c4635d8fc4680db11d5b18f5cb82654962b0480a74d7abc6ec88cff06829eb945cefcd76ef54ceee0e87f070589</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ+Mqtt enable publisher/subscriber</title>
    <url>/2019/08/17/20190817-tec/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="d85aa3aae42597e805bd45878b2a7e80159d66db6b911f26a4eb42d6d3f7d80e">4d94d3e2ea964a9497276ed6e2e3b252f7448996904b2d22e4065ed40f4d7e9820f3762c45d6cbdf9bdce19c3334dec7958c66ab6f6a69930450e914b93ff12edc2be17e8f1bb535973f5b066adf452a76c30c784439363132764048afb28ef071d1aea1fd8f14e531bf0f3f141e1879a531c7a0bea2853919e7231bb2b0ae74f2a098277e751b84bfe736441a1cb11e2cad3834eb72801e07b5696e1b9abc69558b6712ed198f23fac03261424c99b33402df58313eef0a60774fd862318611c5965fafbff2320f7d38df21e1394462d2b544bee82928536f7ab01344927d27541734b587c02aeddce32b1992570d47f2226f0210badd04e620a5e349177f70f5fb1c26bf3015b5b0e4af6a9c124c174865b746ddb91fddca2f50d72b3d79d9a6c4c40ec67cf8920c206252818dc1499674b10d2cc7d335d86d332a7822860040fa74bce9eff7dca946cfb91f6e6d96fe7c5eaaf53886852419a5728b7ca1916907de637254211f88f096d8d9cd6bc2bbf6b75b0c2afe3ccef62eeb2b2a43636716dc611abf430705185bfcb740be6093feeaeb548a0d616bb940a9f02b519b18106659f162a0eacb5d5fefe00ab9aa4d96b5bb22d1d4e5e5a7bf00d4b03ce0ee6ab66f4de3199e9ed49166e76b838e17f36472d12c0898b7dd8b8745f42b22b229548705e283c50e2fd54849fb231f0403eba39a73c78a07323d73707e0320e2a8f3292c9530832d534abf2529b2b51ec7a52b7082a52594d142e537682296af7bc48e0720071fd67342a1d7e9f6939ee4a49b6276fb89388907b96801d4b5baba130b264997f13f8c1a08000ed962df27972df2110ed43f2bd00f463d3d4991474fa6cd51314b483fc325a34104ee4405cb119f30594a0b67f89bdef1f8f80280922fb65a75c41f1ef1dbe40579d7f1caf00e08a135bbc264b2a7e0067d70a1bd52445c83bedfc7f8924c8296adf48f28d878d45a4cd2490c33dc074d21c3ef9525a6cd436c8494cbc55666aa8b6226812b66ac6050e7a645729bc02c6669df8748f5ca7f46e1682df7fd667d802e1c612448a58ea189d86280aa4dea982caea5bb02bcb23df90bc5e812ece8472574949971b260c6a11818ea646e6329845dc801f19b60c8c7552e5030fcffbdbf8e24af818a03009f088e34f55f1ce2abe58bb356fca32e2d6a1db01866f5b4b3e8c720549d928535ef9e5ab1e5f5f346cf50e14d2351d5937692e42249e55aa35dd50df6f3d7741e46e4d399e118cda3575be104dd188e26075da22c9b9e0f76900df46709a7ad518f980ff143c0f53f5d9e0668e58239cf23b46c6627135b4cd8857fdcb1cfb72079b6bfae19e58644cdbad5dbb7f9e8fa860deafe94fe639b210e57cd2bae788e440fd215b612a09aca0f3310d0dec31fc1763a3f275de77d51dca81f2ca191dd29db9ece27d4109c6ed6135a1166a6b94dbb180b121ea93c278b094f60a76109dfbcd40b186ca9917977fe06b924ef9e42c95a75ba719ba9f0685512c44a6041fdbcb4eaa3febeb78b76a5eb7a7b8dd9a27cbdbee5c6506bc5b9511ecff73c58479d4426fa549eb26852bb049cf7e7b85990d88f4795169d9c1efdad75a37dcd5a59aea5890ebcd5b7b80bb9d10576e29d2898c4fb58f9d649f948cf412d2e8523a450aed798992a1551b9710282317e5a835806bb4617c2c246c4588672df0e5877cd2ddc99594abec9704246b23cf2f67faaea7578d8dae758153b75132c8581cacbc075575f6e2595deafcf11eeda2d29835ca7fdeccd9507b39d30adda70c7a552d0fa9102c422103e7cc7452b0bbe23681b1c3d8311273945fa174288146b6b5e9a00d4a959b2414157328f9a5182008cffb83a823fae164eac9f33f202c3f324f1bed120583703aa9c49759c9498387f6792256449c4cf4b68b59532d448d39bca9c5d735d48e9afe7651990c3ca3bcab5bdcd8234971c00c3730b81831e43cc3200200f0c82b9bc65fe4626f2ee924d400ccfda916b6f237e6a0015f84f33d16ff8838605be22039ea1a6c0a16e1945d9336d3391ea94099f840001e842c25251072c6eef6058589a1a015fc2774096ddd51b0193bf2ec80137f1c856184b14c74e2de89528eb64a62bfd9c9c007193de2a13ff5db4e9588484d075806136ee9382c8339aba6050733127bc9bf049ea869c557c0e946b74fe91e0e5f603d2020b0d714875fb7e9f435d0bd874402b40ac274024fb26eb7eb22449079154b486bb7fc3f53d7ad0d51e3faf049142bc7d521d0d6720e1ca42378b2ac2b351d1ac2072aa840a8c78352423ef6aeda5af8e9f2d28ffcc6d394a1a2512cec52d301b7b96d170373328c0997de2f1fd2d33781a9e35f8dd761fbca1a804dcee162cc671f8899d445b5512f09b67ef07705cc10508ef36e18265f82a535d4d0c42d53f941547d41d08da746679d511ea0db5b77182f89e5ed8c0bf55b9ae54cf1af4fff30fc62fbb9aa49689d28544084baf067d661651055a401cab3ffcc9124a67f7f42a41e34b8b871727c87f6439b5c0721aeeb6ae5cad6ffc63487f7902151787969d8f4e327336d8c96ff8268b43ec71fca54ed7b90e5b99da9b8b58a109d1b3bef4814c3fc563ecf172721c43d5f8991fa28203e8b0e3d79a9f8598da221490d170bc58d7c8eeba73fa55052c4b96189388f83ac490c1d0452ddbe7fd8074a4c18aa96062f37d9cb1fd0ee551503b6f9bed9e96f3ead2b14672c3aebd4b3cbeada478cc73c7c1fc02e360b1f249bb0917f543a015c96b2551010df5ffc21429578cac0756a263797af97f105a603d139b568307fd5bc7a9e5eef5d85b2dd408096f888445d8addd4f8a19b181684b1e09b2e51a5ef6defd94a0e7a760594695c1a7856a45fa7e0a483cadb1a24b1718b021eb152c2b4c0476572ff3b6a956b400aed984a92e92e12697fa030547ac83e55b935ff3d3b6165af58baa113167ffa1fa056e01a981d77d09374490bed8a3818eab69733262907e69e42c97b4ceb2b97ccb083aee5dd6451a096c1c222c2d1c7b8dc26b00329e98b980fc77e67d5a1dcd2774ea1350248af0e1fb9c5b6115b6fff759446caaffbb320e628cc6746fe2e01270caa08def290ccab68e985b83dd2b6cb237dc82b460bbdea40a56e57f3ab57a68b423097912077e950b6ff7e7aa9f78686da55c5c1d35d713fc19fc1e2f661d80f8679a9b0fcf81d2f9fc98e35982f671776f8f4b28fdca246332f360c29865651bc884b23b6971bc76beeaf393c31ce29c4618926385985a7b3313bc207b84fb307203f5ca89c90a2ce41620851bb353767e07b18404a59952cc3e23d140419627e767285696bce7af3d58532c41819ba41946fc78eba3ace2dc91dd4bb9613d4afcff6ad537ecfb275ca49af5bb858df3bb41ef089ed828a752db6e1c02222cb8a0aa2f68e7303443437ebadc6f2372e699c485fe3cd14b145cf90cc8e2f1ee1a08989ca8e0becbbcee58b4fb61466f39da1400e8316e7bfcd1c68857353d980b5d22d93fd001de733e62c31130d252c1e338c9c66474c8bb312d555752254d9e37faf5bb729f56f5e54212d9ec9e6e0723f35af4ead510ebb5d8e29203692285bc97d6cab01a3b6ac7683abd708c26ff2a64b071175486d71248c8260e2699c58b4512e3b45e17b6811e0dcbf54c77688185beb50ca2bf486c3fdf19da5b433162e4ce09c257a973c564ef2545efe04235471ee10f13274f04fc3c200eb1dd45dda649800dde34a064e08a42b05a501beb6d9720535a4c4d48086958c0620047ceefd386635610a19243ef83827d593fed3e92322765a1764c4ba86c3ab651eae2ef30cb2c9bab80fc1650881d1aa2903be9e1a6ab7e22ed42a0cb0d7fd7e430c406b745d76fefaaa016c30711e007d0e3a9eed3ab7c471bb58a1b6e4b9183373f80a82d7fde23358a5c3ee459feae6c006404e5d7c99be706ee522872862fe7242fd6cf934bdfd56e89ec851754c1996c4efbd775e9d31ea4dc6c2d451b5297c2c614ff1b8c23823c711e2be00e5950cc6c22694d3e8ae160cf2da09e4d64cbf0b40d7daa7248a9a534c9760b08ebc60561d0905d1419c448acda604532ac5d8069a8777f12857a65a9695ffaa6e4dd4f4cd8839b253534f7843c73ad332bc3b3dfcba1b54210f7934ffe3ed613a356001c2d16f7df16a04141c7718ce110fcb2f45786803dc17ed6fb67b8bddf083ec8c16c11ee2b65e4fe50598bbe49a5dd5babe09fc67c64203bc2e98dbb4c2d3cabe860c11ccece81a35ebf081c931a9e75e115fd52e9e14428b9c802387231c7c33e00e05c71e6572d4a25595845c254ca7d9e67ce020035bd5512b6304293f171ec98875f6a55a97871bd71a9e8bf781f0d87425d47af36498076554c4fa339851bc64971cd2a30d886efedad7f439be0aa79ad82e5d3b12a72e94cca77654dab128967899909e9edd25d3e4e3f11b041a5a1dfac65837c07ed07a76e2ce39c6bd7d9dd0021afd71c7f163e3b417cbac25ff548d957becce1e5a0e9361bee32ad242d3a5ee685290b90af81caa718867c886750b9fda69013ef07b950ecf6ca327ad8fe7cabdcd911eb2d8960d18299ca01be0420171f9f74fe8beecd18a69846c816a716ef5bb1b1544cf4ddb0de63b5282b4f053e637679a32fb9212800648561a7784113e43c6b75f288cec966180b4a4ca1ab6d9f091b80b176dc314beab05971b099271812cb5e6f1a66a915b8403fd9183e30302b22f2524b0e8c7d45fc475e56b00c72ae30d0359cbfdd25c712944b8e56a7b2d08a57221e640fac9c2f963ed4bd06c9b96129321308fb345a9dc2847afc575d4ca51bdea6289bb46d7b621e2fe038d0fc37a9af53a10430186c0c64a0fe6a94eb3fec07d1f44451bed9b8f633982d3e2bf1ca9e85397d4b703ad8769661f977b3e5f0f075a0ffe60db57dd23c0277f1b14d1007224cab015612628986670b27efe9d4984ef793543f09501e7f6b8a940a376c9c61d8d65b067d3e3ab0aa0502e5bb2675c3dedd9b2e6a3ddd3174c84f2374b3ca6a0bb13626fabcad6f3422d932a2b7e22c6da7e930ac9c6863f0aa213f4df994396129c328d4eccf98736de866423e77c22f4b5e462b9ed2c6c054b00447cfd3a821ba384f7dc1418a54fac9b14b7a9a89f6f9e5b04ae65fada32feb44f50ad2d8318724ac7b02716f86bcd628224dcb693360a8a9eb8abe43df3fc522342185017a23535dc75df806dfb27a297e1ec1ed81833e3db8d70aaa54a319ee36ebbd3108d799db5a7e517f285f56683c41a1f93bc0ce3bb1ac37698d8950329187fa72036f8d8a962c359e2e99389dda5128384fdeff23eeef12f45171ca5292bb2ab33d474424289105801ef62102749499429ce0f3f7d26d73d72b5751b9b142046d04c2b035ce146f6c98bca200a6562089834d69130c703e4537b9dcdaf2422c96e4d97c205469d506c33403747c5831e825bd008bb331908c6e1297f0a0cee4062ab2918f18aa28209ee23badd798e1b3f517a535d0a7929f150ac61d73511f75c1d496ea5757431745b19ce404a8d1d8946bf15c152e3cc4ead5d5ed98f127e3a7bfd4dee3b514a890d03daf47b599a510f6a70205c2a27f20001da60f4333584b3d301032596b1019d17108bdc316bcae0cc4e9f04bcad10f85796082291deb0514dc641694556030737d3762d7d1b7c55727938c0acf3c92dc4a45d1c868fdef17e7e6ecb5bf8134950572fc64212eac08f4e3064a5512a97762fc1163b1955f6b83fd2273aaf06c8d5e8ca5548df9b71c1e2b3a616ea5a67e0ac4a7e925664f37d2d2</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 teaching experience</title>
    <url>/2019/08/30/20190830/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于这周回了一条天国的微信消息被老师派遣去干苦力教一名高中生python3编程，并且自己的python3也就是个半吊子于是乎一周都沉浸在现学现卖赶制第二天ppt的劳累生活之中，算是尝试了一把新人老师的心酸生活。</p>
<p>但是，另一个角度来说我也又过了一遍python3的基础语法，可以说收获还是有的。由于本科是c语言作为第一门编程语言学习语法，所以母语思维就是静态语言类型，后来学c++，java可以说由于同是静态语言差别并不大。而python是在大三的时候企业工程实践老师在介绍Jquery和Flask时提到让我们学，当时也没有系统的教我们，只是在用到的部分就去查这样的填补式学习，而这一周算是让我补上了以前缺失的基础部分知识。</p>
<h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>自己用的macos所以有自带python2.7，但是教学需要还是重新下载覆盖了python3.7，使用的是python3.7版本的anaconda，记得以前本科时使用opencv2踩过坑，当时傻白甜的下载了官网python并自己导入包，老师就说过可以用anaconda。如今才知道anaconda是个python开源版本&amp;包管理工具，如果可以回到从前我一定拍死自己&#x3D; &#x3D;。</p>
<p>下载anaconda就意味着python3.7和一些IDE都已经下载好了，配置一下环境变量即可覆盖2.7并使用，python环境变量配置比较简单就略过吧。值得一题的是Jupyter notebook这个IDE，作为新手的IDE来说确实不错，不需要适应新的客户端，网页端就可以用，基础功能也比较全面，非常时候新手学习使用。而且anaconda自带，也不需要另外下了。</p>
<h3 id="动态语言python的优势"><a href="#动态语言python的优势" class="headerlink" title="动态语言python的优势"></a>动态语言python的优势</h3><p>作为我接触的第一个动态编程语言，python给我的第一感觉是不可思议的，相比之下java就显得严格且死板。</p>
<p>首先接触到的区别在于python对于基础类型的自动转换，使得我们不需要通过基础类型关键字去创建变量，并且可以批量赋值十分灵活。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">===python3</span><br><span class="line">x, y=1, 1.2</span><br><span class="line">x, y=<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span></span><br><span class="line"></span><br><span class="line">===java</span><br><span class="line">int x=1;</span><br><span class="line"><span class="built_in">float</span> y=1.2</span><br><span class="line">char z=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">String x=<span class="string">&quot;1.2&quot;</span></span><br><span class="line">//......wdnmd</span><br></pre></td></tr></table></figure>
<p>其次python灵活丰富的方法以及运算符重载使得可操作性极其强大，你不仅可以用+号去拼接字符串，还可以去拼接list，set等，用-号去操作set等。而这些高级数据结构的重载在java中是没有的，你只能手动去实现。。。</p>
<h3 id="python与java"><a href="#python与java" class="headerlink" title="python与java"></a>python与java</h3><p>在看了一周python的基础语法后我发现作为一门OOP语言python与java其实在基础语法方面基本是一致的，只是形式不同，python使用冒号：以及严格的缩进区分方法体，类内容等，同时加不加分号；作为结束都是不影响的。而java使用大括号{}区分方法体和类的内部，并且严格的要求在变量定义和创建参数列表时使用基础类型关键字，并且每一条语句需要分号；结束。</p>
<p>当然除了格式的不同，它们在基础语法的部分也是有一定差别的<br>第一、python中没有char类型的概念，全部使用string类型，也没有数组int[]的概念全部使用list。可以说更加简洁方便</p>
<p>第二、python中没有java中的这种常用for循环用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取而代之的是配合range的for循环，两者功能一致，而且都非常好用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nums):</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>第三、python的类变量区分为class variables 和 instance variables。而java中与之对应的是static关键字修饰的静态成员变量以及普通成员变量。两种语言的变量相互对应起来功能类似，但是又有细微的区别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">===python</span><br><span class="line">class Shark():</span><br><span class="line">    \# class variable</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&quot;fish&quot;</span></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        \# instance variable</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s1=Shark(<span class="string">&quot;Lucy&quot;</span>)</span><br><span class="line">s2=Shark(<span class="string">&quot;Lily&quot;</span>)</span><br><span class="line">s1.type=<span class="string">&quot;food&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果我执行以上的语句，如果是java的静态成员变量，那么s2的type属性会同步成”food”，但是在python中不会，python会认为s1并没有权限修改class variable因此在执行修改时将s1的type属性降级成instance variable从而成为s1专属的成员变量，而不会影响其他Shark对象的type属性。<br>简单说来python拒绝类对象对类变量执行重新赋值“&#x3D;”的操作，会导致变量类型的转换（我理解为权限的降级），但是以下的修改语句是被允许的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Shark():</span><br><span class="line">    num=[1,2,3]</span><br><span class="line"></span><br><span class="line">s1=Shark()</span><br><span class="line">s2=Shark()</span><br><span class="line">s1.num.append(4)</span><br></pre></td></tr></table></figure>
<p>可以理解为类对象可以修改但不能重新赋值类变量，这种行为比较奇特也是java中没有的，我暂时还不知道为什么python会有这样的特性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一周时间都贡献给了python，既没有新技术栈的学习，也没有踩坑解惑的经历，只是回顾了以前的知识并补ß上一些空白，最初的两天我是很不爽的，我觉得这完全是浪费时间，然而现在我觉得这还是有意义的，而且是我以前很少做的事，知识在回顾的时候可能学到更多，而且可以加深自己以前的理解。总的来说这一周不亏。马上后天研究生开学了，期待一个新的生活吧。</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>Diameter of Binary Tree lc543</title>
    <url>/2019/09/07/20190907-lc543/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>Example:<br>Given a binary tree </p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre>
<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">https://leetcode-cn.com/problems/diameter-of-binary-tree</a></p>
<h3 id="python3–递归"><a href="#python3–递归" class="headerlink" title="python3–递归"></a>python3–递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">= Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line">= class TreeNode:</span><br><span class="line">=     def __init__(self, x):</span><br><span class="line">=         self.val = x</span><br><span class="line">=         self.left = None</span><br><span class="line">=         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    res = 0</span><br><span class="line">    </span><br><span class="line">    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:</span><br><span class="line">        <span class="keyword">if</span> root == None:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        self.depth(root)</span><br><span class="line">        <span class="built_in">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    def depth(self, root: TreeNode):</span><br><span class="line">        <span class="keyword">if</span> root == None:</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        l = self.depth(root.left)</span><br><span class="line">        r = self.depth(root.right)</span><br><span class="line">        <span class="keyword">if</span> l + r &gt; self.res:</span><br><span class="line">            self.res = l + r</span><br><span class="line">        <span class="built_in">return</span> max(l, r) + 1</span><br></pre></td></tr></table></figure>

<h3 id="java–递归"><a href="#java–递归" class="headerlink" title="java–递归"></a>java–递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    public int diameterOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int depth(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        int r = depth(root.right);</span><br><span class="line">        int l = depth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(r + l &gt; res)</span><br><span class="line">            res = r + l;</span><br><span class="line">        <span class="built_in">return</span> Math.max(r, l)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道leetcode简单难度的题，思路比较明确那就是利用递归的思想每次对于一个节点都要获取它的左右子树的最大深度然后暂存这两个值的和，并且每次返回的是两者中的较大的值供上层递归使用，这题比较奇特的地方在于它虽然利用递归但是并不能靠递归的返回值累加来获得最终的结果，需要创建一个全局变量并且在整个递归的过程中维护这个全局变量的值，它才是我们最终的res，所以我抱着传统的递归思路去做这个题的时候总感觉思路很清晰却总有点问题，最后看了评论区大佬的思路才恍然大悟，所以说思路不能固化，即使是递归也有不同的用法。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Tree Level Order Traversal-lc102</title>
    <url>/2019/09/08/20190908-lc102/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a></p>
<h3 id="java–BFS"><a href="#java–BFS" class="headerlink" title="java–BFS"></a>java–BFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(root == null)</span><br><span class="line">            <span class="built_in">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=new LinkedList();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            int len = queue.size();</span><br><span class="line">            List&lt;Integer&gt; temp = new ArrayList();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                temp.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left!=null)</span><br><span class="line">                    queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right!=null)</span><br><span class="line">                    queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3–BFS"><a href="#python3–BFS" class="headerlink" title="python3–BFS"></a>python3–BFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">= Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line">= class TreeNode:</span><br><span class="line">=     def __init__(self, x):</span><br><span class="line">=         self.val = x</span><br><span class="line">=         self.left = None</span><br><span class="line">=         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        <span class="keyword">if</span> not root: <span class="built_in">return</span> []</span><br><span class="line">        </span><br><span class="line">        result=[]</span><br><span class="line">        queue=collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        </span><br><span class="line">        \#visited=<span class="built_in">set</span>(root) 在二叉树的层序遍历中可省，但是在图中这句是必须的，否则会访问重复的节点</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size=len(queue)</span><br><span class="line">            cur_level=[]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                cur_level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            result.append(cur_level)</span><br><span class="line">        <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="python3–DFS"><a href="#python3–DFS" class="headerlink" title="python3–DFS"></a>python3–DFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        <span class="keyword">if</span> not root: <span class="built_in">return</span> []</span><br><span class="line">        self.result = []</span><br><span class="line">        self._dfs(root,0)</span><br><span class="line">        <span class="built_in">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    def _dfs(self, root: TreeNode, level):</span><br><span class="line">        <span class="keyword">if</span> not root: </span><br><span class="line">            <span class="built_in">return</span> </span><br><span class="line">        <span class="keyword">if</span> len(self.result)&lt;level+1:</span><br><span class="line">            self.result.append([])</span><br><span class="line">        self.result[level].append(root.val)</span><br><span class="line">        self._dfs(root.left,level+1)</span><br><span class="line">        self._dfs(root.right,level+1)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非常经典的题，以至于在数据结构这门专业课中都有专门介绍的经典算法，但是即使在已经学习过思想的情况下，写起来依旧有很多值得注意的点。经典的solution是我们的BFS，也顺应我们的通常思维，通过一个队列来一层一层的存储树中的节点，每次内层循环都是每层的长度，值得注意的是图的层序遍历也可以这么做，不过需要多加一个visited的set用于判断是否重复（这是树中没有的操作因为树不会有循环结构）</p>
<p>另一方面，发现了DFS的做法，说实话DFS非常的反正常思维，但是确实可行，而且利用递归代码还显得更为简洁，我参考视频中大牛的思路写了python3的版本，将java版本留下以后复习再写。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>House Robber lc198</title>
    <url>/2019/09/08/20190908-lc198/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).<br>             Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.<br>Example 2:</p>
<p>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).<br>             Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a></p>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rob(self, nums: List[int]) -&gt; int:</span><br><span class="line">        pre = 0</span><br><span class="line">        cur = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            cur, pre = max(pre+i,cur),cur</span><br><span class="line">        <span class="built_in">return</span> cur</span><br></pre></td></tr></table></figure>

<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        int preMax = 0;</span><br><span class="line">        int curMax = 0;</span><br><span class="line">        <span class="keyword">for</span>(int i:nums)&#123;</span><br><span class="line">            int temp = curMax;</span><br><span class="line">            curMax = Math.max(preMax+i,curMax);</span><br><span class="line">            preMax = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人感觉又是一道扮猪吃老虎的lc简单题，看到easy的标签让人觉得可以通过循环遍历来处理解决它，但其实通常的循环遍历并不能解决这个题，它其实是个典型的动态规划思想的题，通过从数组长度1开始拓展，每次规划取最优解。没错这种不使用递归的简单动态规划似乎又可以被想成一种数学归纳的方法。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>找到字符串中所有字母异位词-lc438</title>
    <url>/2019/09/11/20190911-lc438/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p>
<p>输入:<br>s: “cbaebabacd” p: “abc”</p>
<p>输出:<br>[0, 6]</p>
<p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p>
<p>输入:<br>s: “abab” p: “ab”</p>
<p>输出:<br>[0, 1, 2]</p>
<p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string</a></p>
<h3 id="java–滑动窗口"><a href="#java–滑动窗口" class="headerlink" title="java–滑动窗口"></a>java–滑动窗口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; res=new ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(s.length()==0||s.length()&lt;p.length())</span><br><span class="line">            <span class="built_in">return</span> res;</span><br><span class="line">        </span><br><span class="line">        int[] pnum=new int[26];</span><br><span class="line">        int[] snum=new int[26];</span><br><span class="line">        <span class="keyword">for</span>(char c:p.toCharArray())</span><br><span class="line">            pnum[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;p.length()-1; i++)</span><br><span class="line">            snum[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(int i=p.length()-1; i&lt;s.length(); i++)&#123;</span><br><span class="line">            snum[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(pnum, snum))</span><br><span class="line">                res.add(i-p.length()+1);</span><br><span class="line">            snum[s.charAt(i-p.length()+1)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3–滑动窗口"><a href="#python3–滑动窗口" class="headerlink" title="python3–滑动窗口"></a>python3–滑动窗口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findAnagrams(self, s: str, p: str) -&gt; List[int]:</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; len(p):</span><br><span class="line">    		<span class="built_in">return</span> []</span><br><span class="line">    	Num = []</span><br><span class="line">    	n = len(p)</span><br><span class="line">    	A = [0] * 26</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    		A[ord(p[i]) - ord(<span class="string">&#x27;a&#x27;</span>)] += 1</span><br><span class="line">    		A[ord(s[i]) - ord(<span class="string">&#x27;a&#x27;</span>)] -= 1</span><br><span class="line">    	<span class="keyword">if</span> A == [0] * 26:</span><br><span class="line">    		Num.append(0)</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(s)):</span><br><span class="line">    		A[ord(s[i]) - ord(<span class="string">&#x27;a&#x27;</span>)] -= 1</span><br><span class="line">    		A[ord(s[i - n]) - ord(<span class="string">&#x27;a&#x27;</span>)] += 1</span><br><span class="line">    		<span class="keyword">if</span> A == [0] * 26:</span><br><span class="line">    			Num.append(i + 1 - n)</span><br><span class="line">    	<span class="built_in">return</span> Num</span><br></pre></td></tr></table></figure>
<p>ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。实例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;ord(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">97</span><br><span class="line">&gt;&gt;&gt; ord(<span class="string">&#x27;€&#x27;</span>)</span><br><span class="line">8364</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>又是一道扮猪吃老虎的简单题，如果对于滑动窗口的使用不够熟练，那么这个题是有些难度的，我在空闲时间想刷一下简单题一下子就卡住了，花了些时间搞懂了滑动窗口逻辑处理的方式就很简单了。这题主要在于在窗口的移动中要维护好窗口，并且每次移动窗口都进行判断是否配对。python3和java是两种做法，但是都是基于的滑动窗口的维护，刚好可以帮助我们更好的多角度的掌握滑动窗口的使用。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>子集-lc78</title>
    <url>/2019/09/16/20190916-lc78/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<p>输入: nums &#x3D; [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets">https://leetcode-cn.com/problems/subsets</a></p>
<h3 id="java–迭代"><a href="#java–迭代" class="headerlink" title="java–迭代"></a>java–迭代</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();</span><br><span class="line">        res.add(new ArrayList());</span><br><span class="line">        <span class="keyword">for</span>(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            int count = res.size();//记录下当前res的长度，否则res空间跟着程序变化就会死循环</span><br><span class="line">            <span class="keyword">for</span>(int j = 0; j &lt; count; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; temp = new ArrayList(res.get(j));</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序思路是一开始创建一个[[]]，然后针对nums中的每个元素（以nums[0] &#x3D; 1为例）进行：<br>1、取出res中的每个子list–[]<br>2、加上nums[0] &#x3D; 1–[1]<br>3、将这个新list加入到res中–res &#x3D; [[],[1]]<br>4、以此类推遍历nums中的所有元素</p>
<h3 id="java–回溯"><a href="#java–回溯" class="headerlink" title="java–回溯"></a>java–回溯</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();</span><br><span class="line">        back(res, 0, nums, new ArrayList());</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void back(List&lt;List&lt;Integer&gt;&gt; res, int n, int[] nums, List&lt;Integer&gt; temp)&#123;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        <span class="keyword">for</span>(int i = n; i &lt; nums.length; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; t = new ArrayList(temp);//基础类型所以可以做到深拷贝</span><br><span class="line">            t.add(nums[i]);</span><br><span class="line">            back(res, i+1, nums, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3–迭代"><a href="#python3–迭代" class="headerlink" title="python3–迭代"></a>python3–迭代</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count = len(res)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(count):</span><br><span class="line">                res.append([i]+res[j])</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res = res + [[i] + num <span class="keyword">for</span> num <span class="keyword">in</span> res]</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道lc中等难度题，主要学习了回溯和迭代两种做法，其中回溯法只要想像出递归树那么就能解决，主要注意的是避免因为细节问题出现重复项或多余项；迭代法思路比较巧妙，每次都在前一次迭代的基础上添加一个新元素，直到nums遍历完成。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>比特位计数-lc338</title>
    <url>/2019/09/18/20190918-lc338/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p>示例 1:</p>
<p>输入: 2<br>输出: [0,1,1]<br>示例 2:</p>
<p>输入: 5<br>输出: [0,1,1,2,1,2]<br>进阶:</p>
<p>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/counting-bits">https://leetcode-cn.com/problems/counting-bits</a></p>
<h3 id="java-python3–位运算"><a href="#java-python3–位运算" class="headerlink" title="java python3–位运算&amp;"></a>java python3–位运算&amp;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] countBits(int num) &#123;</span><br><span class="line">        int[] res = new int[num+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;=num; i++)//要从1开始，第0位在数组初始化时default值为0满足要求</span><br><span class="line">            res[i] = res[i &amp; (i - 1)] + 1;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countBits(self, num: int) -&gt; List[int]:</span><br><span class="line">        res = [0]*(num+1)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1, num+1):</span><br><span class="line">            res[i] = res[i&amp;(i-1)] + 1</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
<p>这种做法运用了位运算符 a&amp;b————两个数a b都转换成二进制编码进行位比较，当且仅当两位同时为1则该位结果为1，否则为0。</p>
<p>技巧在于i &amp; (i-1)这个操作可以去掉i的二进制编码的最右边的一个1（被-1后的数二进制表现为最右边的1右移一位，而不影响其他1位），因此<br>（1）i &amp; (i-1)的结果十进制数的1的个数+1就是我们要的结果。<br>（2）i &amp; (i-1)由于最右边一位1被去掉了十进制数大小要比i小，所以已经被我们在前面计算过了并存储在了结果数组中。<br>（3）通过这种做法不断迭代计算后面的值即可。</p>
<h3 id="java-python3–位运算-1"><a href="#java-python3–位运算-1" class="headerlink" title="java python3–位运算&gt;&gt;"></a>java python3–位运算&gt;&gt;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] countBits(int num) &#123;</span><br><span class="line">        int[] res = new int[num+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;=num; i++)</span><br><span class="line">            res[i] = res[i&gt;&gt;1] + (i&amp;1);//注意括号一定要，&amp;和加减乘除的优先级是一样的</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countBits(self, num: int) -&gt; List[int]:</span><br><span class="line">        res = [0]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1, num+1):</span><br><span class="line">            res.append(res[i&gt;&gt;1] + (i&amp;1))</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
<p>这种做法运用了位运算符 a&gt;&gt;b————将十进制数a的二进制形式右移b位（最右边b位去掉），然后返回处理后的二进制数的十进制结果。</p>
<p>技巧在于 i&gt;&gt;1 这个操作可以去掉i的二进制编码的最右边一位（不管是0还是1），因此<br>（1）i&gt;&gt;1的结果（十进制）一定比i小，所以i&gt;&gt;1的1的个数的值已经被我们在前面计算过了并存储在了结果数组中。<br>（2）如果被去掉的最后一位是0，那么我们要的值就是res[i&gt;&gt;1]；<br>    如果是1，那么我们要的值就是res[i&gt;&gt;1]+1.<br>    综合一下就是res[i&gt;&gt;1]+(1&amp;i)不是吗<br>(3)通过这种做法不断迭代计算后面的值即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是lc中等难度的一道题，禁止使用java或是python中基本库包含的直接计数函数，考察的是对二进制以及位运算方面的知识，当然也可以将十进制数化成二进制以后再操作而不是用位运算，简单粗暴但是这样的话代码会复杂很多而且十分不优雅，所以还是要好好学习下如何用位运算来处理这样的题。在lc评论区学习一番之后总结了两种代码比较优雅时间复杂度也比较优秀的做法。</p>
<p>附上位运算的一些基础介绍，以后忘了可以回来看看（java,python3的位运算符用法相同）<br><img src="/images/20190918lc338/wys.png" alt="位运算符使用介绍"></p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-Bit</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树展开为链表-lc114</title>
    <url>/2019/09/23/20190923-lc114/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，原地将它展开为链表。</p>
<p>例如，给定二叉树</p>
<pre><code>1
</code></pre>
<p>   &#x2F; <br>  2   5<br> &#x2F; \   <br>3   4   6<br>将其展开为：</p>
<p>1<br> <br>  2<br>   <br>    3<br>     <br>      4<br>       <br>        5<br>         <br>          6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看题目以及给的例子可以看出题目要求，即将一颗二叉树的全部节点都放置到顺序的右子树，左子树为空。形似一根单链表。</p>
<p>有这样的思路步骤：<br>1、将二叉树的右子树暂存起来，记为y<br>2、将二叉树的左子树移到右子树位置，然后遍历现在这棵树的右节点直到尽头，然后将y接在后面<br>3、递归处理所有的右子节点</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="built_in">return</span>;</span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = null;</span><br><span class="line">        TreeNode t = root;</span><br><span class="line">        <span class="keyword">while</span>(t.right != null)</span><br><span class="line">            t = t.right;</span><br><span class="line">        t.right = temp;   </span><br><span class="line">        flatten(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\# Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line">\# class TreeNode:</span><br><span class="line">\#     def __init__(self, x):</span><br><span class="line">\#         self.val = x</span><br><span class="line">\#         self.left = None</span><br><span class="line">\#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, root: TreeNode) -&gt; None:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> not root: <span class="built_in">return</span></span><br><span class="line">        t1, t2 = root.right, root</span><br><span class="line">        root.right, root.left = root.left, None</span><br><span class="line">        <span class="keyword">while</span> t2.right:</span><br><span class="line">            t2 = t2.right</span><br><span class="line">        t2.right = t1</span><br><span class="line">        self.flatten(root.right)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道lc中等难度题，主要考察二叉树的处理结合递归操作，思路清晰后代码实现比较简单。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积-238</title>
    <url>/2019/09/25/20190925-238/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p>示例:</p>
<p>输入: [1,2,3,4]<br>输出: [24,12,8,6]<br>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p>进阶：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/product-of-array-except-self">https://leetcode-cn.com/problems/product-of-array-except-self</a></p>
<h2 id="思路-实现"><a href="#思路-实现" class="headerlink" title="思路&amp;实现"></a>思路&amp;实现</h2><p>题目其实比较简单，直观的第一想法应该是先将nums数组的元素总乘机求出然后遍历一遍数组，每个元素都对总乘机做一次除法即可。时间复杂度为O(N)<br>但是题目要求限制使用除法，并且要求相同的复杂度。题目使坏导致我们没法那么舒适的做出这道题但是其实也可以用乘法思路解决。</p>
<p>对于res数组的每个元素都可以将他看成是</p>
<p><strong>[该元素左边所有元素的乘积]*[该元素右边所有元素的乘积]</strong></p>
<p>所以我们可以采用两次循环遍历解决这个题<br>第一遍循环遍历解决所有左边元素的乘积（因为可以累乘所以这并不难）<br>第二便循环遍历解决所有右边元素的乘积（相同思路）</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        int k = 1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            res[i] = k;</span><br><span class="line">            k *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        k = 1;</span><br><span class="line">        <span class="keyword">for</span>(int i = nums.length-1; i &gt;= 0; i--)&#123;</span><br><span class="line">            res[i] *= k;</span><br><span class="line">            k *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        res, k, k1 = [1]*len(nums), 1, 1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            res[i] *= k</span><br><span class="line">            k *= nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)-1, -1, -1):</span><br><span class="line">            res[i] *= k1</span><br><span class="line">            k1 *= nums[i]</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道lc中等难度题，主要考察对线性表的基本数据操作，通过限制条件加大难度，思路理清后较简单。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表-lc148</title>
    <url>/2019/10/07/20191007-lc148/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<p>示例 1:</p>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a></p>
<h2 id="思路-实现"><a href="#思路-实现" class="headerlink" title="思路&amp;实现"></a>思路&amp;实现</h2><p>题目要求逻辑很清晰，其实就是基于链表的排序，主要是限制了时间复杂度，再加上链表的特性，限制了排序方法的选择，这里我觉得用归并排序的方法解决这个题比较容易。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode <span class="built_in">head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">head</span> == null||head.next == null)</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">head</span>;</span><br><span class="line">        ListNode left = <span class="built_in">head</span>;</span><br><span class="line">        ListNode right = head.next;</span><br><span class="line">        <span class="keyword">while</span>(right!=null&amp;&amp;right.next!=null)&#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp = left.next;</span><br><span class="line">        left.next = null;//以中点断开链表以免相互影响</span><br><span class="line">        </span><br><span class="line">        left = sortList(<span class="built_in">head</span>);</span><br><span class="line">        right = sortList(tmp);</span><br><span class="line">        ListNode dummy = new ListNode(-1);</span><br><span class="line">        ListNode res = dummy;</span><br><span class="line">        <span class="keyword">while</span>(left!=null&amp;&amp;right!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &gt; right.val)&#123;</span><br><span class="line">                dummy.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dummy.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        dummy.next = left!=null?left:right;</span><br><span class="line">        <span class="built_in">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sortList(self, <span class="built_in">head</span>: ListNode) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> not <span class="built_in">head</span> or not head.next:</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">head</span></span><br><span class="line">        left, right = <span class="built_in">head</span>, head.next</span><br><span class="line">        <span class="keyword">while</span> right and right.next:</span><br><span class="line">            left, right = left.next, right.next.next</span><br><span class="line">        tmp ,left.next = left.next, None</span><br><span class="line">        left, right = self.sortList(<span class="built_in">head</span>), self.sortList(tmp)</span><br><span class="line">        m = res = ListNode(-1)</span><br><span class="line">        <span class="keyword">while</span> left and right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                m.next = left</span><br><span class="line">                left = left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m.next = right</span><br><span class="line">                right = right.next</span><br><span class="line">            m = m.next</span><br><span class="line">        m.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="built_in">return</span> res.next</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道lc中等难度题，主要考察限制条件的sort算法，使用归并递归的方式比较好解决，但是这样会使用一些额外空间，如果想要使得空间复杂度保持O(1)，那么就需要用到非递归的归并算法。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>根据身高重建队列-lc406</title>
    <url>/2019/10/14/20191014-lc406/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p>
<p>注意：<br>总人数少于1100人。</p>
<p>示例</p>
<p>输入:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>输出:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height">https://leetcode-cn.com/problems/queue-reconstruction-by-height</a></p>
<h2 id="思路-实现"><a href="#思路-实现" class="headerlink" title="思路&amp;实现"></a>思路&amp;实现</h2><p>本题题目逻辑没有很清楚，需要了解到最终的排序要求是对于每个身处最终位置的人，他前面有且仅有k个h大于他的人。</p>
<p>我们用排序思路理清我们要做的就是，首先将所有人按照<br>1、身高顺序降序排序<br>2、身高相同则k升序排序<br>3、遍历排序后的数组，根据K插入到K的位置上</p>
<p>核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求</p>
<p>在代码实现方面，使用java的比较器实现，并用匿名函数Lambda表达式优化代码结构，以下是实现降序排序的比较器Comparator的使用方法（Collections.reverseOrder()的实现）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] num = &#123;1,4,5,6,2,8,3&#125;;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(num,new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2)&#123;</span><br><span class="line">                <span class="built_in">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(int x:num)</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是使用Lambda表达式优化后的做法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] num = &#123;1,4,5,6,2,8,3&#125;;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(num,(o1,o2)-&gt;o2-o1);</span><br><span class="line">        <span class="keyword">for</span>(int x:num)</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码大大简化，可读性提升。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>比较器传统实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(people,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1, int[] o2)&#123;</span><br><span class="line">                <span class="built_in">return</span> o1[0]==o2[0]? o1[1]-o2[1]:o2[0]-o1[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt; res = new ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(int[] x:people)</span><br><span class="line">            res.add(x[1],x);</span><br><span class="line">        <span class="built_in">return</span> res.toArray(new int[people.length][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(people,(o1,o2)-&gt;o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]);</span><br><span class="line">        List&lt;int[]&gt; res = new ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(int[] x:people)</span><br><span class="line">            res.add(x[1],x);</span><br><span class="line">        <span class="built_in">return</span> res.toArray(new int[people.length][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3-Lambda"><a href="#python3-Lambda" class="headerlink" title="python3-Lambda"></a>python3-Lambda</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        people.sort(key = lambda x: [-x[0], x[1]])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            res.insert(p[1], p)</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道lc中等难度题,题目要求转换成解法比较绕弯不易想到，而且比较器和Lambda函数对我来说算是新知识了，花了些时间学习了一下，比较有收获，需要注意的是，Lambda表达式虽然可以优化代码结构，但是运行速度在lc编译器中显示没有传统比较器实现来的快。</p>
<p><strong>java比较器使用：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Arrays.<span class="built_in">sort</span>(object o,new Comparator&lt;sonDataType&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public sonDataType compare(sonDataType o1, sonDataType o2)&#123;</span><br><span class="line">        //排序顺序o1-o2为升序，o2-o1为降序</span><br><span class="line">        <span class="built_in">return</span> o1-o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>java Lambda表达式用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Java 8之前：</span><br><span class="line">new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Before Java8, too much code for too little to do&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">//Java 8方式：</span><br><span class="line">new Thread( () -&gt; System.out.println(<span class="string">&quot;In Java8, Lambda expression rocks !!&quot;</span>) ).start();</span><br></pre></td></tr></table></figure>

<p><strong>python3 Lambda表达式用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//按照people中的子list的第二个元素大小升序排序</span><br><span class="line">people.sort(key=Lambda x:x[1])</span><br><span class="line"></span><br><span class="line">//按照people中的子list的第一个元素的大小降序排序，第一个元素同样大的情况下按照第二个元素大小升序排序</span><br><span class="line">people.sort(key=Lambda x:[-x[0],x[1]])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组的取值范围-T2.1</title>
    <url>/2019/10/22/20191022-T2-1/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定数组arr和整数num，求arr的连续子数组中满足：其最大值减去最小值的结果大于num的个数。请实现一个时间复杂度为O(length(arr))的算法。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为测试用例个数。每一个用例有若干行，第一行为数组，每一个数用空格隔开，第二行为num。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个值。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>3 6 4 3 2<br>2</p>
<p>Sample Output 1<br>6</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            int res = 0,p = 0,q = 1;</span><br><span class="line">            String[] num = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int target = Integer.parseInt(scan.nextLine());</span><br><span class="line">            <span class="keyword">while</span>(p!=num.length&amp;&amp;q!=num.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p==q)&#123;</span><br><span class="line">                    q++;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                int c = run(num,p,q);</span><br><span class="line">                <span class="keyword">if</span>(c&gt;target)&#123;</span><br><span class="line">                    res+=num.length-q;</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    q++;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public static int run(String[] num, int p, int q)&#123;</span><br><span class="line">        int max=Integer.parseInt(num[p]),min=Integer.parseInt(num[p]);</span><br><span class="line">        <span class="keyword">for</span>(int i=p;i&lt;=q;i++)&#123;</span><br><span class="line">            int t = Integer.parseInt(num[i]);</span><br><span class="line">            <span class="keyword">if</span>(t&gt;max)</span><br><span class="line">                max=t;</span><br><span class="line">            <span class="keyword">if</span>(t&lt;min)</span><br><span class="line">                min=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> max-min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>做法是滑动窗口一次遍历数组做到时间复杂度O(N)，具体做法如下：</p>
<p>用两个指针l, r确定窗口边界，初始窗口大小为2只包含数组的前两位，然后对每次窗口做如下判断</p>
<p>1、如果窗口内的最大数-最小数&gt;num，则包含当前窗口的所有窗口必然满足条件，count +&#x3D; arr.length-count，然后l指针向右移一位；</p>
<p>2、如果窗口内的最大数-最小数&lt;num，则当前窗口不满足要求，指针l向右移一位扩大窗口后再进行判断；</p>
<p>3、注意窗口大小一定要&gt;&#x3D;2，所以要处理l,r重合的情况；</p>
<p>高级算法课的课后练习和平时刷lc有较大差别，不止要想出解决的做法，还要处理好输入输出，之前一味刷lc忽略了输入输出的处理导致一开始做题真的很难受，nextInt() nextLine()换行符问题都困扰了一段时间。自己写完整程序时也要多考虑合理的模块化，方便错误定位和代码清晰性。还是要多多学习，多多练习。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和窗口-T2.3</title>
    <url>/2019/10/22/20191022-T2-3/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个整型数组arr和一个大小为w的窗口，窗口从数组最左边滑动到最右边，每次向右滑动一个位置，求出每一次滑动时窗口内最大元素的和。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个元素使用空格隔开；第二行为窗口大小。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出每个测试用例结果。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>4 3 5 4 3 3 6 7<br>3</p>
<p>Sample Input 2<br>32</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            String[] num1 = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int[] num = turn(num1);</span><br><span class="line">            int win = Integer.parseInt(scan.nextLine());</span><br><span class="line"></span><br><span class="line">            System.out.println(countWin(num,win));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    static int[] turn(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int countWin(int[] num,int win)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num.length-win+1;i++)</span><br><span class="line">            res+=max(num,i,win+i-1);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    static int max(int[] num,int start,int end)&#123;</span><br><span class="line">        int res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(int i=start;i&lt;=end;i++)</span><br><span class="line">            <span class="keyword">if</span>(res&lt;num[i])</span><br><span class="line">                res = num[i];</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>较简单，略。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>子矩阵问题-T2.2</title>
    <url>/2019/10/22/20191022-T2-2/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个矩形区域，每一个位置上都是1或0，求该矩阵中每一个位置上都是1的最大子矩形区域中的1的个数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为测试用例个数。每一个用例有若干行，第一行为矩阵行数n和列数m，下面的n行每一行是用空格隔开的0或1。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个值。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>3 4<br>1 0 1 1<br>1 1 1 1<br>1 1 1 0</p>
<p>Sample Input 2<br>6</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class T2&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(int i = 0;i &lt; count; i++)&#123;</span><br><span class="line">            scan.nextLine();//pass the /0</span><br><span class="line">            String[] two = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int n = Integer.parseInt(two[0]);</span><br><span class="line">            int m = Integer.parseInt(two[1]);</span><br><span class="line">            int[][] matrix = new int[n][m];</span><br><span class="line">            <span class="keyword">for</span>(int k1=0;k1&lt;n;k1++)</span><br><span class="line">                <span class="keyword">for</span>(int k2=0;k2&lt;m;k2++)</span><br><span class="line">                    matrix[k1][k2] = scan.nextInt();</span><br><span class="line">            System.out.println(Deal(matrix));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //deal with the matrix and produce arrays to deal</span><br><span class="line">    static int Deal(int[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null||matrix.length == 0||matrix[0].length == 0)</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int[] arr = new int[matrix[0].length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;matrix[0].length;j++)</span><br><span class="line">                arr[j] = (matrix[i][j]==0?0:arr[j]+1);</span><br><span class="line">            res = Math.max(res, dealArra(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //deal with the arr and <span class="built_in">return</span> the max area</span><br><span class="line">    static int dealArra(int[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == null||arr.length == 0)</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()&amp;&amp;arr[i]&lt;arr[stack.peek()])&#123;</span><br><span class="line">                int cur = stack.pop();</span><br><span class="line">                int left = (stack.isEmpty()?0:cur);</span><br><span class="line">                int curArea = (i-left)*arr[cur];</span><br><span class="line">                maxArea = Math.max(maxArea, curArea);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;    // <span class="keyword">while</span> the arr is finished</span><br><span class="line">            int right = arr.length;</span><br><span class="line">            int cur = stack.pop();</span><br><span class="line">            int left = (stack.isEmpty()?0:cur);</span><br><span class="line">            int curArea = (right-left)*arr[cur];</span><br><span class="line">            maxArea = Math.max(maxArea, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>解决这题需要先了解直方图最大面积的求法<br>初次理解花了比较多时间，说起来比较复杂就留个连接：<a href="https://www.cnblogs.com/CodeCafe/p/7634233.html">https://www.cnblogs.com/CodeCafe/p/7634233.html</a></p>
<p>了解做法以后只要将矩阵读入成int[][]后每次读一行，并将那一行的数值当作一个直方图进行处理得出一个最大值存储起来</p>
<p>然后每次读下一行（需要通过上一行的值进行更新），又作为直方图得到一个最大值，并和之前存储的最大值进行比较留较大的。</p>
<p>循环遍历矩阵的每一行后最后留下的值就是最大值。</p>
<p>本题难度主要在直方图最大面积的理解，并通过辅助Stack进行代码层次的实现。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔-T2.4</title>
    <url>/2019/10/23/20191023-T2-4/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>汉诺塔问题中限制不能将一层塔直接从最左侧移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间。求当有N层塔的时候移动步数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的第一行为N。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>移动步数。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>2</p>
<p>Sample Input 2<br>8</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            int num = Integer.parseInt(scan.nextLine());</span><br><span class="line">            System.out.println(hanoi(num));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    static int hanoi(int n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == 1)</span><br><span class="line">            <span class="built_in">return</span> 2;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">return</span> hanoi(n-1)*3+2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>题目描述其实不太准确，给出的sample的要求其实不太一样，但是也不是很困难。</p>
<p>当筹码只有一个的时候需要移动两次，而n个筹码移动的次数N(n)&#x3D;N(n-1)*3+2：</p>
<p>即先将n-1个筹码放到最右边–将第n个筹码放到中间–将n-1个筹码放到最左边–将第n个筹码放到最右边–将n-1个筹码放到最右边。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>区间第k最小-T2.5</title>
    <url>/2019/10/23/20191023-T2-5/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>找到给定数组的给定区间内的第K小的数值。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个数用空格隔开；第二行是区间（第几个数到第几个数，两头均包含），两个值用空格隔开；第三行为K值。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>结果。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>1 2 3 4 5 6 7<br>3 5<br>2</p>
<p>Sample Input 2<br>4</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            String[] num1 = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int[] num = turn(num1);</span><br><span class="line">            int start = scan.nextInt();</span><br><span class="line">            int end = scan.nextInt();</span><br><span class="line">            scan.nextLine();</span><br><span class="line">            //int k = scan.nextInt();</span><br><span class="line">            //scan.nextLine();</span><br><span class="line">            //String[] num2 = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            //int start = Integer.parseInt(num2[0]);</span><br><span class="line">            //int end = Integer.parseInt(num2[1]);</span><br><span class="line">            int k = Integer.parseInt(scan.nextLine());</span><br><span class="line">            System.out.println(Run(num,start-1,end-1,k));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int[] turn(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    static int Run(int[] num, int start, int end, int k)&#123;</span><br><span class="line">        int[] n = new int[end-start+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=start;i&lt;=end;i++)</span><br><span class="line">            n[i-start]=num[i];</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(n);</span><br><span class="line">        <span class="built_in">return</span> n[k-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>较简单，略。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>固定和的元素对-T2.6</title>
    <url>/2019/10/23/20191023-T2-6/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，统计这样两个数的对数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入第一行是数组，每一个数用空格隔开；第二行是数字和。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出这样两个数有几对。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>1 2 4 7 11 0 9 15<br>11</p>
<p>Sample Input 2<br>3</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int a;</span><br><span class="line">        a = scan.nextInt();</span><br><span class="line">        scan.nextLine();</span><br><span class="line">        <span class="keyword">while</span>(a&gt;0)&#123;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            int num=0;</span><br><span class="line">            </span><br><span class="line">            a--;</span><br><span class="line">            String[] s = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            int[] group = new int[s.length];</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;s.length;j++)&#123;</span><br><span class="line">                group[j] = Integer.parseInt(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            int b = scan.nextInt();</span><br><span class="line">            scan.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(int k = 0 ; k &lt; group.length ; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(group[k])==null)&#123;</span><br><span class="line">                    map.put(b-group[k],group[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>lc原题，可以蛮力法简单粗暴，想要比较好的时间复杂度就用1、双指针法。2、借用map。原题就不多赘述了。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>从前序与中序遍历序列构造二叉树-lc105</title>
    <url>/2019/10/27/20191027-lc105/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>返回如下的二叉树：</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<h2 id="思路-实现"><a href="#思路-实现" class="headerlink" title="思路&amp;实现"></a>思路&amp;实现</h2><p>通过前序遍历序列确定root结点，然后根据这个root去中序遍历序列中找到它的位置p，将中序遍历序列按照p分成左右两段，这两段就是以p为根结点的左右子树的中序遍历序列，继续在前序遍历序列中往下找root子树的根结点递归解决即可。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int pre_index = 0;</span><br><span class="line">    int[] preorder;</span><br><span class="line">    int[] inorder;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        this.preorder = preorder;</span><br><span class="line">        this.inorder = inorder;</span><br><span class="line">        int i = 0;</span><br><span class="line">        <span class="keyword">for</span>(int x:inorder)</span><br><span class="line">            map.put(x,i++);</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">help</span>(0,inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode <span class="built_in">help</span>(int l, int r)&#123; //l和r只用作递归终止条件</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        TreeNode root = new TreeNode(preorder[pre_index]);</span><br><span class="line">        pre_index++;</span><br><span class="line">        int mid = map.get(root.val);</span><br><span class="line">        root.left = <span class="built_in">help</span>(l,mid);</span><br><span class="line">        root.right = <span class="built_in">help</span>(mid+1,r);</span><br><span class="line">        <span class="built_in">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">= Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line">= class TreeNode:</span><br><span class="line">=     def __init__(self, x):</span><br><span class="line">=         self.val = x</span><br><span class="line">=         self.left = None</span><br><span class="line">=         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    pre_index = 0</span><br><span class="line">    preorder, inorder = [], []</span><br><span class="line">    f_inorder = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:</span><br><span class="line">        self.preorder, self.inorder = preorder, inorder</span><br><span class="line">        i = 0</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> inorder:</span><br><span class="line">            self.f_inorder[x], i = i, i+1</span><br><span class="line">        <span class="built_in">return</span> self.help(0, len(inorder))</span><br><span class="line">    </span><br><span class="line">    def <span class="built_in">help</span>(self, left, right) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        root, self.pre_index = TreeNode(self.preorder[self.pre_index]), self.pre_index+1</span><br><span class="line">        mid = self.f_inorder[root.val]</span><br><span class="line">        root.left = self.help(left,mid)</span><br><span class="line">        root.right = self.help(mid+1,right)</span><br><span class="line">        <span class="built_in">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lc中等难度题，其实是数据结构书籍介绍树部分三序遍历必定会提到的经典问题。</p>
<p>解题思路比较清晰就是借助先序和中序序列的特性进行递归处理。</p>
<p>代码实现方法比较多，我参考lc题解借助map（dict–&gt;python3）能够比较快速的解决，并且时间效率较好。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>PES-Gmair install&amp;management&amp;auth admin</title>
    <url>/2019/11/05/20191105-tec/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3e63badf42bf442ea004f10187e04a4b115d7a7c81f6d04b7c396c64b698f91e">4d94d3e2ea964a9497276ed6e2e3b252f7448996904b2d22e4065ed40f4d7e9820f3762c45d6cbdf9bdce19c3334dec7958c66ab6f6a69930450e914b93ff12edc2be17e8f1bb535973f5b066adf452a76c30c784439363132764048afb28ef07c3d7310f114042dcb00fbea39eb7e49715ba7c7282821c9d8466de8b89f571aae349053eec4d208c942592a10affafa0b0a65facbb82ddc7d75ad328d24e74ca394e7cf65d9d830205ef63e969e587d2716a9d3d6f0decb9aa4027407a567f9d2157836ea5617b6db3b44dbf1d45b962da33cb8eddbc4c3a2526d0ca32ea0d7141ec8e648dd321692f9c22442ac3164072bb6f98b83d96ecfa586eab0358b647d1d46b5d32748279a8225dca4f18209c1620bdd49fab75525b2fedace2b8da00c84bbc157099dd764cd72e053572f43fd9f8b64ef131931e99df76061593588333b1028b180db778edeeb5ba78e9de916883cd70e0fe345926a5d8d2104b5957ef081380ec1e7361a44f62d8ddb717cbde3113c3c6eb6e50b48413230ba76dc00090bf676b43a352b159d16e4410fe2cc15b7c2376632da24965a2849943bbcb8b9e37a0f28bf13c38dff1c11d83902d419d2b4cda746ac1acc23bb39240701d1d653f1f03cde72825c1988fd0209c3b9968b8edb29ac03f67a04346216b4b12dc48d536da26c55eaf278095ac29f11a8b1ce65856d0d12977b554a3d98ad81aeb6482acda08e00a4fe571dacb1c53a12b14ba10ccfc533b5cd41d66e37f5bbc917eaa6bf847973788627a42fbdedceee7810e96159a69d4436d6bb41379700190af5fecce050ceb11643cedd8f208d701ba6cec795c6472d3ab65e148c070b6a01458da111fd44a31145b92aefe1265bf93b28183d713058045b0ab25ace229880adfddb41d2bf2fc2d3527e45159d25d0d9878cccece94ff8c608b55c9de34466da218e298ede7a5f3bbd7e82737f913bce8496a1f50153b717c3ee03244a51dee0bf61575d39eb451405efd0d59f615ecd63bac84b2a9e3840b05db694f9b006fd69c8771e40f89ec77eacbf84e8f507ebf71057b37611b337490c0d9a27b8b403b8cba392b77d0987d8f5f6a844285895e04b2efff9b681993ff84dabf1b2c3dd84055de205ca47c50e699e70db2a53b44f67b4a1736e53233db71ae10c11536e88a9fcbe5a0cb0b9358f206992976ab53ec3a551e60224fd64e325b4b56f5e127fdb391faa2c75c67e2c978ae4eb06c2567322da368259ebfe1120ca1f8334e7840172ddfd0b4f6cca8d2fe1bf8b3e9bdd2df44517a8c781f35abfb7d8b269f830fcaac58d96e84a283e760b064a84e4639cfd2dba2911619d88433b635f6ada2815c9dce3f0252834214fa80c4240e6e04ae4d8af7eb895ebfca835d61f2101e64084b4ba75a068ab0ee6038f4aeae385f3f277434d15cc87b880fcfb9c948f2726608baec777068802fa117719e27fb354171e74f60110ebb862d5d15e9c34513342d50c2650396b13d38c202149b133cbfa4f2ab51abaa2b6e5e5f480f0e3c1f1a4f5b7ece5b39b183dfd4ecc9647500b3e85b96f4f5a7d2709fd9f475f163da3acd284efb1887b3e05e8d0972e7a839221c2f312c2b9f5811fbdf3acc7b641cc483877d0a235acb1cc9e1657a170364401a36c1416ef3fe7e7c854ec8607920be35ccdac37d4f21eaa0d383de36eb7d6dd40fb42cd26d486c52322e0ef8315030eb3c5844c0d367d21765603e67f8ea70aa16751e71ccbd65fd5ea0c2e8e6f544d433a5e3d3335490d05ff1fd995fa322208067b1c3bef6b779cd0faa9b34b535ee5e1abcb41a644f4379b817d00b06a2ec1415b2234b396d0ad847d7f2c04e33d28fad265cb61c51bd8225dd3910815eb74f608c8340f28124e145810cc77f73188b33f44b4436caf1bff59c867a0416acba21ec221bddf88f61d541b96c7b16ec05977ceb640c04183558ad0141971a23f98e8cd827eea99d0c383af5b0666231c2f7065baf64f8c3c177716a1b47879909587926f7858cba3f50b17eba8dc1787ead151f17b11d0d3b1c7fc16e4196c6c745944e399c778b2f754179b73b8074db0cd9d5b2ed42250079ec33b4fee197e11ca7d59d4e72c79863b5bcb2da396efd04e525b8adfa95d65e53e7be7ba608b74d41024379175ad9bebd128c988f69a87d131461ef37376127f24d5e0203ecf969746568cdb48f2cc26f28b85c855a6b1229cebbc5e8fa9360d32d44393a5201db8c7768006be93f8e491e56844d2ce7e91650b3d99776d94ab395a877ed89f15b410d854fc5c5949a8513a82e53e04d742eee3cb46eab7666f5b59aad9175e88d56858a710181ec2bf973d0a91d7a17dded556808874f8c1d119e9ca603df3a9aabfc7c6ef84f2f3ad2aa8ffcb6a84317accdfb4566ae0d6f804a8b56a8742df22b437da28ab762ba55bc472d0cec7d94af0e391961c72e0b37d3e3249a0cefe6ac609960964cfc3d7ee3984ce88b4af77788f0677575470ef18a3eaf817717cd5cfbfd33236b8400783659e03d899a560466364356a4f9ed4dd706b47eac1792dab5524023f5da19cdb5e3a16cce7515d1c3307eab7d26650ba187e50c92352b6877d4076fe93db3e6da56c2ed99574fc7194e150213b4c17bbf0a58b6b1d3d54a53fa798169d2ab43e10e8a0cbbb22b577d86fcc2e5f6350b07af61adbb977a57c69122b856073d00017d34ca5d203b24e8a2f71cbf290da53cd2eb50310712914a4942cca9c3f2df054b4a1ea2eb9277efb2971b58fc6a034c40f3fcd4f619b2f71547f925003395823b4f2d7e75a2c0edcaebc1134e61b8d835104c1dfd4c58fabd398c44990ff30a4d56e38e34058faaaaec90dad434d0dc97d74b2182eb417fcfbb04ab6b3c986aaa417f9ad3fcc5b64e329cf516c6cbd43105e07125e2a4dcfa791efdee57b6b20d8def582b546083769bc3daecee9d6974600eace25a20b4a760841d17d015afe7cb3b7fa7ef18e35a29506f0fc3b5979f38c17b1388efa20fc9007e032910e5296fc41620070942db39ae441687e32a937a09932de8f1f2214cd962ec52c67c8d537d51efada587c33f8dbc89b689dcc0dd343cb3bb718f7c90938d25def1bfbe18549d36e1cdaa83cc6922e47bc46b8dd741ad81e0a6d6b6fb12c8bedded6aa439f7683805f13bf398dbcb3f040d1812db3a6227f78b35a1dcdccfb2259ace33c3d80015c71c1d8448be8f34ac85b2a8a21ad29f2b5f4078c7dafbf4a3fcb254e2689d410a8304ee9831785d376dee3c964b38bb79681ebe531d8daa9bded8a8d0d68bf3f38e45900c38ef2877fbe5340750b45574edb14079665dba03d88f263209de00b89af3c5a5763eb8c21a4a44ea3c3a4d1a4b97fcdb39521c494f8f59982e76ae9df94bc36e68d9b98e1a8f24297e20515bf05fa26d656b99bc87f561082d4f234090219270b6c45a4c0fe10f796f783c9dafa1c4127266fab42ba6c1fa209f209d73176eba29aa86261873cc1691f589a91bc7c22b7532d06da3cc23475b8895f88bfba54ef9a0785d71a84d59c492dee5aee095dc3c58f19083b2c68c66839085a0066d26610c7eea0e43dfc968df57f8fb5751d2167730049f03673fa42b21366bcbb5463cd3301baad55e03415f0512389ba972d6f956ac2583be4edbcdbda38f3f92020badc9ed67345066c082ec69e1f2677708cf93a89ccb861a1fe51e1a8167ddbebdfe7ef18665e4800c9a411b85b33490de69608c689d2f728ccc980a9931a5a1706abc625d3254991ccb8c9e01943656cb64ac3ad2c306eeac999116ede334f1cf6d5f15249e463268f3dd71cc51f6d3e8592de843dada644bdc34e4a3d38af37fe0d537a4f379a253fe9e2ec69e440e1be12b2a743f750f766f18de64a396cd175ecb19fdf656330e382e190b7e3b8430ec5fdb3c52e5842f4449a55bc3b85327b860173f15e20e275b855c4813f585ba59cf0b5e1d8a892939ceca5a3c11750d7473958a0d85636da23038d6ac60f0e24e5399bbf3da7cb670ee4d54a0a817d9bed587bf89d3d4ec7e0a169c2504a17d6f3dcbe0d04d253867c116ca2bad850e87caab916d2d7000f6672aa2ebdf51834be4c29cfd2c47e0666f8716dc1248185d8440313e214254318d1c3bdd3ae966f1efaa943b297737cc31e3200c0eee765954bdfb677968065124ffb83509450717530ec45784879a3bd3137a66641e7ce169d45232052359901f1ab596b552e454543b47680d33956f31afbb279a7dd1d6c7d2bcb5ff70a4ce9d423acadf3f9d4131ec3b65c4fb1647e292d7c4c2db85cf95ebba544cd1d56ffb4888d4f4096319d1791880a13df412ac49910865fccb395b5dd5160728fceb7bd30f72a6cb9ad45ae3d8b26fe1cf1adda99458b82e969d22124cfdc0f5b94ae8e07f5794ddf7f3b4dda30f2207c5cfb07d290dbd40b31761281658e18bb725cae692b5272718527279fbe3e0cd55f672064e887b6856178bff7666d6547c8083daa0fd9f852b89527f5c7e5d7a884d7702b8228ba63b33f2848d650e2d6692ed97d3dbd639e99d7bbc3dde141ea3f45e1563062c87fa7341fb95fc856aca55f99c22da69568ebb8e62804511a4b6cdcb81feb74b6a5a2524a2a960550b6e5b2718660c1c0609ed039e7104e3e791796bf1a3d8fb780b375e2ea3ec03267df6507082cc6d3f56e886c4e0725fb0033685825f2afa2c95185a5d5702fea56c649260361d86ae10ad6106fd70bfb0c6662de85a817b0e3d6c6fde523c397375cbff80b7eda3931cc878a5158ff693b03bcbddf18719ff6057c0bec56931302433ee4174f01aef04c8a1ec65b16fc53d7154be2540a3f257763709460b770681afaa16278592cea5fc035d09a8b4acf26ea1cc47791a1a14e72508f6c1766c2b3b987d4ab152aef7a982181120a132d7c3fe6de5dd479b9c24fde8894561931d36d3347440c0d72b28d531cb2b0566af56ca37ffbc19952db1e37db8794a9cc28ae545decf5ca939a9d30e78dd642ac6494bbe737312cd4d1f5856010552a948c878cf0cc0838271a052f721dcdaf6a3cf1bd45aaa072f019f1b29213cbb75f11663379c68fcf2eba23b74f55f41f50eb47c647764addae19e819fc733b1bc439e3cda3a04fc94716ecc9957ca53adff00468814d325384fbde1369fd53b1005858cbfb058da6007bb8de2394e1d2a49c7330df40f7767016e81bbf0605351d59abefd29f9b8f716d48b7293326988ec98b31481e771a1a146813dae55c4e8aa15eecfd30061b0a4a765481d60e961f6d7584b1a67d58b86071ad51cc3302f211faf418cb434cf995b1ce960637238d39490612aa6dfc9b84eaacf5ecc0e98761d5124422066cd61537f3c6b2443409e7415dd9d156fb284ecb3d1c016e7fb1f317bc6104a1952aeaef55e4600bcb9e26f679d4b29d28d8bb3686cdbaeeab0d736952ef54aea52bdad743f8e3c3f98895f1ff3dbbae8349d0f5d9ee9ba096fed798d406c7f4df9c8ce77ba4d13214d9204996c4a8dd6d195158a1c7bf0e382ca25bbfcd356c1aaed03c0211f2d9e6f1f452dcf067109a63886c08a5a43213e1322db461a8954ce4b59c36666d3ca4ff967062c2672fc6cfe4340c3121c88d9256feda7b3a33154d341d03a45c274e446aa52c552ee4229e75f9a799a9ac5779500283f380cf0d1564d0bc747ca69a091184af3372493e3364cc15488df66f89dfededdcb1dc8c79e191b766d963d7299f7c087da3467c6b7203b9e5bd9a0819020d7a5dd0348831edc63152c9392005ecf44de696128e388a1ac7dbbcfc3a5cca59833fa633fa549b18e012159eafd7327f498110c3e8043cf78baa2b96d5ffeed2bfd7442ab8f58def5c8575e9df96a938d4caf7d31e76c204a3d9f6d5588ca3147f385ed485d816b197c32a0dbb5b69589ada979b4f757a7aca8cb31778d26f3b88d2fe36d15f3fab8bcfba657f9fb732aa55063663f4d76160a1b6025abb5882b21e47e37b5fbc620a706b4e4e43c9315d5944dffae7179cd780e08c92c677b798d8ad4a90f835ff08e6a6ca872e0de8a7650d4b13945a1d691d5457aa62d9bb65886f50ce550e75132517dfea7ceccddb89914feb84ac5d2b36bfa6f60d52c1d7bbc419ee5022d41530c002ec7885c6f80471f2d32f59fa8a58ff1c4c21ceadebe6683c2e3f20ee9c2cd3117db594e5ee8d5b28209addb8e73d08916f88b79f51a3765ad76aa24c1d68f1bf899ff66981bc4a09f5bdc48f30d50e2d916eda7cdc326f9390d4cfde874f65bb10eeca1c1655e38f403535ff7bf50bda7e346cd56717e4b051f762e5cfa7bdaaa42db2c3dfe0b8cb7caf84e322589d163af760a01ef9d6c60e1f3545a3341f7ecf12a38d86a4d2540576b4e2acebeab25b88e06158beaccb09881594d09dada7e682362e9043ab726d13b531d0f0ca2bf1e7c632a3f124ed132fef872a0a9129ad42c9c43c990b3dcd319aa018c7855430f606f65f13bf320da2ebe834942da515aa32c843f71955e5e0d22207abb85f5fd14a64237167aa7914d92708629b4f896167707608be6d9cfde88351d2fd0b27ebff79ac682fc73c5b6bb7830cbc614177fb4a542d45170c3d02833846fb3d0983df2a508bdd0ba600b78e6b500cf72320d0fc9b6dc798a8a90d08d35024dfc91198438a340c6b031277855da30651176e1a7653757142f003d9a938c9f81b8fb1daf1f2a99945a9e16ea4baf0d785222930383993a303988164c5b378afa2460da73aa6d127f00837f1b2b389af707223e80aadddf6505dae3a8dfeac8400c36e6529112309392b678021262e2b7949dc8ad4e83aa5a1dbecf9ced99a413b7495b5a425cc68029e89a030d8542af87ea814837bdf6e77cf6e61101461f1d383dc87f7c20020b3d3d6a3626ab5c2c738dafe8af86b01e7d4b29d3f25e367009fe5c0dda161efa47ad0709d944b7e64038a0995b8c67c8c55f1a9609d853b4ba1264b6273403ce96fd63c981e92b0aff311a16f069ee231bd4ee141b3f819d28a83e1176427adc56ff96c964016282aa36508a15d383bec88d3da9c1430338b6b17f71834e6296e0a7161b4780e78827af0ceb8a3f27e6bcaeabbff07977f1a11f50e0d53f4caea579120f129b10c429795f9348290ed78113bb59d2a16441aaaada8719ff88b39b216fb4a3cb8c36d242f955064ea5642e5ac87c08c96dad53a36fb32f0f0f534d0b3d7219ca10059b3014ca0c3106d5e51ec790ece4b06de335e6ff81215da639bf5c66d00d13252458400f5907fac501c84a890df2db422153c3b0c2a2754d3f6984b3dadbf78f80d334666ff118d3a95c0529ea8fc8103c97ca51b419bdaded6126bfb5d1c6fee8f992f815b1d2481191cbafc4cd281abbb904c4bb99effad525c0bc249ef182f2125be1cae01d51e6aba3d53b6d07d8f8cef0535add853462dee7ad7692c68da5422c74cdb7b54ed93bb131c0abb076bf91ccf6d1fee1b240ed5c23874c5649ef95b31576d59e524f599276f7da10c9d1e98e1813afb509a25c7d3385f775c142468f349108d6b0a69f43f1f37197846572a004e68c92b6e106caf016cb9e4487177f1eb0c7f78397cf60311878bcfa5cce2a457f949ccf8f65a274bd5e3d2c9f3f9062b319f3735f872ab1c780760b0c936eddb28ccccc2837d8b1096b04509f0b3cfc070642709a65feb31235e0e3645c3920c6e9156606419c79af2e086a90e661475b5cedc00a702369e8dce462db0c4da5aa13ab7d07c232b279efe8699125b01995531a7c6f78ecc41144d7c73c9011eeebbeca8841ec8c8d77cdbb868566b5acc8619ddb581f9eb54621596cd9218f005df1ba2827e2dd1015270a6da8491af4d112552f1a32d3beeec88f36906bc353507c9fa3f6559492a1c870f06a7f5b7092257d9d24bb3a500607ecaf650619c49e081a7bca425520a55af39f003f1d96b6d3e4fd1b5b12f392bc16c219bf8ac00ab29053ae12c0dc2464ae9424e7b2366e3fdc2d9cbf4f5eecd182cca58500a29af55749e37ef21c10a2f5d40c6335aa1ff888d671ea0a1056a74bc5a8b013f28b6c5d9e23f40ebc0e33f8c105ede2256aee853071d76f115bebe50440621d3b002120d67fa1e498ebff641002f6797fb61acb8bc19b293464a0503c7a7ab4a7fc70fb110d42e38ae39d08b79e1de3e2d65cdcdeeb9796432f35e7cd1ed6835540344d585b2aeea6b916de9233a5f3b8fe2e579e077972079c7548f6aa15056f019fba9ff510c5aa32ceb74e9702fc09457dd0ac55dbaece16b8d718d4d481d56b51b9d37dae9071e5e547f9dae9d366835cdfd4409083d854892d7103231113a4f5b9faf890409c1928a1253cee8052a0658ecb1419baadd1bd67c775729699765be900a522810065a96667110b17b5ce4237e232c528aa033a052201779a172ebc9177253084a04d0fdf66382e52a4124113482120ae87ffec45aa36fca1273513ea6656dd617aa134a455d8b0f06ade8b95c784d051154149b870c685b063594106806778c84b9db27f61e1dca62944c0eabbb609f8007d70805283294e9d8dfa92b7f61654f2310a3b3b118d3e08d963ac5a6997dae6f5bd3d6a90101154940fb6388e82010895ffe289fcd45bd2796ade9d9d3edab7363c41c0fc6e70083ef53e2327d2ae8ffbb1d29a4658cab2301f11dd46612e07649e92574563cf8956d43effe4e02fc4546490ac5939556245d31d3961257c1eadbd3c803683b379b1fcd79698086f47575c90a3419f53b45b1b560541c59f50490fe661ee4a9654c75886e043ce523814657aa5687f7811b923193f4b5637652228af4c0a83358dc303c00208fe017e585db0f254ff49ec446d0ec1543c3320620780c4cc0ce9f5b99eda25994e7f308bae50d9141480a8831dd020d63c00883320847639afc846a5d068a173e291b1ec82aa438d8849108890139b28c9592afde8307fbc948f7aebf0f4c020b0323b00c40db8f473ec07e3f527fa4f181d8a1ade4442253928fc2bafb24ebb7a46b66b0469ae9031f0700481a9e2847fea6edfac95499d7cab8cfa6b41b9e999a002ca3783c43c2140b79bbf94386d041585258cfe43b9b76b99914e78af079a63c83ce035697a16732c32952b0324f8188b95bb873fdfab561d4376cbabde8814343ef16eb265aa3a50af687f1f2015718be4ba27c828645d610857b7fb896723d3236dd45b08eb03239b99a83c10fc0bd0ef2f19ef8577aa4a8005965a670deaa0a6bba5ed06e6b17dae79d44f46c6c48a809c501ebd8fc12f98ceea03c48827820a1cac83d0663e46cfec05eefb86d29c1230754dc7dbd7a8ea854a72228ebfac491805975e6736e1b95893dad7908aae6d420abd3ce14ffa653e3a183fa0020abb2adef8b08c4df78db6f3c6b5cb1d67f1447d8ef54dfc0332e9497c88135357073e3980c8415e794baefcf19c54c95086c0baab1950af0b4a2112e54a5533d6288007885c03d883bd90891205f4ecfbc21ea5cea038a9ca028d83372ccebfdf4c21ddd238765ca727a0af173c6078904f3bb4a668a35bd6bf9bba18b452212ae9245e85f1840a5fe0dba4bdc7e931da55969f3b21d167659bceac3b8b43834e6fae7343ae00deb1afeb1e71a5fb0c87839b840d493f480507b95801797a413ab05ad7b719d53ee24edf2e8dae9afc8461ab61275ef319e29547cde963fe7240ed1b5c5cc740e8943b68ee34fd7b46257affc0c034738522f99389265be2850a43ee083e30ec521a484aa2b45c6a76645d0a301aa10dbe83cf2e875414b23e35fa509995971c214b56f5c77f366e929d50108adde221101b482fa72469265f77c98023ca8aeaf7f8072b0582f2dfc408fc5f39da610dce9917c7942176276f8b933ab58176d811c02d8438477d8373ba983b0c3f2ec4aaf0a6df235eb78bc7ebd64f531dc013f498c0fc4af7e3ae2d6a671493a6c7a5e7b230b7676b76a85fa11a5dadbc6333672a63a1aac148cf6eecd4becbe201dd6f85454bb9af3f9e3d6391b92a707d5f9d1b5f92d22ba565d35603bf16447059cc5fde122b532241ddf80f01ad8112ff9215b4833af7a8efc8d209dff6e63e8fdf851c2031fbbba48965aa38fe59208fea9c58f48dd3e36636f17088217610e7767fe9423ff6624f56184ee63b51425bc400abbb5bb26fc4e5c379534f42d933731ebf6f710f94d4b7a1795957d5b2146e5fe44ea3190f2c2eff9ec2436c070f3b86ce7adc26ea543a184e6dbdd3620096c000c876fdd2d17f5b1e8a68a559457c78d8a796d7ed9a3f7ae5c2aea3bff39b00e14737b79f18c65afb0a2fe76bb2fca01a5829c82004a5c990db4ad35ee592c0e6a875d37c3e32b049047f2a8619aef3c2ad3f423a5186a037f117f05f1b9c8789514605d1ada686afc62d2cbad0ae7b18c8f3681764763f1c5c0423e82475868b957d94f79b4aa46c4d09146f3f6d9f38bfb84f594b8fb0631ee148bd18e4f6baf7704b4f464d56a1041c862c8be9e85e188419d6959cd8d00ecb996bf8665acf41eb76b7bcc1dbd9a89a2479b024f54403a3c109b8b4a1fd835443097097a7e4e159debd985c28fbc7ad69750de8d5d8e10c0b2a9271c0fb3b98f30b62d58e60fa6f2b40e1b3a78c5e8a4b13a66646ffdea5c4d91a5f993aa822ed9117bca663abebf965caf2eb2ad21a084c4c5c4d9019477ed3e59fcb8610c11023f17497eb8aea6fd5b18204a4255ccebd9d496a66c5fa30465480cea3deac29fec3416914f6f3a33d25f2864caff8853b88a03b3bc134f951afd6434b9798dbc1cc4783f4b639e2794823899ebd5e54f5736d56aaec4abda6aec5710c00b19c1ab5327c28103cc6d18c4bc89912d709a2ee7adec97cf388bacb352167ecaabef91055f1c586b7a110922e81d55a4d222cb55d61135921d09cabda484b3e13eabbd7a398b51a62e58c137017d1a696bb2b768aa9c80bf6d98dc395ac3a1e83235cfe2d4c2b5946f40250cf56c51e4d597978541dce7bca49ece9bc4ee8b4eb416df9e3db36896a33c89594b4a93165c7584953af5ecbfe4d28c26c254d83c7c1094c2ce83a5445f95708a52e41044a11957436933ec840e3bf4b51abac36566a2a07bc83c1381a254ff61af89804fc4944a4ddc1d2329563886d627711b17b2c08c59a0d44bb6f70210298f0d9b4e717740429c951eb0303b067a97fcc9235b115c39f55435a6bbbfcbba42bba40bac96c07e6f5fc4b10798f08686505d29d6c8e31474a3d71a135418a5197ed19da284a7fed658e7998df1290cf1bcbac58c8f35725dde4fd299d7808ac89e0a3695dea7dcbf5cb591744fdd7233f32d6caa0379448751fc6bbaf6eb82338ea87468407a6fa2f1feb419e3d161011b7aef71894638aa7238a84b603409d5490c85efa9813c7a14a7633eae93a96002d915b8d4d8bc7dd19d33914518f56fb6cd684e249e142f7ca92f2c6c14a4903d2491c4d64c51ec8419d8cc6f38fc921293f6c1edd7b158bc831952d8fe29c83ef6f4661af6444d08a56671fe36e2b2c6caa30515ff67f1df6863a822179e96e590334b65e3f2cf718be3a8b28d80cb2ca194821572b9484f828147e1934b823363531d6fb0502676d886f99d1497f76f24cc976df245d72f67eaa0f93af5a2174f3f067659bff50bb1e5b95add0e0d48b65c603012073d56d0d8def7184bf4e1375ddd0b672896d0f8e53c4c39f1b5937bc44da6125ebc211284f2ae07cb321f834d168070c39e16da6f91cf342c031ad2eddeeaa2ed66e8a18ab5540970b50018919456a6f136d6d11d3508784077f1ce39ba11c59802199accb578a8c9d3bce609b2ea74247e95d8fa0eb4be28a7e58222f335f58dced6467bfa7a17bcdfdc4287e23cd764edaa29db9734360d8c460ca7bdb8394263289742e420ecc680726e51e98842fe6322064839c07fda9548933e00e8e01ebe9db4445cd5e5f792c1db554e841c74deb71a4041b9b6c126319e8aac70c3eebd68f6753e8c274b2fde2179c777cff16eac51a3408af02088bcff3aa593e73b1f0240f9bb25db53d7a5b72a6fa10a84f4f9192c5acf8dde714d9aff61b70c16c1874656906c4a7f9a17c694835285e742105033f7067daaa8a09a925d58a730a9ea2e044eeb26bbfd77f625ab395dc31acbe467fcf2ad32f2aeddec63a171779c25277ab4a061e5282aae86d54ff33134770479099e82456761e6e918fe1a85a139a2f1b203c67377597a31b4d9da60709b65e9d40196bea48b732502d4fc8fb51dc97c05d3193eb5c0dd92eb0b8695a0e296ab522c521688f6cc8329a55a3016e65fd1b4293a62c8bc65cdf7c37537a8e5aa58bcfd85845a5e13cdd8a0e20d53b5fff20618d9ceaf34eb2ef132495be5f253d08c4f9c371680806d4c2e931b9aa44fa6818d73b153e3a37b17a0e4fd1cfde1a46bc05c8532948136b573c7fbed4f866bf9899d940836d9f3a44e1b64c298385e255f13be4a49a815cfdfc69d07d26b5a8f336dec24da1f0194f14416557372f14875d3745aefb2ed471f416f9dd96d9e99e2c3ec28e06a9c9af7a3b54e0d2e0380eb5f452927917c1b9fee5d08b2da8c17abf6f1c06055c428d09313444041e3ee10d4e304d6348493f60e399d2d6863c17552d65dfb1714b9988a7474a62f113b10ebb1a254e151e8f965c0e5a55940162cd4a488f2feb549bedb3787b49ad8a816ba789d78dbd1f461ce8d9f2d7c468d2886a6d00a81b2121e4eb857746bbacb9a6b8edea293c64e65b58ea684a3830b98e287c963c7927d1c70094738fe4e3b1881678bc33fac718ff1cd4cbf35177b3301aeaafbcd0103b123f098a69ce23a765ef53aaec82813fb46b48b3aa635c7b3a3d2a7bea6ff06a165e868315f807d76ee0ebb542e4d87348e6c903b0ca3eaddf4d664cce1b6ea7399b27ab783b438227d5e3191641c4635be37b53e72d0891593f29e0670e0f1b428a6015e8907392f742046c475ea194f73450a9789c81ec9662b05d435df57c3a5e006c530044899b6b026dff424c7e968526fec2c30c8be689a87bfbdedd6b6526a24736835852fb0429ee1aeb32d053ae3a323477234c53132cf1756fbef43479f30d01af848237795bddea19a19793ddcb8dabb1827a058af6f2c781bc044b60826c9806646a8fbd9d07733f2547ac44705ff70d5c3dbb1ccd3ca4980a423c625b90a7578f67e32f956ab53e68fe1b53a7d760fca76562b06955c054e6230066bf2d8835e89cf040f2bb3c993cec572fc0c9108b683a0951a389234d9063e1658a19e8b79991918d8fe8c85f77323291ae614366e985d420f6eb49a8adbe93540bdd385c20b4c7e596eac8aa86b0fd81901f5a77a7512ee0db09f985502ee46e6b0c49e315cd92a13535310d2462160bc9556753c02f465332c18d0414c1712018df4ada874de8c070366a12c7ab1b615bb9a690cb9bdccbdd4abca4d2e01c15652058a7e57cd886da0d176187d4f7c059df306eb15d69e7b66a9a0c31cff0e96843c47b0fd9cba544ca816522d31539f60714a8ce6f0c18b6d8c8dcf8aceec6ed5f83d213b49c4ba3d217f0d3eaa3767dc014ad65ca43bd2ee01ba595675b8de6f4932341fafa6d16546b5a60a073d18f11f7cb3d14c534148f3f7f773549f4109969cd282494df7a530513f2729cb4a012c547bb51e74f03c66c74f6c7d7c33aa4b31562603c3271ef99609bedefe8bfc61c8acaec804e98b5bd4e6f9b51f1034549ab3ea417333af624ed0a741a7582a60193c954b6de886409fe5dfde0814214015868950b20fb96579f8b042274c573befc2ea1daed96cfa5a180bab84c5195c99da9321d1c67a9ffc98480745a23b89ef62b9f99c59f9e032364457e23ff439b5dcc8397ef61569123f8562a8426c88840ad36910b9dcccbd1ec7c7552605024ed9a71add937b7f5f281a7fcf0f08291afdb08f74868dc95c2a4cae565016c4375047c9ee0dc8ef72a2ecf2d532192d3d93685cdbd2dd4a5004fc930573b34bb6473cfff8f348a7b40d7131b9aacbdaaeda29d3d811762f812fe12a518a463d818c7a03d6b0506ab78b2117c8af10705f16687cb27ca237e0445549276326049c02f3eb74d1a06d8ad1242cb81a5ce0b2ddbddc4094c5b7a965a986cc2b21529dc67a54c0c1c72d59eb55cd70a92072f1c6ae4885d2ce96769ad1360539c63f37a6cc3c5074e41d02b2cb8903f08b844716f55320094544d56e1c57045d285ea2f4cd69593759b83aac032cf97c4f1dfd945194519aab8b3cacfcdfeb80b23bbd1da76d66d6f4dfeff7803b51517741c38469a2de7bc33073c00dbd1fcff94264c21d5fec987916c14d178f449df77fa6043dafc6e90c338dfce6c34b5802fa5cceaf7df6e54fe1d5c1834b3bcfdeece0350a206e97186a39becf8a76d3dc5dd90826f6d860e2e5bee6f172a9f09fcd76d5d77d89bbd6f79e479bcc1d2faf511a5e164b8b4e876c3054901ec79976f7d09ab42560e3b8558eb18be81a16662335072b32d0349966c94df736227055a5498aa93d33b227165be0bcb4fc19515f9e5fef7f5c2efac444aade0ad7c889aa3abf746bf8fe07cbbacf8ed11caab019f6e7241742c7f3bb6cf2356cd77fa1cb526d9bd188980847e8f72019aafcdc719ee7a7bdc40012723fb267fad2dd6ca98b943bc7d1ac0fe61d3b3388bc514105b36434dc62765a22b9326fa6bdceec0113c4545bbccacdca7ce4d57598d4dc048c8dc18711bb0a9a628e9d10d9c1a71b1496a4aaa0c20dbc38b357674637e3eb0783812bde78c131b0e9303d627c989fd0c49ba4989c488abc786912348e44e998a2bf62703edf9da0d5132a8d25dd62d1fa33043cfcc57df89f6a153fc4b4abedb11059da2b9cab92203d24f81e9f14273ad52360ed661d1ad71af9c351cda3f2f597cecb2043535a78e5d1b050e3ec6a21080af1dca6c94f82b0ebf87a8f05c93795c57471051bb62d31d0710131ade6bfb0ad4903ada2cf3d015aaf8ef46b7c19f929b6976a51318f7ab95e1226c289f067f94099a4c7125411b8fbaa3c230ba97b894e25ff8e30d0008b615dcdf257c5d40b53b5b9b0941e9585051e16120b5a9f6013739fbd38ec5a9d60ffdd5a3d113430838e500568f0ffba16403ba1c35d1b8dc4467bc74f846479384b57f945c7300a7817b738d62edb05e11a8cce0f9d8fe37521688a80a16888bb61ea4990c2bc353d01eb1e43e30cbff964cba4d88804d26fb3de2eee3258825b5cc100fca95e31bce3a3143a043f9e1754c4eaf87c5cef9ee0bce99f29e707cb59185ba21334932ff0d77f1cd1d64206eab1f66021c37abdc827026281d70f7513b464ce1aa88d83f5b2d44010b6b387119d379837c11bb892b26467185d370549c356300b2191a20ce69a1781ed8bf0d9ad35d18616a649e24db5a29152553154199ae3f96b41668007c35f3b6c74fff069a4f2e928cc1b49a575524972cfccf203db12060cbd79ae79912355724bc64663163c19bddcf57d049a01341ac31a2d71da958854f545e8f1156afb091d2eebd6d0d041d9398e367e9b288c45375ad209515b0e9f4fedce5b714cbb8c86be39ffe5264b131ab28e5d6eac2f1207c64e19c26355d25e7a6b24de5659cdb0dff1a78d0a4db7c4b3822d016f5b04bba7a2c4e9a4b3e09636351ca2dd9c11821b690e21a786e7ddec6d04b9212e29b22bd9599bff7b722c5929267ff5e5898cbdfac88b1e4a10c1a7fc60f1302e52acb43bed94c0c6cde82f38b04dac4113ccfd8247d40191e31e9fedc69b9bda1819395316ee4a942d0066f002746331531efeffbb0b5d0443c7f01e1d37e10088dfee5e82677a822490a542244fcd07d961bf6f40524d9a7d81b9c080673ceaf818a99563bcfd041adb4f517189d3a7ac6640858f9bb6618ccd1f530092e64b74890f7ed3922e2d1f3d40a30e7a4b1995d053501a78a995b7ca0b81ae8968c677cc24657edf988b8fa08777c333af926aa82340ec3a32b8b90927c5e13d0ea2cc3338acd9ed71852c044a5dc9f288b637745afb74bdbc822d2bc867f6ae47bb112cd0583d2793e9742a273fb1447a95523c03126f9f7d8a72d60512aefaea5f4bdf7e1c0341600b242c70faf67e4c938a6b44f55a34ef6776583bda66d2c8381919ab659ef19c872a37b11b2fe7cdaf8009a95e826e0edb5941cd94424ce916c8a47f7290cea903af73a61bb07648be39ce41d9de7dfbffa47431efd1186ca2d3413a30eb09b88e25b9f0de4a6f2432903ccacd6aff791aa0e30a3f0d84ef338b7ce415a4190e9cdca276628658082b9885917859cb2c61566df246f0d21d47dbfd7ff13763b08fca462493474766c8e67d185625b25cba0122d3eacea8ad99c4572fdc78d2bd7b39cc3704c28994be8d0057359d886fb4818de74c923a0586b545cda8e03123bc51c2c6e01cd616504f4d2ebb515e4222f7c69f6c2f9fe736533a4dda473c217b45eb99c53bf8e2e351a16e4165f6f9d70c0f623ae12c8d95dcf68e2b0b79c6e9ef51fcef7aadfe27e6fb5642e5a5ec5c6e848168a073eb2e9542635ac5caee84ac6d393526815b9f5f4777d39ace05e7c932eaf65a45cd8e0660d362f47c0663ed9abe63d9ea6bc9f1a592639f3233450c793a6dcf4f4cede38a14bf016da9dea6d71edf50c6dc787c9c4518c11cadd2174e82327be803962dda20f7ca133b9d7315a0e9c15ad117a1c96138951a9db284f4e40ef5cebc9b4c95a05f38d2b938bd7340c5c40c72b166d786b6016165cf081e482be676129c464990f5a9d9f6c08a6748b2ac59ebd7643140995ca30eb6ead5c8eea330f957a8b243b09ce2a5f441fdc4cc0eef6d74d99527b040763039d38611f8cff60b86d4c6ffcb5edd359fe2d68b20801a93b0ce2cd10e5c8073ec758fd8f3c2dfbfab3bd571998fc33b5fee6631a015da519dee4d887964370a14ea7a152a6194df2d5ba7e1ba6499db2f9b15b8e0cfa9bad7c615a7ecc40282d4349880a88c02117d0615639a50e1d0c58d7934e0ca6b099f154712f7be9a1e25c8bb69290c2dab33258ddc91780daf08b82c6158eb002660270b85eb56ad84a9ed684752dbc7066c1f2e0430b09c486312e418e35725837d6c8f2dff90d59f76ffb96fea637b71fc62264f0a421a3f9392ab62b841039e6ff8d208b1b0e4cab8b3c66f1a0af5c9c4405b014dd68d63ef50f8352bc18838605000d1ea120aab8ffeb4f5e2183105c7f4b97553e40d22570a63e5ad2cb4db7cbbc05650ca729ee27b4e71e02e395ec5bf279a218643f20ea49623d5847e69636ad8dadd73b161e481b112c33fe2be8e45826ddf9cd754f1f710b1988d8834ee7cd4230fe542ca6ce5fc6eec7bfbd7a192517d58accb0aca34166f8ad95cc685c7f7f06ea8ca9698d91bc225d2f90d03089ccb4da0eaca0a8f24941a74ec241ea953a6543b0c57d87bde6f150cae4b548b9bdb5c5e344f0d60aab72fbd36c130dd41931318db933395c7fb2e80ad490eeb27160f4d34901a9c795b8c22569ac2fa00f002011f5d6a4ca75439ec92546c196ee147fc3f54bfd01f2df2a7ad31b363f2bb512650ad2459cc3805e67f49bda694c8a06778bf9777fbdaa2279ad10b528702a59f54509860a650a600fb372ce7520848673074751d7d462b73e782faeb136b78ef18bd818d4ba693f347050233c43325e7ff1e2044a53ba6ac10ca24bece8f4e89ec90c45cc3a8492a21f7e967d25dbfa3950a6df035848334b1d13f584a0d6f18bbc62858494faee06412efaafada8dc820cc0f5b9113cf28b16d0cb34c28fe7263c83b56cdd1986300f7f9716f6689f081918f8d4abb2ec38e8eb11a7f825e04c747540d0172dd829dbc99029262fbbe4d3eeb90a6897e6e8a576e7882ef324291b487a5b76b4dfa5f90c6eddb304bcbe1cb61eec2cbd25935bb362dc1caf1f3516702cd031cf515c23e4f8e2dceff686850c9ad7c8c3a75d769ddb91b3143b257666ec752aad1b599f097b92f1fe84ad95140c3d4b49b878c5af2a96de3afbbd14406c5a1262c2b785cf320bcbcf49da5c78025aa6d76b8c12fd788a887606a0fcb89c48fd6370a1480b4dbed8ced504df24fee49f775e1f1f77f0071e9c31b9d549e9270d54f77437710b09df3758376f92dfa0001ec64416d26c857e37a8e4a79d69c90fef6902d6c6302d2673fd6734f0defbc88189edf4edf30d736e1deffbb99ce4adf2f780caed6a5099065294bab051d495564f390bf4927d99163cbfa74a84d41595728646230367105165c77e97f0c827d7f1ce7387002b3263e8c5734b169a75fde458fc705b15cf5ff42572b49b1ed98cd588056d3171a418a42a72114029ea72624b1a36fc7fbb81548bec8435c90c91341b161af26c3f444e76db6583ab29c68d71f5feb92e3a658be8e4ab94d9243102e115b2155d28dc858c1f0a8ab30db62de0b650fadabe562908b6d0d01ec1e08ad04b2d935912059c8dbeeadde18e95c740d60d8b2e92193b668cbe7c387f2bec3d375e3cf4423802ff26bd4252d56f67b0bd59681904837328fec83308790f95ccd432ff1cbf4b4ce700a6fbee4adbf8501b0d6e97e0f93440ed1a3aba7cb98305121fe714f973dfd79c8875ca2375d1a376dee5c71bc9df23a0665f2e9dd6c9fe46c12d95b7c562284208e56f7c705f2dfbc26e76f6e20f030b2b60b7f8a16072d78ac9fc59b5d59a14dd6036c290b74de01920cc7c618b12b3510bbad22b5d80c6261d31d2d83fd7d7770bdbfce514e7f6f7594e6eaef649e56b874585ef088504f4b13c285f26af5ee1dd5d9f2239996e9342c1d26d7ac6182f73676deffd084e45b7d3f550a31840a344cac7a8f00a0cc792d2be1da638b78d43161c344893eb239277dc92c0da4d2363ffb76055d1ec4a3fc135ad99df1cef3c1722cd0f39627a16647b1587a5f756cc3fc939900bc7d81a288f9d77bae6be7ab14fa1219cb430e98e895e614d90c9ee9501298828af8cc3a2ab69f44e1f7fb6b703a2ac5c6cda1149fe5cf455371c271369890bd7244aaff6aab6fb405e55b149f21d116e4388004ad8be3aa77238c825ec14cde78e60be0dba444bdc3de93d94a71770f18369395ca29887bb9b4156dd5149cd1b52a882aedc1dea85a6a9bc871325b62431ad3253c544e40c0382f8985ffd533ce65ebec4de37567016553290a056764446f3e017e85ad4eca07246866cfaf24225772a6bca69f180183ec096d2d51a60f763608d54ba971804997993d042244d0a5fbb3cda8a283eee3d4cf459802b606fd0a581aa8f1bb0b999af898d629791ffe60038422a13f46b32f54a2b19a8308b9e310855d656e96b3f304203448ce0a5ec4ec7e59fa9a4c0f15eb1c74fd4b523de4ad25bb273a5337065cfd57fb0138ea76eb8d045ca801ac0f46f7321dd6b768781789ff96901123bd95086333956016330c4514674b909c885d6e9c4ab612a613bb329641cd074d4a8ff3c8ca79b49ff82144b25ec66d7c82874485992a6489b0a220fc635627968c322df49a0fa3f73946550caef34aaa1343b61478cea7d677fb65d5c1d4d832f00035d7a51789ee8cc00e8dea88b1bcf879d24b2bba7ee426f95875522151732ab729d04e89278dcceec88286ca7faf31f6184e9065a814cfa3f66bbd098817f9dfa541fa76be89b9746779714e114625563bdf6b2d3ece37a900f3dca915dde59b02a03d003989d5aaa4eeb031a550bcfe1e182856d6bbb38dc2f23f7c1d98d85dbebedd94b012b2f7cc78fc37ce6ec604efd1367e0c599092debe69b8f1dd17e990694235bbded6156f0bf410e096d5d3e58a56a8c408fd0933539df1ee5ecbd2e02e9cbc1a4fd8b62985c98e4af30739030fe290be5699d7eb5a4c696e917d7b845403ce8f51e6578f154a180c992d2a5a62dfa6cf5ade3717d6e235555945d361058020ce5fa631db3cc66b3b4da57c956e967f140688d5210cee299ec785b1d18fd18345f2d6958093c596cc756ea0f5aac3c6909255282103bef545e0c8acd17ce85e4fe15be50af2e16b3f3d99a757e08c435e2ef599916552f55feff98dc070a8370162ae5957e6344206aa14a608721f2a1a51188e4a34b28d7046912f43ee30427660e437d1ee3edab1c3ec3771383ae82cdc5d78ee6b30c0d5f8d8ca6f2bfb626ddb88c3d5cbb139454bea985d281c141c27f2cf9c998b640bfd2e68eee341e699478b73fbe9ed89a92878a9fa61590fbec6ef6499d463c477ae03b456e4b5c862dc0519b725e8398c4b2bbba85bb68675a2193c55599faedcdea8685e7b99c15e5fd8d925065515f769a4e2568f18ec4cf18e0b64582893e0bd22da66dbb023c61f7ef341bc69880b603c99db287ad84f16b5ce29c9032ca47ba21e1d34c98c00a8b4d58a87549815bf7ac6af1602668828cbf3666cc524885b8924e3863ccff69b75a7e691c18a4a78a68885ce8c72cb7dc7e8898e6a2e7452d473f089ec75231caeca737225a15923f8b79ceca51e25f062ab2e0dcef228afed317ee77275c69d5294af19090b3b49d8e799ec32b7341af25e3eb96c27f0482c16268bd8dc69372445348a23ccd0d8ef62553f65b3c09af8f352d547e454389328233f0b14d31f5f34850917ec6aa63a71918e6a9f46e684d3f10c4bab8818bb74e8bf8031b2df734023792e8f1214c1c039bb90ed6639a08b105a9d2b9d47dc57ba7a0a31095bdd3dd394203e0d6386085df4890cfae8736d24e379808755a7fec6249e1ca2d450db2c514452a6de8a550d8fb9b961cda385b589c3d8c48bdfd2a47849d8350dfd82f97adabd430f02500a0c875aae702a131f55cc511aa4389d155213633c5e4b3ef5605d47cf8c3256484873aeca7a3b02a2aa336ef6d73049ccba5d225e6f8a2e2bba6a573dc9c4756ecd0cced7f6002d74f2ec399863993e2bab13448d6012e82f8470d3b54fc18e47ccbf383fafe6fe2d0ffe7ff48db008d22595cb2d081ec0e55c93a80da2be437c4fcbe4c00ed98db64559e90c4a3aff9a840bbabfcc8f3929c28d473c85e228a485c9609ce9161a2ac2faa3164ee4e83eb4eb14d4dd55e6458db349275f011d2da2231032db25ea83849cf2d5f70cbe62c7022cc639ae9783d16de8e6bee35d6314fbbac92b0cf6b3fcaa35ab41db862bc3646a5fdadf95c619b36dc306a23676d105a6df42625ef7913f07d219fbed166e4da758fedbacf1855d1935c2b3205eeaf6ec158200b48d72aed0a9a37176031072ae813cc8a48af6caf83db26eed25e088edaa30b0c95c8db30d9c187a4c73abb388686bc60848688c700941928a1ec4c64636ab52fc38f3ec0343b3d3a2b26f109679037e57a36ead18a8e2b15ae0399b19d223444a1709f1d5759129b9f18b239d8c675283fab7997eb2266662c0748535b120d3a67695d3f8000c20b44b4bbf3a5af0387b3d2be76414b1eb4074094e150dbee6e4b58d5a32ae2c8bfb9fd5026d7cf32d8a01f855d478efc61b1b115f05e5efdc907e3eac3211bb148ce424da97f5c857b8b3743a2e56142af6968629bb73e9c8fe9c71b9e9b2f557640af78a54132bb244d283f002315fc33343127d560a447cc9836e6cf5432f60ca68cbfacedadab04055e7a02f2cda068bb5d1d9180323b51485264864a44fcdfecc5bea7e3b5adb9bb69fd8e612d4944de2506db16444dac0cb1617c8b00f768d6e3dd833d2291c398ae5e68638ba7f465535b537eda04a19353ac0818880721a90ce072bfbd2cbd1b29e6176d5d16e378dec73acc529281d8029a79664c2b09ff81f963cdeb7ce00e01a2bc947055000db2fa594cfd33dcbb30dd59e053dcd4a09f77cb289118c265e627597796232fbf8302fc9f252e194df1be5bf71d69a7e6eb699133f831e17b9b0b427426c68834638e65ef5ac6dcafd6c24075fb7da34dcbad8b26941d520a78139012cb6a991a39207c643d3560fb02e2ab75c27a0ec7b8a5ea1fa08fdfe9ea31f783ca8e79c4b33efea5483f30d217636ce12a0217d70cc498cb4ec38295fd5e991283cd051aa117d4caea11903c521b5cc5cf7faa5ef34d0453a743767c2c553403f98260923c9949d8d72fb4ddd6d1a6bf936338b1ac4fa0fb5d7fd06e827363f7a876e8edbf58d7ab9af2de2a426c3b919bcb33889659a8888a96469c80df15e76818e61827fcbfe0d67090160aa846fda42e65431ec885399406c4922183d3cc04640cde67ed7c5d13cb63e57213b91d7c7738b6cab637e943b0c418966df060486ecba67866d545b020b84b61d3f616db1834ec40d811a683102a33f0e0ae178a9488325bd392d9ae9a179083db2fe91e63a9cde631e56a334f079f4e97639889c67ec5c716923b0ad7660c6b81974dce4d744ac556ffbb94da56e7297952ddfa870414a6ddcff1ee91ddbf3bfdbfcf332092fe433504f366c1a9142ad36b9fcba8f6dc28662819f0d10e18dc4d835c1be4feb16987aabec9cdb32441a6fdb6aa69052898813af44419ab34c77bdf86f5bfbd9a0be7c9a53b4d6cb43937e4e051bd85ea4e0b3454d214eecd42bf729a2677d7dd1a5deedf63eb81db9329f5a812ae1404cfcb282c57d25b5a9116fca749bb8bc3ff958af54e9305be54ed080317a87a9917fa1e38b1e4a696866ca0b13dc8642ce8a56562f939549094265e01ccd5583b67a29c91d69db5c0584a6cf8dde1fc78d2e37222efa85d12957c61f1a38ee2f88e973de4947316e26d2300acbad9f58d90d2d0089c55290b09c52cff76af5c4de85a937acec4aa6a5d7d420b7bb5e608c412222ae4f93cd325fe43d6b67c60cc6fea722c589e71b2c000a2845141a4d3f6353a868437a8d9b4530be2efd5f39c0a9ad6c784aa3dcae079589807b42e22a3d02cac8beb342e7528c39b9cf314a694778ac8d29270f6291da158711c32068946b6d921489fbcfa1372e036593780c450e93f463247e4ec8e2bc788c2d67c320d6aad79ed65e9fe96369bca07fb0ae94106f237c80677095b872c9b0b7b35424f8f4a11914a9b99428ecddc76857c7d12e33070923d7ad476e2096b7e55d08ea698abeb1f5e52b0a21961f08d2be933a26bbc338ebfbd0b91073fb791e95e2a8ce9d4b646dbf76f6aa98f94e1bcc89d131cd777710db72a6d7de86428f2f0ec16532cd045f8299afaabbae21ad50cdf42e32f94b084f24f88f5edceae13b05dcf7e42b8033ec4da5f85d9d6afd6a340f3d904ace82c4dcc18b456f7e53d59117aa59f9a1a5d502ecea66c53c3bca8da743da4d6306d910d0afff69520a86e26f9f357c45f21db8472b1ed027a84185c48572b659a63b3377ef03be3eeba2921a04c0b8300efe796fc0da364ebb761cb9bd45cdb001175277fcccda8fc8108fb18e8977a4c91d46b3371b6a0d3580f99a15f409b053893eefbb9ebcecbc302ec5b544b938ff414528d9ad94533c7f055960178a394d5e92bd7cf6fdd7b32c027b779c1fc565264797bc21763c6e38c43c19bba54be628dba6cc82cc8a73dede63ec261913b2c089da223902945d8875d6934f1a2bad1bcc993d61815113be058c04505bebe015a07ec61c2a3c68ca4edd2928db61ec5dd8d80c4cfff5b00d0de09e412d22c23c2c8ed4b2bd41beec79035f39a6728f49623f9f8f3bcace331876049f1fafe329bd86188e00b768a775ef896ebc52ea111ddd7d5c4f5163366cc40da8bb027417ff735834adb965703cb212a8654e9ec85cb8b010a06cbca124719f1c8bf5cb394c6a0c5539dca1ecb7262d046b0fdeb1b748bf39a3da3db9d17a0b10be30ec52e8d9591cb354fe74e004b0e0386f51d29821e6dd984ba51f970eea57266b49447bb27f6e5d62c2ce294dadd2b9d82197fb93a6bbed78bdf780e8ec5f7bdaa6337e254c047372a36084225f44f688dba02bb99b4d051d1082d64e90da3c262a6db3a7d8eac64aea35db92ac9452b83525ee3d2b29f876a37ef8890ebe428dfd8569488dd90e533a5be267a070adc6e0e206453d78be5b186b60a05002bec43f68e251ab1a1ba45af5912153dab10998ff34850d7101fc4faeb86fccfdc1f65027f791a23d276c175c1bbef0850f4eab09b1ac01cc2cfbffc1646ffbeef3bc85b5bad9c624330d2a3c9ccdf5994ee6975f3288fb6fcfa192b480f38b74387444235c7a7f883d813f64446c3189906eb0429fe05bb4d8848447e02162b5a1e595e3d135944facaaca0dd81116faa13b80b330a27946a32bc1a383b225077b7bbddab1ebf4a9645d94169a6126f2f25dd7ba7a36c30919859c3956fbb6a3cec7c8d23510af5923c3e9e80b689ced26a4f04e98e20b85ab2a71c71f8daf9d0362ee77f8d0694a43ad9b30b05f081edd9d5ed984590e6bd6e0303d97bf0852881a1b96b953835fd9547851adce2a049da100e34efbc4e139a0cad7f601513b2c9fb74e570211213f4ae904c588b27cb8bcb1c31ea4e9aa2cd771a3c809e98b2f1b6dd9204e8d58042a74a5c9de16d663d386364c13e4c579fe81189c44b9a58abf469aac53527344ef3b96073aeed599dfc8320c3896665a882f9d3cd4a1ca1804c5f838efd7f9d7f9328ffdf43d3c619cf85ef6b37d9d443b31c48ce81ef2ac29a78dd81753e7c284cd16a0a32f81a3bb9d6d5beb6f1d23445881bbe402db501da28743951eb0eac50691e1c2522cefe0ee5a91cfb7de673f77c425674c0d64011c84eb0444ca198806dabc61ac10fc34790e75d3c84e8328e499d045fea79ccdb088301eab72294ea5bef584292a1193964931e402f97d8fecfbb6a76810fe7e48a13b86d724ac0abd98ac8e1375d9532621336f7db7259fb6824ee679652cdcde5f92c13adfa021c4da6b9dd6b6c0a5e055638066c8b51d5a490f8b07d96b523049c6a0a76b0aee069434f6b9ad04130c1281b6467e41216719a6d68094a3fae44be8d26f143c14196faaa9b5eebf20ecf3125f3ffa92163ef50a1ce1c652fe73ae073c3fab0ab59bdf1896e25f486ba85cb5b00fa8ac2cd8de5209dad61cfee308ab9dde45f4e6fef6d30ec0b6a946248f76417a9223e75585e52d299f762c8e0a641e2aa3b12e84f79db99c1e296ce7677e6818f83341b9fe669cc74e6fa02833fffc09acfd190eead2d527836db552758cafa42f4b5c7f73d5da136efec5d7ee4b50ff651f781f99dffa654a6b1ca5ae6c4697efbb9ba5f32c347b9d5a9cf8369451955524007773efe1a9836862c9c17aab4065c02fc83764781f79e3562bc01135293880665abb388e5311b57a35ecf9bab446d110c77aa84a2ceddcce44984bce14985f280236aa2920f5008926a1d739c0c8aadca2ee786e5cea56767867383ddc16d5ab461773d269b801cfc914cc1ac50af78765d4c87c27b1ace823c0ed4e698d016a68244bc8b60ce1c9b89628db9dd0dda98db2a01105a1b10f9880458170281c0aab9b88fc30d90f9e338bcc0bc0af51b74c9c3fab74257147e919847e585030cece7e9b31e7bf8c329f9ce9b6be9b90800ae793f6d48f991b5e577fa11f6d90b331350f51a47911001e55432de696b402260fbd3482ebcc197ec287f67e371bbf80c0488f5050afffd8f47fd939139157cc4ee997d1c7db96bff4b0b4a4172aefda267bdfcc260caad0a45cb0abfb79281936957099cc407fe2f3a0cdd6d95603f67d6a6aad0a59b22b24e40d0b37136cd6eaafa621fdda965c3a503502c8a542f64c8d2f0235ec076d617fda41376114d2d4868dcaf0c8288d9dd499b28f21798c3d21088fac45633cf7ad9328f99d7c64e83a3fa27c0523134e060c094b7962336f0f3510541de43fc8a8509e19043a6cc7af00ab39fef0b7764b5c05a405746c7550cd5eeedd0d0aaa6b3536b95dfe36898b928b6250cffa5fec7e5566904fce842a27e911da0b241f74cf9557e7db86e0fcce4ac4c6da6aecb517ed945a8509e495eab3ee0f69be3075aa6ce8fe78533f2cc7d3c3dc518d72431452d2f3c9c89e7e0877e3744dfa2b70c9ec51ef7e575e0ebc9312ae50acc1ace0c50e387986cf9e2dcbc3bc1078ff79e08fd0eb6f3d91f82974c27468852ffb5a0d927f5dfa6c9c86fe9f099f6562b263ae53134a4b47eb405ab213d2b74e5118fadf5560ef7f3d51c2fefa2f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列-lc1143</title>
    <url>/2019/11/07/20191107-lc1143/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p> </p>
<p>示例 1:</p>
<p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:</p>
<p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence">https://leetcode-cn.com/problems/longest-common-subsequence</a></p>
<h2 id="思路-实现"><a href="#思路-实现" class="headerlink" title="思路&amp;实现"></a>思路&amp;实现</h2><p>本题属于典型的动态规划题型，可以通过动态规划快速解决</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">        int[][] res = new int[text1.length()+1][text2.length()+1];</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;res.length; i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=1; j&lt;res[0].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-1)==text2.charAt(j-1))</span><br><span class="line">                    res[i][j]=res[i-1][j-1]+1;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res[i][j]=Math.max(res[i][j-1],res[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">return</span> res[res.length-1][res[0].length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:</span><br><span class="line">        n, m = len(text1), len(text2)</span><br><span class="line">        res = [[0]*(m+1) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+1)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1, n+1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(1, m+1):</span><br><span class="line">                <span class="keyword">if</span> text1[i-1]==text2[j-1]:</span><br><span class="line">                    res[i][j] = res[i-1][j-1]+1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[i][j] = max(res[i-1][j], res[i][j-1])</span><br><span class="line">        <span class="built_in">return</span> res[n][m]</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>lc中等难度题，主要考察动态规划。思路清晰注意好递推条件可以快速解决。</p>
<p>本题还有变体包括：<br>1、输出公共子序列（任一）<br>2、输出所有公共子序列，并按照字典顺序排序（dp+回溯法）</p>
<p>其中2为高级算法课的课后练习，还涉及回溯法，很有学习必要。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列-T3-1</title>
    <url>/2019/11/14/20191114-T3-1/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定两个字符串，返回两个字符串的最长公共子序列（不是最长公共子字符串），可能是多个。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入为两行，一行一个字符串</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果没有公共子序列，不输出，如果有多个则分为多行，按字典序排序。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>1A2BD3G4H56JK<br>23EFG4I5J6K7</p>
<p>Sample Output 1<br>23G456K<br>23G45JK</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    //recall and get the LCS</span><br><span class="line">    public static void printLCS(String[] num1, int[][] path, int row, int col, String cur, List&lt;String&gt; res)&#123;</span><br><span class="line">        //the end condition</span><br><span class="line">        <span class="keyword">if</span>(path[row][col] == 0)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(reverseString(cur)))</span><br><span class="line">                res.add(reverseString(cur));</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(path[row][col] == path[row-1][col])</span><br><span class="line">            printLCS(num1, path, row-1, col, cur, res);</span><br><span class="line">        <span class="keyword">if</span>(path[row][col] == path[row][col-1])</span><br><span class="line">            printLCS(num1, path, row, col-1, cur, res);</span><br><span class="line">        <span class="keyword">if</span>(path[row][col]!=path[row-1][col] &amp;&amp; path[row][col]!=path[row][col-1])&#123;</span><br><span class="line">            cur += num1[row-1]; </span><br><span class="line">            printLCS(num1, path, row-1, col-1, cur, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //caculate the len of LCS by dp and recall the LCS</span><br><span class="line">    public static void deal(String[] num1, String[] num2)&#123;</span><br><span class="line">        int[][] path = new int[num1.length+1][num2.length+1];    //take care of the length of the res</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;=num1.length; i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=1; j&lt;=num2.length; j++)</span><br><span class="line">                <span class="keyword">if</span>(num1[i-1].equals(num2[j-1]))                 //the length is different</span><br><span class="line">                    path[i][j] = path[i-1][j-1]+1;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    path[i][j] = Math.max(path[i-1][j],path[i][j-1]);</span><br><span class="line">        //caculate the len of LCS</span><br><span class="line">        //int len = path[path.length-1][path[0].length-1];           </span><br><span class="line">        //System.out.println(len);</span><br><span class="line"></span><br><span class="line">        String cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        printLCS(num1, path, num1.length, num2.length, cur, res);</span><br><span class="line"></span><br><span class="line">        // Set t = new HashSet(res);</span><br><span class="line">        // res.clear();</span><br><span class="line">        // res.addAll(t);</span><br><span class="line">        Collections.<span class="built_in">sort</span>(res);</span><br><span class="line">        <span class="keyword">for</span>(String s:res)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            //other dealing</span><br><span class="line">            String[] num1 = scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            String[] num2 = scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            deal(num1,num2);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //reverse the String</span><br><span class="line">    public static String reverseString(String str)</span><br><span class="line">	&#123;</span><br><span class="line">		char[] arr=str.toCharArray();</span><br><span class="line">		int middle = arr.length&gt;&gt;1;//EQ length/2</span><br><span class="line">		int <span class="built_in">limit</span> = arr.length-1;</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; middle; i++) &#123;</span><br><span class="line">			char tmp = arr[i];</span><br><span class="line">			arr[i]=arr[limit-i];</span><br><span class="line">			arr[limit-i]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> new String(arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>本题是同类型题目中扩展的比较大的情况，比较通常的情况是求LCS的长度或者一种情况。</p>
<p>所有情况的解法可以看成两个部分：<br>1、创建二维数组path[][]通过动态规划存储从path[0][0]——path[n][m]的所有情况（LCS的长度信息就存储在path[n][m]中）<br>2、通过回溯法从后往前回溯path数组，并在过程中维护一个str用于存储LSC（具体方法是在path增长的那一个结点获取原字符串中对应index的字符）<br><strong>注意点：（1）从后往前回溯获得的LCS是反的，需要在存入时进行反转处理。（2）要避免LCS重复的情况，保险起见对结果list去重。</strong></p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>链表回文-T3-2</title>
    <url>/2019/11/14/20191114-T3-2/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>判断一个单向链表是否为回文结构。自定义链表数据结构，要求时间复杂度为O(n)，额外空间复杂度为O(1)。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个值为节点个数，后面为每一个节点值</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>是回文则输出true，不是则输出false，一行表示一个链表的结果。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>4<br>3 1 2 1<br>4 1 2 2 1<br>3 3 5 3<br>6 a b c d c a</p>
<p>Sample Output 1<br>true<br>true<br>true<br>false</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            //other dealing</span><br><span class="line">            int n = scan.nextInt();</span><br><span class="line">            String res = scan.nextLine().trim();</span><br><span class="line">            <span class="keyword">if</span>(res.equals(reverseString(res)))</span><br><span class="line">                System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //reverse the String</span><br><span class="line">    public static String reverseString(String str)</span><br><span class="line">	&#123;</span><br><span class="line">		char[] arr=str.toCharArray();</span><br><span class="line">		int middle = arr.length&gt;&gt;1;//EQ length/2</span><br><span class="line">		int <span class="built_in">limit</span> = arr.length-1;</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; middle; i++) &#123;</span><br><span class="line">			char tmp = arr[i];</span><br><span class="line">			arr[i]=arr[limit-i];</span><br><span class="line">			arr[limit-i]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> new String(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>按照题意单向链表解决本题，则需要先用一个快慢指针找到单向链表的中间结点，然后逆向前半段链表后一一比对。同时也是一道lc的原题。</p>
<p>但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序-T3-4</title>
    <url>/2019/11/16/20191116-T3-4/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>实现插入排序。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出排序的数组，用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>13 24 3 56 34 3 78 12 29 49 84 51 9 100</p>
<p>Sample Output 1<br>3 3 9 12 24 29 34 49 51 56 78 84 100</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    static void deal(int[] num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;num.length; i++)&#123;</span><br><span class="line">            int tmp = num[i];</span><br><span class="line">            int j=i;</span><br><span class="line">            <span class="keyword">while</span>(j-1&gt;=0&amp;&amp;num[j-1]&gt;tmp)&#123;</span><br><span class="line">                num[j] = num[j-1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            num[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num.length-1;i++)</span><br><span class="line">            System.out.print(Integer.toString(num[i])+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toString(num[num.length-1]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            //other dealing</span><br><span class="line">            int n = scan.nextInt();</span><br><span class="line">            int[] num = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            deal(num);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>八大排序之一，比较简单，每次选定一个序列元素，向前找到合适自己的位置将它原来位置前的元素都后移一位后插入到合适位置即可。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>链表区间逆序-T3-3</title>
    <url>/2019/11/14/20191114-T3-3/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>将单个链表的每K个节点之间逆序，打印出新链表；最后不足K的节点数不需要逆序；要求时间复杂度为O(n)，额外空间复杂度为O(1)。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个表示链表长度，中间为节点值，最后代表K。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出的每一行为新的链表，节点值用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>2<br>8 1 2 3 4 5 6 7 8 3<br>8 a b c d e f g h 4</p>
<p>Sample Output 1<br>3 2 1 6 5 4 7 8<br>d c b a h g f e</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    static void deal(String[] str, int n)&#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        <span class="keyword">while</span>(flag+n-1 &lt; str.length)&#123;</span><br><span class="line">            swap(str, flag, flag+n-1);</span><br><span class="line">            flag+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;str.length-1;i++)</span><br><span class="line">            System.out.print(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(str[str.length-1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void swap(String[] str, int start, int end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            String tmp = str[start];</span><br><span class="line">            str[start] = str[end];</span><br><span class="line">            str[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            String[] tool = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            String[] str = new String[tool.length-2];</span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;str.length;i++)</span><br><span class="line">                str[i] = tool[i+1];</span><br><span class="line">            deal(str, Integer.parseInt(tool[tool.length-1]));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>按照题意需要两个指针每次一个不动一个移动K位然后逆转这部分链表，如果剩余链表长度不足以第二个指针移动K位则不进行逆置并结束操作。</p>
<p>但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序-T3-5</title>
    <url>/2019/11/16/20191116-T3-5/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>实现冒泡排序。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出排序的数组，用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>13 24 3 56 34 3 78 12 29 49 84 51 9 100</p>
<p>Sample Output 1<br>3 3 9 12 24 29 34 49 51 56 78 84 100</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    static void deal(int[] num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=num.length-1; j&gt;i; j--)</span><br><span class="line">                <span class="keyword">if</span>(num[j]&lt;num[j-1])&#123;</span><br><span class="line">                    int temp = num[j];</span><br><span class="line">                    num[j] = num[j-1];</span><br><span class="line">                    num[j-1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        //deal with the <span class="built_in">print</span></span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num.length-1;i++)</span><br><span class="line">            System.out.print(Integer.toString(num[i])+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toString(num[num.length-1]));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNextLine())&#123;</span><br><span class="line">            int n = scan.nextInt();</span><br><span class="line">            int[] num = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            deal(num);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>八大排序之一，比较简单，略。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序-T3-6</title>
    <url>/2019/11/16/20191116-T3-6/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>实现计数排序。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出排序的数组，用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>13 24 3 56 34 3 78 12 29 49 84 51 9 100</p>
<p>Sample Output 1<br>3 3 9 12 24 29 34 49 51 56 78 84 100</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    static void deal(int[] num)&#123;</span><br><span class="line">        int[] tnum = new int[num.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num.length;i++)</span><br><span class="line">            tnum[i] = num[i];</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;tnum.length; i++)&#123;</span><br><span class="line">            int count = 0;</span><br><span class="line">            int same = 0;</span><br><span class="line">            <span class="keyword">for</span>(int j=0; j&lt;tnum.length; j++)</span><br><span class="line">                <span class="keyword">if</span>(tnum[j]&lt;tnum[i])</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tnum[j]==tnum[i])</span><br><span class="line">                    same++;</span><br><span class="line">            <span class="keyword">for</span>(int y = 0 ; y &lt; same ; y++)</span><br><span class="line">                num[count+y]=tnum[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //deal with the <span class="built_in">print</span></span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num.length-1;i++)</span><br><span class="line">            System.out.print(Integer.toString(num[i])+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toString(num[num.length-1]));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNextLine())&#123;</span><br><span class="line">            int n = scan.nextInt();</span><br><span class="line">            int[] num = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            deal(num);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>顾名思义按照每个元素大于（小于）所有元素的个数确定该元素的位置，用count记录，然后直接将该元素放到最终位置，需要注意有重复值的情况，用same记录。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序（递归&amp;非递归）-T3-7</title>
    <url>/2019/11/16/20191116-T3-7/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>实现快速排序。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出排序的数组，用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>13 24 3 56 34 3 78 12 29 49 84 51 9 100</p>
<p>Sample Output 1<br>3 3 9 12 24 29 34 49 51 56 78 84 100</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main&#123;</span><br><span class="line">    public static int partition(int[] a, int low, int high) &#123;</span><br><span class="line">        // 三数取中,将中间元素放在第一个位置（优化效率操作）</span><br><span class="line">        <span class="keyword">if</span> (a[low] &gt; a[high])</span><br><span class="line">            swap(a, low, high);</span><br><span class="line">        <span class="keyword">if</span> (a[(low + high) / 2] &gt; a[high])</span><br><span class="line">            swap(a, (low + high) / 2, high);</span><br><span class="line">        <span class="keyword">if</span> (a[low] &lt; a[(low + high) / 2])</span><br><span class="line">            swap(a, (low + high) / 2, low);</span><br><span class="line"> </span><br><span class="line">        int pivotKey = a[low]; // 用第一个元素作为基准元素</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123; // 两侧交替向中间扫描</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= pivotKey)</span><br><span class="line">                high--;</span><br><span class="line">            a[low] = a[high];</span><br><span class="line">            // swap(a, low, high); //比基准小的元素放到低端</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= pivotKey)</span><br><span class="line">                low++;</span><br><span class="line">            a[high] = a[low];</span><br><span class="line">            // swap(a, low, high); //比基准大的元素放到高端</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = pivotKey; // 在中间位置放回基准值</span><br><span class="line">        <span class="built_in">return</span> low; // 返回基准元素所在位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void deal(int[] a, int low, int high)&#123;</span><br><span class="line">        int pivot;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">        stack.push(low);</span><br><span class="line">        stack.push(high);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">            // 先弹出high,再弹出low</span><br><span class="line">            high = stack.pop();</span><br><span class="line">            low = stack.pop();</span><br><span class="line">            pivot = partition(a, low, high);</span><br><span class="line">            // 先压low,再压high</span><br><span class="line">            <span class="keyword">if</span> (low &lt; pivot - 1) &#123;</span><br><span class="line">                stack.push(low);</span><br><span class="line">                stack.push(pivot - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pivot + 1 &lt; high) &#123;</span><br><span class="line">                stack.push(pivot + 1);</span><br><span class="line">                stack.push(high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //deal with the <span class="built_in">print</span></span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;a.length-1;i++)</span><br><span class="line">            System.out.print(Integer.toString(a[i])+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(Integer.toString(a[a.length-1]));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNextLine())&#123;</span><br><span class="line">            int n = scan.nextInt();</span><br><span class="line">            int[] num = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            deal(num, 0, num.length-1);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    //swap</span><br><span class="line">    public static void swap(int[] a, int i, int j) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        temp = a[j];</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>八大算法之一，利用栈实现非递归的版本，首先需要掌握常规的递归实现，将递归语句替换成符合运算顺序逻辑的入栈出栈操作即可，需要注意的是入栈出栈顺序。<br>附上常规递归版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//快排递归体</span><br><span class="line">static void quickSort(int[] num,int low,int high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    int mid = partition(num,low,high);</span><br><span class="line">    quickSort(num, low, mid-1);</span><br><span class="line">    quickSort(num, mid+1, high);</span><br><span class="line">&#125;</span><br><span class="line">//每次将一个元素放到它的准确位置上，返回它的index</span><br><span class="line">static int partition(int[] num,int low,int high)&#123;</span><br><span class="line">    int tmp = num[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; num[high]&gt;=tmp)&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        num[low] = num[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; num[low]&lt;=tmp)&#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        num[high] = num[low];</span><br><span class="line">    &#125;</span><br><span class="line">    num[low] = tmp;</span><br><span class="line">    <span class="built_in">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>分配问题-T4-1</title>
    <url>/2019/11/24/20191124-T4-1/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对给定的n个任务与n个人之间的成本矩阵完成成本最低的任务分配策略。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入：第一行为用例个数，之后为每一个用例；用例的第一行为任务个数，即n；用例的第二行为使用逗号隔开的人员完成任务的成本；每一个成本描述包括人员序号、任务序号和成本，使用空格隔开。人员序号和任务序号都是从1到n的整数，序号出现的次序没有固定规则。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出：每一个用例输出一行，从序号为1的人员开始，给出其分配的任务序号，使用空格隔开；使用逗号将多个解隔开。结果按照人员分配的任务序号大小排，第一个人员的任务序号大的放在前面，如果相同则看第二个人员的任务，以此类推。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>4<br>2 1 6,1 2 2,1 3 7,1 4 8,1 1 9,2 2 4,2 3 3,2 4 7,3 1 5,3 2 8,3 3 1,3 4 8,4 1 7,4 2 6,4 3 9,4 4 4</p>
<p>Sample Output 1<br>2 1 3 4</p>
<h3 id="java-回溯-基本数据操作"><a href="#java-回溯-基本数据操作" class="headerlink" title="java-回溯+基本数据操作"></a>java-回溯+基本数据操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class T1 &#123;</span><br><span class="line">	static void distribute(List&lt;int[]&gt; t, int n) &#123;</span><br><span class="line">		int[][] matrix = new int[n][n];</span><br><span class="line">		int[] temp = new int[n];</span><br><span class="line">		int minCount = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">			temp[i] = i;</span><br><span class="line">		<span class="keyword">for</span>(int[] x:t)</span><br><span class="line">			matrix[x[0]-1][x[1]-1] = x[2];</span><br><span class="line">		List&lt;int[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		change(list,temp,0);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int[] tmp:list) &#123;</span><br><span class="line">			int count = 0;</span><br><span class="line">			<span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">				count+=matrix[i][tmp[i]];</span><br><span class="line">			minCount = Math.min(minCount, count);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;int[]&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(int[] tmp:list) &#123;</span><br><span class="line">			int count = 0;</span><br><span class="line">			<span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">				count+=matrix[i][tmp[i]];</span><br><span class="line">			<span class="keyword">if</span>(count == minCount) &#123;</span><br><span class="line">				int[] t1 = Arrays.copyOf(tmp, tmp.length);</span><br><span class="line">				res.add(t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//print</span><br><span class="line">		List&lt;String&gt; res1 = new ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(int[] x:res) &#123;</span><br><span class="line">			StringBuffer sb = new StringBuffer();</span><br><span class="line">			<span class="keyword">for</span>(int i=0;i&lt;x.length-1;i++) </span><br><span class="line">				sb.append((x[i]+<span class="number">1</span>)+&quot; &quot;);</span><br><span class="line">			sb.append(x[x.length-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">			res1.add(sb.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.<span class="built_in">sort</span>(res1,Collections.reverseOrder());</span><br><span class="line">		String p =<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(res1.size() == 1)</span><br><span class="line">			p += res1.get(0);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(int i=0;i&lt;res1.size()-1;i++) </span><br><span class="line">				p+=res1.get(i)+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">			p+=res1.get(res1.size()-1);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">		int testcase = Integer.parseInt(scan.nextLine());</span><br><span class="line">		<span class="keyword">for</span>(int z=0; z&lt;testcase; z++) &#123;</span><br><span class="line">			//scan.nextLine();</span><br><span class="line">			int n = Integer.parseInt(scan.nextLine());</span><br><span class="line">			String[] tmp = scan.nextLine().<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">			List&lt;int[]&gt; t = deal(tmp);</span><br><span class="line">			distribute(t,n);</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static List deal(String[] tmp)&#123;</span><br><span class="line">		List&lt;int[]&gt; t = new ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s:tmp) &#123;</span><br><span class="line">			String[] a = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			t.add(StrTurnInt(a));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	//turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    //回溯全排列</span><br><span class="line">    static void change(List&lt;int[]&gt; list, int[] temp,int start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == temp.length)&#123;</span><br><span class="line">            int[] z = Arrays.copyOf(temp, temp.length);</span><br><span class="line">            list.add(z);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=start;i&lt;temp.length;i++)&#123;</span><br><span class="line">            int t = temp[i];</span><br><span class="line">			temp[i] = temp[start];</span><br><span class="line">			temp[start] = t;</span><br><span class="line">			change(list,temp,start+1);</span><br><span class="line">			t = temp[i];</span><br><span class="line">			temp[i] = temp[start];</span><br><span class="line">			temp[start] = t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>本题主要考察回溯法和基本数据操作，较难。我们需要通过创建一个n*n的矩阵用来存储分配成本，然后考察所有的分配情况并获取其中的最小成本值。</p>
<p>难点在于考察所有的分配情况，这里我们通过回溯法获取人员任务分配的全排列可能情况，然后帮助进行查找最小成本值。</p>
<p>找到最小成本值后再遍历一遍找出所有最小成本的方案。</p>
<p>最后还要注意输出格式问题，校园oj格式比较麻烦，要细致注意输出格式。</p>
<p>附上回溯法获得数组全排列，可作为模板熟记</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void change(List&lt;int[]&gt; list, int[] temp,int start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == temp.length)&#123;</span><br><span class="line">            int[] z = Arrays.copyOf(temp, temp.length);//数组作为基本数据结构可以用这种方法进行深拷贝</span><br><span class="line">            list.add(z);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=start;i&lt;temp.length;i++)&#123;</span><br><span class="line">            int t = temp[i];</span><br><span class="line">			temp[i] = temp[start];</span><br><span class="line">			temp[start] = t;</span><br><span class="line">			change(list,temp,start+1);</span><br><span class="line">			t = temp[i];</span><br><span class="line">			temp[i] = temp[start];</span><br><span class="line">			temp[start] = t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序（递归&amp;非递归）-T3-8</title>
    <url>/2019/11/18/20191118-T3-8/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>实现归并排序。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出排序的数组，用空格隔开，末尾不要空格。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>1<br>13 24 3 56 34 3 78 12 29 49 84 51 9 100</p>
<p>Sample Output 1<br>3 3 9 12 24 29 34 49 51 56 78 84 100</p>
<h3 id="java——递归-非递归"><a href="#java——递归-非递归" class="headerlink" title="java——递归&amp;非递归"></a>java——递归&amp;非递归</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class R8&#123;</span><br><span class="line">    //二分递归体</span><br><span class="line">    static void mergeSort(int[] num, int low, int high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            int mid = (low+high)/2;</span><br><span class="line">            mergeSort(num, low, mid);</span><br><span class="line">            mergeSort(num, mid+1, high);</span><br><span class="line">            merge(num, low, mid, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //归并操作</span><br><span class="line">    static void merge(int[] num, int low, int mid, int high)&#123;</span><br><span class="line">        int[] tmp = new int[high-low+1];</span><br><span class="line">        int i=low,j=mid+1,index=0;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;num[j])</span><br><span class="line">                tmp[index++] = num[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[index++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[index++] = num[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            tmp[index++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=0;i&lt;tmp.length;i++)</span><br><span class="line">            num[low+i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //程序入口</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int n = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">            scan.nextLine();</span><br><span class="line">            int len = scan.nextInt();</span><br><span class="line">            int[] num = new int[len];</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;len;j++)</span><br><span class="line">                num[j] = scan.nextInt();</span><br><span class="line">            mergeSort(num,0,num.length-1);</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;num.length-1;j++)</span><br><span class="line">                System.out.print(num[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(num[num.length-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class R8pro&#123;</span><br><span class="line">    //循环增长gap——1，2，4，8～</span><br><span class="line">    static void mergeSort(int[] num)&#123;</span><br><span class="line">        int gap = 1;</span><br><span class="line">        <span class="keyword">while</span>(gap &lt; num.length)&#123;</span><br><span class="line">            mergePass(num, gap);</span><br><span class="line">            gap*=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //按照此时的gap循环排序序列的每一个gap区间——low～mid～high</span><br><span class="line">    static void mergePass(int[] num, int gap)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        <span class="keyword">while</span>(i+2*gap &lt; num.length)&#123;</span><br><span class="line">            merge(num, i, i+gap-1, i+2*gap-1);//注意mid可以和low重叠，这取决于merge方法的具体代码逻辑</span><br><span class="line">            i = i+2*gap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+gap &lt; num.length)</span><br><span class="line">            merge(num, i, i+gap-1, num.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    //归并操作</span><br><span class="line">    static void merge(int[] num, int low, int mid, int high)&#123;</span><br><span class="line">        int[] tmp = new int[high-low+1];</span><br><span class="line">        int i=low,j=mid+1,index=0;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;num[j])</span><br><span class="line">                tmp[index++] = num[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[index++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[index++] = num[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">            tmp[index++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=0;i&lt;tmp.length;i++)</span><br><span class="line">            num[low+i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int n = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;n; i++)&#123;</span><br><span class="line">            scan.nextLine();</span><br><span class="line">            int len = scan.nextInt();</span><br><span class="line">            int[] num = new int[len];</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;len;j++)</span><br><span class="line">                num[j] = scan.nextInt();</span><br><span class="line">            mergeSort(num);</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;num.length-1;j++)</span><br><span class="line">                System.out.print(num[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(num[num.length-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>八大算法之一</p>
<p>递归版本比较经典</p>
<p>非递归版本需要通过控制gap增长（对应递归的二分操作），并且按照此时的gap循环排序序列的每一个gap区间——low～mid～high<br><strong>注意mid和low，high的关系要前后一致，类似与向上取整还是向下取整一定要统一的思想</strong></p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Sort方法总结</title>
    <url>/2019/12/15/20191215-sortSummary/</url>
    <content><![CDATA[<h2 id="八种经典排序算法总结"><a href="#八种经典排序算法总结" class="headerlink" title="八种经典排序算法总结"></a>八种经典排序算法总结</h2><h3 id="算法类型"><a href="#算法类型" class="headerlink" title="算法类型"></a>算法类型</h3><p><img src="/images/20191215sortSummary/sort1.png" alt="算法类型"></p>
<h3 id="算法时间，空间，稳定性"><a href="#算法时间，空间，稳定性" class="headerlink" title="算法时间，空间，稳定性"></a>算法时间，空间，稳定性</h3><p><img src="/images/20191215sortSummary/sort2.png" alt="算法时间，空间，稳定性"><br><strong>时间复杂度函数</strong><br><img src="/images/20191215sortSummary/time.png" alt="时间复杂度函数"></p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>是否能通过考试（背包问题）</title>
    <url>/2019/12/15/20191215-LCS/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小张想要通过明天的考试。他知道考题的分值分布，也知道考试中要拿到每一个题目需要耗费的时间。假设考试时长为h，共n个题目，需要拿到p分才能通过考试。现在已知每个考题的得分与耗时，请你判断小张能否通过合理安排时间，而通过考试，并给出通过考试的最短时间。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为测试用例个数.每一个用例有若干行，第一行为任务数量n、考试时常h、通过分数p，下面的n行是每一个题目的耗时和得分。所有数值用空格分开。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每一个用例输出一行，如果能够通过考试，则输出“YES”和做法消耗时间，用空格隔开。 否则，输出“NO”。</p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p>Sample Input 1<br>3<br>5 40 21<br>12 10<br>16 10<br>20 10<br>24 10<br>8 3<br>1 41 17<br>19 14<br>5 37 16<br>17 14<br>10 5<br>9 10<br>3 7<br>10 12</p>
<p>Sample Output 1<br>YES 36<br>NO<br>YES 12</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class T1&#123;</span><br><span class="line">    static void deal(int n, int h, int p, int[][] num)&#123;</span><br><span class="line">        int[][] dp = new int[n+1][h+1];</span><br><span class="line">        int <span class="keyword">time</span> = 0;//记录题目用时</span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=1;j&lt;=h;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-num[i-1][0]&gt;=0)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i-1][j] &gt; dp[i-1][(j-num[i-1][0])]+num[i-1][1])</span><br><span class="line">                        dp[i][j] = dp[i-1][j];//不做这题</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i-1][(j-num[i-1][0])]+num[i-1][1];//做这题</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        int j = h;</span><br><span class="line">        <span class="keyword">for</span>(int i=n;i&gt;0;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]!=dp[i-1][j])&#123;</span><br><span class="line">                <span class="keyword">time</span>+=num[i-1][0];</span><br><span class="line">                j-=num[i-1][1];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">if</span>(dp[n][h]&lt;p)</span><br><span class="line">            System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;YES&quot;</span>+<span class="string">&quot; &quot;</span>+<span class="keyword">time</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line">        int count = Integer.parseInt(scan.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(int z = 0;z&lt;count;z++)&#123;</span><br><span class="line">            int[] nph = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            int[][] num = new int[nph[0]][]; </span><br><span class="line">            <span class="keyword">for</span>(int i=0;i&lt;nph[0];i++)</span><br><span class="line">                num[i] = StrTurnInt(scan.nextLine().trim().<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">            deal(nph[0],nph[1],nph[2],num);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    //turn String[] to int[]</span><br><span class="line">    static int[] StrTurnInt(String[] num1)&#123;</span><br><span class="line">        int[] num = new int[num1.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;num1.length;i++)</span><br><span class="line">            num[i]=Integer.parseInt(num1[i]);</span><br><span class="line">        <span class="built_in">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>本题是非常典型的背包问题，是经典的dp算法题型，思路如下<br>1、首先创建dp[][]二维数组，其中行为问题，列为时间限制（对应背包问题的物品和背包容量），然后通过动态规划填充整个dp[][]数组，数组最后一位dp[n][h]保存的是给定时间下的最大分数。<br>2、要求做法消耗的时间需要使用回溯法，从dp[n][h]开始往回回溯，如果碰到满足动态规划递推公式的关系就存储下这一时间（其实就是这一道题是做了的意思，所以记录下做这道题的时间）。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell排序</title>
    <url>/2019/12/15/20191215/</url>
    <content><![CDATA[<h3 id="java-实现Shell排序"><a href="#java-实现Shell排序" class="headerlink" title="java-实现Shell排序"></a>java-实现Shell排序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class shellSort&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] num = new int[]&#123;23,3,11,34,45,43,67,56,22,33,11,2,8,75,26&#125;;</span><br><span class="line">        int[] gap = new int[]&#123;5,3,1&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int x:gap)</span><br><span class="line">            shell(num,x);</span><br><span class="line">        <span class="keyword">for</span>(int x:num)</span><br><span class="line">            System.out.print(x+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    static void shell(int[] num,int gap)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        <span class="keyword">for</span>(int i=gap; i&lt;num.length; i++)&#123;</span><br><span class="line">            int temp = num[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-gap; j&gt;=0; j-=gap)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &gt; temp)</span><br><span class="line">                    num[j+gap] = num[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">break</span>;//注意一定要加，不然下一步每次都遍历回第一位，然后把第一位换掉</span><br><span class="line">            &#125;</span><br><span class="line">            num[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;思路"></a>总结&amp;思路</h3><p>八大经典排序算法之一，是插入排序的升级版，核心思想是按照gap将序列划分，每次对划分出来的部分进行插入排序</p>
<p>随着gap慢慢减小到1，排序完成</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>前 K 个高频元素-lc347</title>
    <url>/2019/12/16/20191216-lc347/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]<br>说明：</p>
<p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements">https://leetcode-cn.com/problems/top-k-frequent-elements</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">                map.put(nums[i], map.get(nums[i])+1);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(nums[i],1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] res = new int[map.size()][2];</span><br><span class="line">        int index = 0;</span><br><span class="line">        <span class="keyword">for</span>(int x:map.keySet())&#123;</span><br><span class="line">            res[index][0] = x;</span><br><span class="line">            res[index][1] = map.get(x);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(res,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] o1, int[] o2)&#123;</span><br><span class="line">                <span class="built_in">return</span> o1[0]==o2[0]?o1[0]-o2[0]:o2[1]-o1[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;k;i++)</span><br><span class="line">            list.add(res[i][0]);</span><br><span class="line">        <span class="built_in">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">class Solution:</span><br><span class="line">    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        <span class="built_in">return</span> [item[0] <span class="keyword">for</span> item <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>

<h2 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h2><p>lc中等难度题，java中通过两步实现<br>1、计数，java中通过map的key存储值，value计数。python中则通过Counter函数进行计数直接生成dict。</p>
<p>2、Java中通过比较器实现按照value值降序排列。python中则通过most_common()方法实现前k个数的截取。</p>
<h3 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h3><p><em><strong>python3</strong></em><br><strong>Counter计数器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">obj = collections.Counter(<span class="string">&#x27;aabbccc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line">=输出：Counter(&#123;<span class="string">&#x27;c&#x27;</span>: 3, <span class="string">&#x27;a&#x27;</span>: 2, <span class="string">&#x27;b&#x27;</span>: 2&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>most_common(指定一个参数n，列出前n个元素，不指定参数，则列出所有)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">obj = collections.Counter(<span class="string">&#x27;aabbbcccc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.most_common(2))</span><br><span class="line"></span><br><span class="line">=输出：[(<span class="string">&#x27;c&#x27;</span>, 4), (<span class="string">&#x27;b&#x27;</span>, 3)]</span><br></pre></td></tr></table></figure>
<p><strong>items(从dict类中继承的方法)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">obj = collections.Counter(<span class="string">&#x27;aabbbcccc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.items())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> obj.items():</span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"></span><br><span class="line">=输出：dict_items([(<span class="string">&#x27;b&#x27;</span>, 3), (<span class="string">&#x27;c&#x27;</span>, 4), (<span class="string">&#x27;a&#x27;</span>, 2)])</span><br><span class="line">=     b 3</span><br><span class="line">=     c 4</span><br><span class="line">=     a 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>K 个一组翻转链表-lc25</title>
    <url>/2019/12/25/20191225-lc25/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseKGroup(ListNode <span class="built_in">head</span>, int k) &#123;</span><br><span class="line">        ListNode dummy = new ListNode(-1);</span><br><span class="line">        dummy.next = <span class="built_in">head</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = dummy; </span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end != null)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=0; i&lt;k&amp;&amp;end!=null; i++) end = end.next;</span><br><span class="line">            <span class="keyword">if</span>(end == null) <span class="built_in">break</span>;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode nxt = end.next;</span><br><span class="line">            end.next = null;//necessary <span class="keyword">for</span> <span class="keyword">function</span> reverse!</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = nxt;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    //reverse</span><br><span class="line">    public ListNode reverse(ListNode <span class="built_in">head</span>)&#123;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode cur = <span class="built_in">head</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != null)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">= Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line">= class ListNode:</span><br><span class="line">=     def __init__(self, x):</span><br><span class="line">=         self.val = x</span><br><span class="line">=         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseKGroup(self, <span class="built_in">head</span>: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(-1)</span><br><span class="line">        dummy.next, pre, end = <span class="built_in">head</span>, dummy, dummy</span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">                end = None <span class="keyword">if</span> end == None <span class="keyword">else</span> end.next</span><br><span class="line">            <span class="keyword">if</span> not end:</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            start, nxt, end.next = pre.next, end.next, None</span><br><span class="line">            pre.next = self.reverse(start)</span><br><span class="line">            start.next, pre, end = nxt, start, start</span><br><span class="line">        <span class="built_in">return</span> dummy.next</span><br><span class="line">        </span><br><span class="line">    def reverse(self, <span class="built_in">head</span>: ListNode) -&gt; ListNode:</span><br><span class="line">        pre, cur = None, <span class="built_in">head</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.next, pre, cur = pre, cur, cur.next</span><br><span class="line">        <span class="built_in">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h2><p>lc困难题，参考了lc评论区大佬的解法，主要是链表的细节要非常注意。以及null值的判断一定要全面。<br>步骤分解:<br>1、链表分区为已翻转部分+待翻转部分+未翻转部分<br>2、每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定<br>3、需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来<br>4、初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾<br>5、经过k此循环，end 到达末尾，记录待翻转链表的后继 next &#x3D; end.next<br>6、翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环<br>7、特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end&#x3D;&#x3D;null，已经到达末尾，说明题目已完成，直接返回即可<br><img src="/images/20191225lc25/111.png"><br>作者：reals<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/</a><br>来源：力扣（LeetCode）</p>
<h3 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h3><p><strong>基本操作反转链表，作为基本操作一定要牢记并灵活运用，同时也是一道lc简单题 反转链表-lc206</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode <span class="built_in">head</span>) &#123;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode cur = <span class="built_in">head</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != null)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, <span class="built_in">head</span>: ListNode) -&gt; ListNode:</span><br><span class="line">        pre, cur = None, <span class="built_in">head</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.next, pre, cur = pre, cur, cur.next</span><br><span class="line">        <span class="built_in">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title>分发糖果-lc135</title>
    <url>/2019/12/28/20191228-lc135/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>示例 1:</p>
<p>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。<br>示例 2:</p>
<p>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int[] candy1 = new int[ratings.length];</span><br><span class="line">        int[] candy2 = new int[ratings.length];</span><br><span class="line">        candy1[0] = 1; </span><br><span class="line">        candy2[candy2.length-1] = 1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;candy1.length; i++)</span><br><span class="line">            candy1[i] = ratings[i]&gt;ratings[i-1]?candy1[i-1]+1:1;</span><br><span class="line">        <span class="keyword">for</span>(int i=candy1.length-2; i&gt;=0; i--)</span><br><span class="line">            candy2[i] = ratings[i]&gt;ratings[i+1]?candy2[i+1]+1:1;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;ratings.length;i++)</span><br><span class="line">            res += Math.max(candy1[i],candy2[i]);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def candy(self, ratings: List[int]) -&gt; int:</span><br><span class="line">        can1, can2 = [1]*len(ratings), [1 <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(ratings))] //两种赋值方法有相同的效果，但是前者消耗更小</span><br><span class="line">        res = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(ratings)):</span><br><span class="line">            can1[i] = can1[i-1]+1 <span class="keyword">if</span> ratings[i]&gt;ratings[i-1] <span class="keyword">else</span> 1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ratings)-2,-1,-1):</span><br><span class="line">            can2[i] = can2[i+1]+1 <span class="keyword">if</span> ratings[i]&gt;ratings[i+1] <span class="keyword">else</span> 1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ratings)):</span><br><span class="line">            res = res + max(can1[i],can2[i])</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h2><p>lc困难题，难点在于思路。<br>要求中“相邻的孩子中，评分高的孩子必须获得更多的糖果。”这一点要求一个孩子获得的糖果数与左右两边的孩子的评分有关：<br>1、如果一个孩子的评分小于等于两边的孩子，那么给他一个糖果即可。<br>2、如果一个孩子的评分大于左边（右边）的孩子，小于等于右边（左边）的孩子，那么要分给这个孩子“左边孩子糖果数+1”的糖果。<br>3、如果一个孩子的评分大于左右两边的孩子，那么要分配给这个孩子“相邻孩子中更大评分的孩子的糖果数+1”的糖果。</p>
<p>总结来说，对于一个节点的值需要与左右两个节点的关系决定的这一类题型可以尝试分解为<br>1、先从头至尾只考虑与左边节点的关系做一次遍历<br>2、后从尾至头只考虑与右边节点的关系做一次遍历<br>3、2可以建立在1的基础上直接完成，也可以做第三次遍历综合1和2生成最终的结果。<br>这样的分解方式可以简化问题，在上学期的高级算法课程的练习中也有题用到类似的思想，希望自己牢记，作为自己的工具在以后遇见时可以敏感并且灵活运用。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm practise</tag>
      </tags>
  </entry>
  <entry>
    <title>PES-Gmair微信公众号的推送实现</title>
    <url>/2019/12/30/20191230-tec/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f341fea77e471d21bd5b07769cded045de82544947f275f08ddca7c215397d12">4d94d3e2ea964a9497276ed6e2e3b252f7448996904b2d22e4065ed40f4d7e9820f3762c45d6cbdf9bdce19c3334dec7958c66ab6f6a69930450e914b93ff12edc2be17e8f1bb535973f5b066adf452a76c30c784439363132764048afb28ef0df40bfc02759895366679f59a0e22d6f096e6b19b2afe383d5b20732323b69fc0c328712f56c8c3123a9290d89ea8791cbbf02a48239a8853ff3c539b4c361fff7c50387c98ebe21fc888a65e0000d718a5f3d06ae41bc3d3507bfdb78139612189db9ec20887493ee43fa19df4fe86ca4f35fc1ae8f08f22b74442c39a8aa85ad688f28b324804f02b0aff836eaeecc991061d587842beb52c26f8f9c9d6ce417d6989d08ea52e64ad15ee9fcb5c4c2d4cf0f1315738513e85a5f0842d5225661fd6d1e4387a5e270381b3731bb35039b0db951de1be892c78a1eb70694a25d17bc6470b677dcc7a1b6d22037886994cf6a01eb96f83180cac94978cc0075b108e95313bab954a495670f8ba766d76735c065d2d7e60065a73d18b0fd1fac05e40e3b77924d88247027b2b64b1ee9c7f07e3b17ccfed5b7914f7e86c342cc5eefc92f8441a930f9dcfcd824cb33f1a2c63e94f225506fd788ad04daeae1ead9b659c86654060148812c2950433b6de58841ea4cae86c38dc7f70cd1e71373413f3acf64755e11a92a35aa3769efea2bef04251d3969c773872f73dda2714d98265ee0179db2a6953aacfa8ebc9f5594b19514f8a2e2ec71240c1361d5f1c79321730e1b1eed33a7011cd472b48016ff8f8779094397fa2ceaf774dc68ae2ed75fef2089f431e2a4b64fed24a88a803b59088fb13e216fc0d0a32202da99874eb1b249fc388353242335220e5a95d64a5547102a45b9adcacc5b7b26d6df102bf09dc8c309e79568e1ad9f8586d2351a78b4800b51f01c44e3efa1506f6edc543d218fd315f31675b78fa652af729554bd302654af84043ea2bb0c53bbd8db7e01751f4127590c0eb845f331a65b857888972edf15ab55f9345e13ab9f187f5b6e078fa860328c9b779696727a02774a4590fdb29f78bcb7921c11a8e3b75d37a92eedd9ee84b80fe2b712f262c4eb0b3292d36ad204045e6c54413b26e459fa10c1812de66aedad46084bf33b74740eaa31a11a9445ea7637b3054fba64d5eec6d34e997d028869d59344016b03c3351f7ed7875c672229f27a90ff4f7be38827d811ce50d55269c6d2c81d2694b50b26468f1bc637975453e98084643bd8e0a02a0606c31f451eaf83b4609149fd568c0f113c0f7c2dcd85c415ec07e9ce6b662b97698fe1377b2c092c4317d0e4a8f8cdc3b115113be1cddb549a4c5fbb595c0b4ba727102f42de752f34f5548eb73ae034691b2a3a97e479deb968f5df6ec545f93aab08981efe9dd08b1b8fcec0494bfa10487f8b205d96b316c07056630373ba67a6c8f3cbccfbbb8aac857dc01e7da7d855732e2e58cacd0134e06c903c5410f338d7e94c785706e07e70d8775064f2164195c3b6e49255885cd00f767c484b86502e15a0a165c13505cef8ce87ca153960b2e3897a09d424b05488490107d540a8fdd7836f7cc0dcdc85a418dc1b6b36d72d73984d39619f183c1673fd1c4a9f6b74befbf216ec7ae253ac9037b8f3ca43b3963ef8af527d253ba472ea3534651151c2aaf034e651809273b7be4c01a3a05b5f654472b7afcaf06ac567f30a5802af38b89ae3243da65784a33d9bf105ac95f7a2e85953c44be44cb97336e0e03dd1dcd4db623d4beeea81a465679649d52b2e636570b1f06ea87633066844bba397bc191132c36e1de3925cf9752f6c1fc13543ec33c0f0064dcca519fe07e4096a289bd960642ad42528f2d06fdc7aee220751a8456defeda2d71ccb3c4e579134d160a4c3b804058449226c433f5738fb68a29d004d34423a1160c98b85159e6ea014de9c886f4019f60bb074ecf4d9f9f340368445182f2802dc1ec4ae445a30314b2a0e578af2995edce4e60fab47b2445627726539493f9b0ead94abae8f0c0c70646e237a8bf4c0df9a46e1a30cdd27fb34474538c41994fbce32064c0c7e72991fae0a81f790e203ce7573b0aacb662d317f82efb0a52f995b82eabaf6b295d72dd818d8356f6c75a7535c79f030970600f5a897c5b6c67b28441ab363aa7667457321f4fbb9ebc435fa76b1afbcb2c73e9017c83647ac6d4b2af2c2cc4c37c14565624c60f3967537259a3b7e01335c2de743b9c37cbbedbbb24946fc61e026800167f438434133c8cc6e8c16b7f82d902181b4ad6704f87b01d5840244bd26e0d7e4bd5a8f74705fecd71d59e382820dfec9e0f23341fd741dad00dec689b5f4d3e9ab2223452d80fc016105c4b28349d023f6de8792a56f4b32f025c209790c1f7d34089f2dbbb9e26ab6015e641a1d3b532a085644a06996c3985228f9f61ecd8b43c6773ecf2b58bf3e73d1ae9b368044fdd8c95a5ca958e4e52bf126aef20e6e7a50afcf89375e65d5c2f224e0734dd1e6aefe77bfda4ca06f05ac9645f169d760264d306282f65163874f46a755a0b4e857308c6f4eb06745c10dc6152f176eb9ff95bcb7043252b1fd7df13ed60f076aecad2ccc93b2be3a4f5a695a109e8cd5576cc2f621443d4670a3c2155f644eeba9aa911730f9333d3c83e6b1fbdde780c98d3067972a6d825b9386a7ea47edaf28f0c56302503c15b9ff728e76750ad3fd285abd553992bf0cc15b0bffa70a78c150c68bda65ff52856ef19097664d247fd033a49b4d3802c7021ac3710ed71328d7e86d9958a537db9f9c14bcf7a31fa25d92d40bde2b5562c94d1b9dfbf9638e274c2909b25909f8e92298f589ea58b282b694243a09387f73fc097f04c28481548d07a7c1e49224b83f104436c76b6c6b74cfd264625880be1564202db93d9a87411042eb5234adc3f5df07a200a1dcc601354a1f5cc681808c85773423d453bc0fc3a794a716816a95fc273195d85bfcae1739ce70568dcb5b3668a969e8896b3366ae8d9a36e706b40676a0ef965b6703ac212804eeea6c5b56ea024fba703c083f079aa6a39a962f2ea4ecd224c64c89a18cb96efad72000282c4b4c13bbc97619a7179cef66d609b7a091ae56aded4a5b4de778d48556fd6d735cf7b0e66948b765020b8531c35fdef64a4817ca2c3b9485ec9325d93aaa5320858fbe09611f0a276771e47e8c21213ba7fa88ca1e20b8a658737994918ba5cc76596b930facdb09bf18420eb65a06fbcf979ff28ee3ee0afcffde55312c46f0bc30a37c5f11bd75191b7d98be80c58e1dffced2199baaf804475d6d0d8f6cbc80da9d7b01b2bb6364692a60723ce8151d47205f50ce743249197f6bb0ea278d90f36e784d208efb5347a7769017aa951d2b38b5dbe36548d8fe06e5af26de408410d4324b0aa92bf20f6671c6370fc677eb79cb9418431e35b56975d6ba88cb2e040b18eb6e4fb1b92853f21da3685250962cd3f319599e3d02f8e4f7f7b2537ec7852a42e1d2e8250d6149cab91bdaf7612f5fa15bf5bd527c3b02c3c97f3f085924441a41ee4c35ce9f52366c8848ee9a3c81b3204e605695a562cba326d8a8a44e6f5ecb34d21e28ba1028a7e1e1810721809c568a1fc89c8bdaafced539108314fdbe6c87245eddcb5859614b53570c57b2edf471ebe9187788f2c023cc5558602ece7e7eddd8074c382ba613295d468e254594a85a4153a9e2fbcd5f9c9406c7d3ba47cf49477b7005184d1e9421f21fa36e0473c9cf71fe0b22c19a903ced19f890f4ed626006b64171edaa232d66f88f9440159335bf08e6fca4a7ec63bc7a87f517ecec779e97eda91d94e04cc12f5c588082e7d46622e367a723b69867d89db8befef9c1411a0ccf5d1212e6211b471fcfe1ffc3423c23aa3e0a62f8f59cbe239e7b782a7b8d0b4edf91d3348620cdc0de674376d41225fdeedc07eba06fb989bc7ab82197f83b24c649447f18d5dbfafe9f0d4e13c8f3ea50d867467ed09e395d411736fe94f0d70c4c46b50f49a5ede5a2f99fe93d48f9fe8d4113b254b97cbd74fe4c877b74a5a8762a42376da0a8dec90960fc5dadee45fb9a43d1339c3a89e4fbc8eb0f79c6ac244423c1ccee7c60458a72819c307bb25e4dc5491a19d8738c88329b1d4bd7b5b220015b8f10b8b89901247f6e320882ec09d52d3e5c73690922716acf73fb6f8869a835dc258d51a4290c2fdf72238994111a26e46b8da2226774268ff97bd0555e49df911d4b58b079022f658423087371d61747b46024ebdddb9d805599959622f368f3dd2fbff52be333076c2c922b5133ed06f76242686c84397cc083a5bec4f5b9b878f3910e99239d26228fe73c3b37ad4dbeb630ad2c7a995c4e5fe8206ebf7ecab3586b4e6e74548a8b7af139c42f2604e3636d415d1c76f346fb2e7e072ec8a454910bc1aa40a97ad260f30755dc33fbf6dd34e8a6a629fcc97ffc838683cda3a0e8bfe3fb78b05008e7cffb0d71f9ef922ca3016850bae241c5c2fb71d30f0f3fec21d4377ae7becc8624ebf1aefc4379caa983263142fdae0d13adb90ffbaceb8e7934c632ed6d6393d02902f1cd77df40654e5f6429db5439a41463ee8dbc252b9b2f2c63e001c62669ed958a96c8cca2475c91799fd55ae57b7c5bdaba179cd8ecd90e75ceed802c842202d55c31e3309e991e4948ff889b85f6d328ec907fd4f06563f1b9bec010fa124f57306460fa474cecf0b57adb91f1bd3cce7f3584275fd5aa10bb0d40cdb2c52fbf644c345aa36dcbcd4e151d5812412a465e687f5e4fccb960d185cdf662066ded42e9cec63ab5b293a416397bbca80046baa90b2bb340b31f07add1e1b9efda18f8c29886de34179a70514ebb8e4fa0e90e9dbbc10c2a7218bd0c21b90d4863da11cd14e4d0441a848bc23091073efaa45e51e6b0d7d6163924260e193804ef109553bf8be2da3d3389881df70ee280571eb3274c239c1dc4df993981ed256c4808953b312c0f325a535ed416a1450d5284c2645615cc311c52fcdfbddf06c1520d7dedb515d6ecab0b00fc08a34df1637e545baaf2ce37706ba7cf21e411a8141b0cca32d8586c9c7647a2a796c7d73bc248c8ba0a01da46252ce79278d32acb21b00d58459e16f3c350a0d4802f554315b67a3157924f280bd349924f22f6924aeb0af4cad8a4e62fbe8316cb7468507d37e211ef127412c979d4061d8e378e089ae3f2e0f2e300503f8ec7963ac97e75f8dbe7ccc868433fb8ce637badd293eacb58ef5880e96ef797dbb3406a2fe6f5ccdf0a496de4fd8f63e6aa9098f9ff532feac42a5378ed4f0eb22f89e83a0dba1273589b3ecad221809735d79f25af27e7be6e356d0503071a186802430725d562d34450ba531d034afcd83c8286ac4f2d6c80210a86440e7364fa2c18f2433458a3225486e6750df7928d9cf7b85970e7b1d6de0f02c1edcc0761505524bda52226d0cacc2106ec15a7cf165b9df7237bcba846f9a794c07b08da6d97ec46c31410287084fb19c96f0891bc7089d64d77fc2c378a33692b4ccdacb545fb7cc24543f1ff41598a02f71014a4322f0f3cf38f06f05903a89c247b4d51a6d0287f7033f5cc797443e4ca8ee7deae8447f83f61c600819aedb719d72023b1bda9b6135e7770b3bbe626b9e419de814a166e1eddc66bc09262af871d7f57ef5249f9b6d7214063efb7233a7eff9d1aa1a083d68b4e433ad2f5b1c44ce5a3d782fb7c29c2690329223e2524e2123e8b4b5d4538f204883c089607a79302ece814ec255095a6246cd028e742ae75150ce2360de391c3cff3fc921029fddec4185e5d372ae6de93f884386a3b207bfea8be5017b7d940ac8ae096bedd2a1449380533cb60ae866fd92bf8b85b7776df77c41e5e3aaa160f869a42e4864908c787af1623492df5d08b9d161496522b021426525e54a3c376d920a452f9585fd49028c35fcac042141c92bd845d10297a0a31ec79f83c67e3a7c0f756b505dd3def8757a5addebb92ab250abb5ccdfa29a54df4edaa7c4543009d2ea4f1b62841ccede083350689b9edadbc21da9b6063f059e0f3624d3069785059f0114079271ba801abc0e6d9a42376bc44a72f494028e942f2767ee432b9c5e192560218711cf89e007cffce9fbb4b624a77291c2341febd740707f6ba1aa9fe712d5294493d2df76288223dad29f37c40a28560bad3da599952405b572e92562b4d0f2712e4645874789c824b0c23a437656b4e0d7fea188deb32e40d549165b7e9593c481ac503bd87468f0749f545a8913266dd86c5e3d20d74308a50f34201fcf14c239d2935ec095f1faf4693ff56c6af8d9c97314ffd9fdbeb37a3ffba254f9df2ae5b4430aac4704732f5efa77703a6e927f46a12efb5a79d4d957c2c35db441e3cad72198f89f90d42e1d54428c7a44f383621b43a4df404868bcf923c667f391abdea2384ed7443d03c34dd0bc100b669877cc0155cf594238c74af1dabc6f7436f0efcbc00b412a48fffaf8f4d3cac6874bafdc80d4477dfd0b5f5d2c8a988fc024c6dd136746d397ec95cd61a486a23c7310b23a3ebb4edd0ccaa4b44a9abb99c7396b8c6d64ad644e7c2212fe8f4254306e6e1990e64fac911ab8b7cb6720935f752d5f232ccb8298172585645ac7c7f0962036d6178fbf132f2b44e3ca77f59d32fd0d7b070ce28860ad3cdd9701ab531cc35c5c66f7cd525d1a99a3662fd02f87992ca97fae6094e409ad492a4bcb03d52eb6598d3dee766ab0a08a7137fb88a2d8043081e8199f7af6c5cac549fcd6693afb98fa5dac361e76adac74711d0729ca12753f7a19f09734266a2eed0c81c3e4c0f71ea9f55ae7c23dbffd73152bcd928cf33e6c429c88defff43f3773c2a87c6f2750c42ad2bb03275235d9e3d3049c93d75fd7743c39387dfab54bf382476a9f994e4e6eb211c3c28c80245c7a2107e399fb4e7013f9b90f260e174bd05fb0719f2c1f49df259cc2a714dff9e5c26565d601f6f382f884f927192f875ac1ee990844c2bb502b3fbb738f44094af0d7bb7ed2cf52e10174d1b25db4ce1e1fe110e04522c60bfc695273b348ec41d4912de62a69838e994a62f6098b51c320441e403a375557b59dced6dcf4c214115a126104472f2a9fabd2ae700f7dc046bbf9672213ace4b6b38cc6c9b018a0ef6fd4237fbf1e3ebffc0e0eaaf8ed52009c3ccc9f94b4f3c73c1bdd0d69e83a26624ee75f0718060e83345b15dc423fe46f5ad1385a118941038484e30b4ffff38458ab02994e8927d0babdd740417bc99268fd543d763884c6cd18cf717969301c1ef3fe1dd657ca3a70ef30213568f72bb8c24ec5d3efc21a5b1da840501a7a496af1aa14b18ea7afdb2340809cf3012f7f30a582d4c176100d2c0492fb7514246c52b80637f3ed3a51123e76b7707bd7a6e33b270b131b3c63e66001ef308e40e15b130c223125deddd8b4ce57f529787bd82fa8dac25f6e822a5f743dfc96efa93435fa28cfa47caeaa5a5ffd59fd9812330eebc02ae3138d17cbaf26bc40556cc345057b5b28157a8f502eb439ea07a8762ffa517e435052241cdfbf9086c8929a29a39236fa3ed3b634421153e4aab8be5ee7ee296dae271dc648d9dd2618297528ad443f9a240fb5512af820851a7e12e23f931c2f0368a355d315e45913aa165bd83a6fb395040973a377414a323c7924ac88274ded9e5797e624df83ec5824b52b80a40ce8c00cb16389ef1fbd2b16f792d67f2c867182b0fa5702caf3f89f0561c4a094f72d205209b714a2be7ff67da7e9c1cd1816ab6408c1cc64383dff2afd86112b19585856f2818f0086a19717d2df39c27d139baa0c0e7a1d20ac2699f24eb0ac1f72fbdf915b570bc5a4498c6b0849c360a9d01ceb87ec0a35c4f990e84b1a1e139fe185ecbb477103cd99b0c22bb3b93c98a9326123ce775cf2a8059985dd1b4f38d77441142349cefe96398c0f8e01f2c362af7ac7c5ce06f3448b12ac3d89994d9730052ee32d7d37ee4c680fc4cad23e6d487d1c9ee388150213d6b75e37980577e5c7ec3698d888ec236d869a92eedc81ff6a88cdf29659a22b5798d848fc120e6ba2ea37c6b5119b446df4c21a9f9a06592a5347a30cc21d5e16689610210b312edcb9d24536111773b2a68050db07257c5835b2dd5c26723c039e40cba85248c2050162c828a7f022628a5a770060057ab92041a61e2e1c7cb8b38c8008674bde4a600cfdd1e430054ea06837438ce0eafcd75b498155f986e341d84b10b23f22fa3917e6b6bf2b0ac0ec51ab785113d777460e94f928b2fa9c00c928785b39a6b5d97ab1f9bcd6782fd71bba3769814aea2d18cd5283f7572158f373939a74eb979cd2a2a45422ba4f6e6845c4e7d8a162200022b0d523c731d884e06c418b8950402ea08a0d7acc6d4ce981e8414ef8a7bd1fff3f176b74163981a085ccb8fffb40d9db70e161a243b8adea0136f0d9f65b65fbec924c76eb0cc82c2683475ce3b205bd207917181f87abb45e55e8dcf612a9ae8483812e6714f7b5e643c8c073ec3bdb01d8b1f588cdb9c764aefe1209ef70ecf07a1be3259e669e41ba53bd0845eb2d58e10b78473218bcfb7043434c248d976326ab6ffd0c548c7bf3029e3ee04d31ce434ce65d827ba9839ce6f6d79c382199ffa1184e8972a3c6115ff7d0cafded61ef87397006b92d1f1a4d35649ac61a1d2364ef6e6ac125f3b55c166ac2743d4c0b80560faa02853ed95a937ac845f6659b8473494588e811df5d68ea52fa3853239354e1d655b52a9ad20cb6207471f9ac1bf1f81c995bcead5de9156b8b3dbc0715ca30f17d54ceec9d218f30f83252411fa4f3a116156becb886bfb5f48889dc44019be24a34e4eb547836abc4e3912dd242a798912a8f47c3caf9e29420817ec9a0a8b1ed9cc89079847b850fc0c024496fc4a0a18dcdc53ea3c8adcb3dfb1946fa39047a37fe99a789d50b0c5bf2b02ee1396cbe62812567af8a685d44206af4fa3672cf4a1ffa4df17b7a8150a23f1104cc6989e108220fa7ecf8250b08387c3e256040f668c6435dc8da7c5ee63444ee8a3dfa660aab9f974a4a812a68cb062e6fbb8f9d30342a2fd8bb3f01d33a85362ec0b973b417d2979cbe9ac4e6eb68a2be7fae0b3051280cab3bd1b58977b9fd536f3035f4b5bbc54262d2f64446dfa58b2141549d90df7ab677ef16b32453ef0ed96905889c011d8d8e3b55ee53aa69191ab56c178c29f6c7642bacd1a41fec76c716efb3360a74e88fa2a915dd9c2c203a199dd88794126f1d661f6c5c5810dac66c415a474059cb9233723c87b3661f081638f749a41f6d7b8957ba925a0c9bf04bfee8e41739e7d76c6535a059775bfe5a2e53cff0834705b822da53e76a9e9d08fb49c25996e83614b2e2a08559bc1dc859ec460f9fa2ef9121f9c40b9d1959c3322134fc3630d65948f63f8eebe1baa9b8708777ba2912f6d464f9cb9aa6ddbf33f1a0135de0cae437199fc51f559160b80865919503a1e3e22f608dbb866e10138337989dd6cff94113c48f465ff5c4c230c0d6ecb8a7c9a2c0a800a5982d4c1a79fda3f14992126f52a5326491ce3899028d2164621385d84ce679d2638e9fa7a1c8f9ec2401dc2e50d66ab1d233ab3afa6d71960a030e77a6e41821921d8737391eb66959435a8fbf30c159c06ff8610996eab7178cad0249fe2ba89822cf940391fef3e40b58fbe45bb2586e44c3d41d8a5419ad65fee9e5088d8406a4063f81155c167ef99afda84704081e1c9654a52d3939cc7997e903133342c7b1ed39bd8ac668e0e25752c290faba8ac938901f40daf094d0f4a1caf9b919be7d1104e944b07bbf3b553531f791f08e5e8e59353311593d0bd7eb61f36582ffc9148b09c8aba3f640b51c0c41d10d046dfd2bcbc85a11d2e9e6d1cc90048aab00cf95e71e10939ac36ca41e14e9126e7acfb0c7cf59d1d83786da7dc54414b615aaafb83c089f8d96806b03c0b5e612bd8bf1814c34fa06ac6096d0cd6a3b5f48249f3ee16d856a63de192ee495d2f4063366effdc15776598fedb761fcffe6aa7c527739974777551e0ba250b1798de7a430abcd737d4ae38ee4faa2bb87616db256197d9217ba1940ae5e481f8ae1b7f6f754e097529d5611374de017acf4c5d02af0dee79296fc2c6477dd15afc8ea8e62c0a2b6d7a623f9f4353de247ee193b8e4b2fc8b866fa3bdccd22d403a894f6b20eb2112751bc06b02d2055d48317a8ff27314a97180552eede4dbeb954e2e7ee8e9d70e88951375af13cc4ff704bb4973bd7eee5541373e0b848c51ba5296909974bc945e62dbc3d01a6cb4e3ee346d2fe355f444f5136827c62f9683b3a763a47dfdae7a4d75b2dfbcbcdda410d118d8297509174eab356aa7e022e65cf5334b72ab518ebbe42d39ee93279cdc6a7ce47592b8e950453216e8318f73a809c3b5b38e1315a6a0603e2a6bd7bf32cd8582a32d65ea5eaf2c935e71a696dc48c218fc5be0ffce54eb7fd7df5f4f0fa31e7bfbe4aea776c107f11e4a20084d08d0ba861992df7f692bad4c96d4a4b01229e2be5257ccf36c44fe06bdd3e0cd192bcb977f5a442cd3cd2d578c7a80d70586536448b5c2d3123c8c701b4e1b855e6c9725efd3831ea7766dd25f839f72e4f4081b81ec5d102acc8de948f9b119ca46fed7837ba4ee7f2678d45a313d62d3c70c8d450343f5fc72533fbeb74b93a443ea7261d6241663006dbc9218f1fbd1d4c926117553ffc9e816ca6f625d1ef8e75495e48ae5d8cc002d408f6ce8b1804e37ffee3b1f530ebeea22d19a5deb0cc49b93fe9c8ce9160d808df93dbfadc2034ed83e22480dde304e39b4172c734538d25047376e553b32c9b4c2ed5b3bc5e831cb917c4097d08a6b718db2b1454f8226822a2ea39487486e0d2407bcb14e43b5c28586c6679c91bcc852c34990ed09fdb72c83856be03c2ecba25d2999c89d575712b1265c56fcd9dbd63710e079e0ad13cf70ce4559518c524a90fbe421a988cc09621226c0cfcf5be478dd4d68ea2dee321b928c00cfa4ffd9e464b334979d83f5a10bafbedba1c618df5d32c225b6c77a50caa44fbfbcb0d0634824adc5cb51c3499694ed41077ba4bb8e41668536ba7de6465646e3cbb10f9f57abf1bea3fdc98aab8b6bfc557c0c12b762639ddab89dc8ee71717ae0b6650c6f076dd5e6a004f7cb14245ff871cb29970fc69376011fce8253f6232c50fbbffa79a849bdaff6812d8c314014ce5e69fee5061ea51739e8c8e29305f7cec81d256c4d7b09bfb46d3cfd3531b10691c5cdf1697dc3454387325346ef47bee53c8e198274887c276df9780af84cad2db71ee7c77517f4c0707bbf9cbaf414ef4f525a04f87554a67833a2821e067a0b41e5461bffdb7396c477c4d1818e2e4ed4361a4cf72e0295be6a89cab35958ff5a0782c6d3107da595b83a67f7f909f267bc34352330244a89b135c665bc4fe35384292be37282b9f84d97a4562b4a55e449f468dc7c34573a6cc9b034ce4fd4d15ed448cd3f85e6aca2ed691a99102036319a6c576763a297f039164e059db790e1d658c5ae7eef52a7c3c891b3a4e31ef71b2277d765c4896a4e4c9257a20e65b453e76c1b81cfdc906ae39b9f0aa52e27ee85276f2f9280307b342302c99b6a9e617ddaad8922a9dee2e775162217998cf8c80acd4ef002638efe0eb59696d73cb50cdcaee197be2fcd93bb2ca4c43a738933d0257637013f098af3079db10b914c824f23be9668fca82a6f48344945f446cff8fd43715f0b3e9f89bd1fdbcbe2455cee40091cf8b360bcc4ad23850996a372035080a9bf5045fda82995c1c6f5ccdeb709dc44fe450bee9527c0b67846c03316ba8f4be8d39d736ac485164026b9c5483f98ff196493975cde542713c3ec4ba49c860bbbde03802104083cad14d042879a1e913176ed724dac5fbc27ac19b72ca15b42dff11972d17b0b268bd3cccc68835f8e9c4be3b86bb0aea2006d772b6566fee59db79aca6c895d5b2329a3eb5eff06b9923dcca00d0918ca9f966df588677e89290e123020da4da2c3398c74f6530b75568913023ae68687e15cd1df5a80f7f9abbdfafbcf5a721a4e7be5baa774d1fc87ac418d08d1d9f24d9f01e0f49474a7a9b27cc39469a37f00e0f8506f1b027d83c09b0dede96d9acc980068891dd10e2373211af878f19d7e750eaf3db3bcd9bb08c4f8ddec2f9270ccb4c86e6dea04240cdc8fbdf43f4f9f2a5df108ad05917b07630f2a8edb1d625b20f6d577a9af0cb3241e65397e81db363bf500a26055f384243eef9f5527f98785ef650beafbd10f11b0236fdbd26ecb39ba8e4d3db97cc44d92a72aecfa398f7060409530fe847746aac52f90eea72cc4faefa76e1ae999bc581bd6b9c079f67b5709e1bcaee820bf98daf1490a5759e6f261d00d902bbd3fe482b8da193f9ef8dab252d541870983991843e1102dcf558ba6121321a7dfc4dd4378bafc528af8da37ed206ea24c49d2c8cdcb438bb154bc3995a1b5d454582dc15d0a24a0b6a4021a004dc0e0aeac8f04fb5b3d072767b30042434a612a16877d3f8e9457be2692b8d936b80f8560135566d5a079172c284ceabf78094532d73a5cc8659fc0e3f56c01f51aa10dba499bce4673b15442c0d234faa55fcc374c0af1b0fb096213f6eaebd05ae000ae5e1df278b2ce81aa5349099e7bd1acabe060addcfaa71ff7e27f6c35b983996bc913bc01b5f20110da845ea49c7449fd1bb5acd84418e4cbe8bc7410ed6e705efe2382fee33580bdb4afebcedcc6c358447693dc1c15c5b0f67b06685788121f717351abf2515b26950337a885f55e353804c1f43484387158bc59bbd84aa6549c7afeca0751d541c1692cf464d36102bfc341323ac93360199a77da0cbd23f48ff57ef0d09b44d844ec02574b7df9afe4622d66b56bf0fb2ce5feaadf8db07612101e66fc6c8f4f940f90ce66bfde7ca00dc008dbe4e7cf7de35b3232b197217354c2e058f0b04f81a585a99d284efc8b2cb55d1c9e80ae2eecc32c9c4a405394a7305ec7f764201d1b50815ff838f909970966a9c61c98627ec61633fa135be96e1a39181ed5f2a907ad6f41b74af77e68fff38fea56f523f50a4fd2641a92460df659a79d9be06522545e6560d7b18ed9e6793f361dc13ef1505bdd6ff4d31faf1ced2dd79d5ddcf370bb749e1909319a70955c959ab3aca8a083ee9dadd64dbd8dbccb556775c48664a8c24c3a4ce69f02e1e9d3aeaf21af670feda03b7ddf770fac57ad99c79dc00743857c5941a0936c0b43ecc773873ce25a8bbb6fd4e82ddc5eb22cc1f3b5315ee2b28f3a727345eb5217ad47f3481409fc631ef63c87d9a64161093fdcc45c084f1f2699214e9c653102186c3db2010a81eb3b73767d60377ef5fdb3cc5003940cbca704cbd082ea31cae995a63c6826936c85fadbecbcbe09ca4d33e84e0077983f5f628ca5d1d8da8572a55b46c9fa518cb88ea01fb8724188dd349a64562161c01c85fb26b7890e44cc5774a20faa7ce7acc34aca1c327761f7afe5f95f83fec5017d4f9946d25ca0259fb107c469c194955783aea7ec02c7e74b6e1365cbe08f70603a293f98e731cae83e9486ccd9bca09203b8a3702c2b25adad394e0770da00b4924cace8c52b28bea1ea78b5f38be660cf38eb4168903fb9ecabcc37a39438e110350d3664a3b25831feda104d49fc46956e841975c425ab4314a41d543e6da58d3980d77e8f0fb62b514389a15af3579b1d76fd3d60da5eaefbf52604aa98a43276692714f665d29526bda8fb0fcf6e7df8a122957266044fbe4f4401e275629753e59bd4d32bb435c0dfc2d0c124ffbfa758ecb31a1a6b369213257cbae54fd1cdc6023225abebf6d6fde4856a357dce15306b258cb53cfe0055cce199cf82954923c1c48c3ea47819adaf883ee60bdea1c4fbe2198ca90b33d11a64edb24cea67d4f0552941c7d8338699cf687e5f0300324ac484f0d34d4dc86044ef47dbef94bcbf4281ddafa646aa77696e23286518be51dcee3e67ea8ab4209437f88da8279f2950a95fd00eaaedcb0a18ba12a32f5c0809060fd48360af19d4e2bedd916939ab494fe3320358545283def25e739565486ba26ef556ebb79aa6d5deac44258a3ba0b6df9172084be01149a4ac8346c7b914d15a2afa38776eac8422a130d5e9b257b97915d1b598692ef2fd37ae12c71c71983d155b713710921563709ccc40f029e5045eebed29cfe892e9a81ab71c36d0cea638c53f094b04635f6b66d6d213ff506901aa44285de293c9af77bf737263d7ca5b69cb0b91d698ea6e9866eff15b9edd66c4cffae38fc39db313a6248dbd9370437a99d80e7d6069a1a2e4e836e9b85f24f88de14aed802bb4192ccc4959456414f75c9ee77515d26027e0362b3e28f474e226b2fd53f75b862f5c44e0e3906bc84fdac9b0d3773353474cc17ffff8dabb34bfb26caf8bd5a75fe4eb2b60ab9965c92ee2dc2ec7a76eb0d13094c7795ce84c057e01da7e246304867659a5dae73da4ea0850c6cf74b2bf5922308c9d55c056eeeebd3e5574958568a7e0ed2b3589875523dfad9803216bbfc3c71d66cd06655dcac29b483fd096ec38bf70dc7f37d78102fbb848a8927ec3d9be2a97ca164ef9d9dfc6d424e50da295ce3a523491bbad6c3061fd7d4f4fab87959438d5c5541a94d36a18cf4a40dfb05647bebf7676a53be26ac97c0ece956a24c378764d32f33bc1831719a50b0d3606cfbf7019e6694a896f684624aa9bc998eecdcd5ea99f2968f0077012f6301345739a7038708043b6b99e6823b70ad7f5f952c0782beffed96b0e3a1c947b0a43d7060924a079df18b16730ce7fb26e58dfd773e8ead88ef79c7a19b8175ebfeff6ce204b0b66b4215523109ee1aac90a582e8c6cb836bad72e1e878384e0a94221ecb60326dcc9c0a3e6e98ee8cc4a312ce5d4056775905caa582f414ef4c34de8624013e1862f82c34a4c0f3b9e6b2b9360458216b07bec36d5d37e10d958394fe8ec135fa906e6dd79e2142933d276e9593022c29b99e0fbe771a0fb34ebfbe59522ff3a9d8ad0b0385bf8a85bbfcb121ae4bf730870b54782d29b35f6722b23cae26c2ff00bb1a4c4e9bfab7fd780433c7cdec622751c05cb4677fbba0e54d246d69d5a599c5759b81614919f18e2488413784417ae0f0480298c4307b740bfa6344d19a44bb502e4dca59860c4f476250c7184af0fc73dd8b25169c40da87a53162549a6faaf9cf3c0691e759e990e3155268baa438ff2b058758e4e060f8b83102a21234a481683dee5fba9103feaba2294c433727b8e090d82a2b96fb55d63c59446f0234cdf1ce542c44b86e24acb114daa4b7b690a9e5c78bbf5449bc6bd4d995346334749a4f2a798bda36e437b58006b017d9728d40c4353f2ec7c0eda13aa39beee6201a590a4f8d39ba773f4e35ed5a662f8c78306cfe9bee18e9b2f0b985fcf009fc9113f42bdd33b66fc16d76f78b6c9eb5fe6cb98559e70814eb168fa52c2029b8266b05a21bdf6ad27c3c7f76f24214fecea6c0ab663bc7c1d5d3b021c8cf9a8e2a810c23d2ca76fe4a416fec185ecae5194a8e9515bbd9aeb19fae29868f0c6df59e8059bdec1a01e9f62e17aaad7063967b5dc68ffcf045d251a7756b84949270c6a4dd9d4f710b445ebaa632171c37f29413e18f066e4e98bf8ea8c7918eeb7926e4fe52c3549a59cbc8fd0e47340d5e2e3a3a0b83531cd76eff602309f1d8067c814c73291426a13919d8ba01c491ccb40ed606353fd7a255851b7191c1a8da9be6e6a5a4532d13305f36bcb9a5654415a790965a603566de15d1999230d7eb8de1496982a700f08f91baa18f46c447fe83c9631eae47c0189e0dd2f5fb39ab46a75e778f514840bfd6799c9a3dd692c52980eaec2674c0cbc65ffe3dab28deb2171539203d4013baf1bc4ee3cb784f19cfdbaed0307b1fe9b2c7bc0b05ce079ee5dfbf1a5b98f376dac15655adb8b706b92e142e67fb04c868af61121d148b7cab572717df832ecf7c65f18c723bc9fc8e8c8049c6e6a22566ead7e3bee6dc2d5f2e603ab49e1026b7dd4bb60ad552bfdfbda86bc849c1ae42643d9723bb350266f2e0b3a484869b8055dcc9b9a6108caf72f9d73a638607b75e4308ee21e87c2961be87a2cc2df500f85bcb61a545f915d5ba8d30e1c142967d2e6db9111ed351f47da2fd2fd8ce3c46dd87344980dccb20db0324307cf4ca1cdec01ba39536656684e4a6d67bef1b073395a48b847abf8b7dd147dd70a8e909bd1fafd872b15584e90a37dc6ca7988c06c980ee1df012c862854e0fca166508f85c13104b623335a2f01e7797ce760efcfd3714188760f14c8759c3518c7b7e98e0cb8e0b586d00910b83ba032185aa783acd67c03b0eb30debf3e59596300b72581e1c42a1a7967d280a087f294c7f389938646760f54307636bf9996f41d2b2736d04127fa93bb0b7f37acdf5bd01c652868a33fa7bb2ed014d71d1ff0315d6e3c9baea506975749e242457b60fe7cb7121c3020ba365943d752f13a915096f88052c739fdb9ae8790f048c9890bcd75e51b09558f2b11df5b34e33042de124010b6b05ce7533c020c9522296c4c7f2127df94dd75a1b3c30df8a579f315c3b7b73ff2c7bf18068d5335f84f0686bb26263ec29a67a026b216025a3364dc23b810597b6c37771ab58d0461613b862122087042b0aa4dd8317412d2e479a9654a5bce73c2a131445ebd2b0d8071f69c17714f95b11b2df02cb33818c58ec650e140ccbc2af40bf84758a9c311643fdde6d03f4a907b78acabe05159e397bde779ee0c1a06964ab386a57b0bb602eca1e3c7f198575d52c8b717254a34cc83392338d0ef5aee03bfec73119fdbfd979d2d18697cbbbbfe583b3c213a42f6a60cc1378aff9ae25a24e84a5602a768622c789a0dbc91e9b0b9a164f19b4899f52adc94004238544de130c63706849462c5e451f780cdcad099424ced4f359422ae45ed3ae062761688a78e495f2ec0f208eb648e8af81a3aad0ba254fccd357a2fd4af67c0714989f5980272a13f2ba869ad504c88fc0bc349865077684464300ddf7dac026fe31004298ebd3909238945aa15e635f653cad93f9454968a17885254598f9efc6e6cf7608e867305314e2cb2537756dfd8150fe4fefc56a3a727c863e3b319c52ed683206b669b51291c929105ee9d23203492101465b66d307e0b0bc7469b403e1a91a2dd56ca1af429a4c05043ebcd0cb9e8675bfa7259ce1ff8893f70c747fb81ae4489182bba66ae3d6060e7c8f2f3dfeea0f8ca0e3c2f306d6d9eff8d75b718044ff4141afccc36fef14b0b63286d1f12512fe396cbd0aefc2cb054942d2ba208caaf8a8f20096737e9852ad4b04632c3fcb2b534630b7a6cd0a363a59c5617b9b8cc4727d5bfb78f34ae96a5b2af0e8b62a11f0531ebdbba8e2ba29a4898aa7ffa23eae0a49794b9326e7282edba7068e495fc00407d3093b830fc7e66faa4a3ec6a7a3876d3881373238f36a79323b3c12ed7f9599e41c035619f0e289ae5b61833e694b538b25e399281e34544b379935d8f7efba26b3e8bac1ce2d40d5f54103e43dad4f211a4df90cfa5384988a436ba1a1e392fd25c60b3150e08a020803ae7a027aabbdee76807777b9397ee5f5a16eb10c660c4fb1a717e789a2fc85d1729a3cbf1d33b1decf1098b60a4f9e13682321bdc76291b5acf80bb19da133f725fd5e47dd65e07f3b95bda19e3f7d171d597baad37baa12c5906433772b73055277cf872ba5d74595ea47acf8d3a6cb6111ddd03a396b79a5a652ced538288d20ef9a8f0700fda87bff9a82c1fe9e5958907a206365c58e77fe73f4d6e93ae9dbd0036bbf0044975abc3a00260e8117cb72328c3653f1c9f04189e974247e1264846c6d2c71e8e1e406321c7497ea288e9cc98d07736334c25d7662e29f8b88c23cfb3daa7f9f87d9be3151815690c4684959d3ae9dd01850dae185b9d49953415c662b543da8b1d42f7625891b2d76e3d17d79b2423444870d36ae50dfbb32093de2fcadc510e66d9550c9b6fe8a9668a52bb80a2bc677ec2e1ab416e9c04df7689c0ae1592d57e8c999fbfe04da4aa44b9a3fd665bf1f76d4eca2ed6d9922b979099a3a6380814c02684873ad08517c0f369af33a2c4c7c85018bd4ed2fd7c2cdeed68f71e5ef32f911c3a2e4ca7138dab3cd0895a9c3e80e7ec2204e9333935f890401e8de83c41d36fc711bd7d4a868cdf02acef1f94c6de1c8e193be9a08732e657ac1ba5345309cc943d39ad4ca1d35063484a4a41ec9c111f6014579133086d2f14aa70c04ee28840d1baa9c4ffaab3ef92d97cd430eaa1dd82ce9467cf4cebe5d4c39cf0cc6abb1fa3c8cd351c42d014549596fbb90155cdee766eafed508c761b9c7992143390bb8ae212119b731cdc91f0c969cecb8deb7c532442fbe4d371f8f8bdb63ce656ea27b217974e3be5b53a1174ae9368f8b032ab3253ab8fe82e1f8baf06c37f013b5b951a27b590799be0a2115b570e52efe8528afdcb865d982615ec6bbfa1e6572bc261034c02340cb43db7cdf49d23ec3408c674babb0a006efceb822bd10e5974ed11847601484e063fb93e399093544a04b36ed36b0a1dfb8982205ca6b2f8d9482f0906c4f8654c81ec3c47960190dc4aac3f1fee71d7307f76138b0a2fc604ec33938061bc6e907e5b16448e772d8bd173f7e39ab60d793f47f683d442abbc1e0c48f56ec1042ce219bad22ec5b5c4e4d5bd95116cc5f24008f82761db98e23697af80e9f95e2e26a9adb5908cdb525c2d423f63f8f6a1f29f4e2d1809cee03ea9e36e3956290978a145d1a8f3e44263c6e6be5b13f17407a0ed5c17fc75097f07fa0bcca331458d402a9ab84a63ddac5c8c5dd8fe1a5fc7c9f5355cc17cd43b0ed7fde9bc4cdcdeb0d339e0aea0db468f9b4f251fc8db4ec6ec125a2df00a9b8fa24ac577c7a915341cded36ee504fad82649246a4537ddfa8d524064ffae13eedee1c95a1afb0c4653c00da2d13447849f9d5567b44b05fa7de4c5a15812b97d441197d9635a8240d73b0c7b0eb4b4fdda92d9c643a3a6d9d74cb56e9066f9f16d6b8ad5e1d9248014bfbe82586c94810ccbcdfdeecb860d17727b039c0c9c957459698388faf89c96eaebb3236fc1b83086594d8a672b07ce71997fe2b2ae7daf2f55dc0848f34bcc61b5b369c94ce132f826c375459be0cebc5fb05619784058fe8d0e9dd48f0fcd98b2e4958ed4bfd4d45bf4d7ac2f9acb8886ff438b40cf99f5bff7301c0d9cbf6ff5223adc9a15d88fa2f225213a84f5324ca6ea86e11aecb65e06adf1d618e4c4fc83a5bae50eaec2ccb49b8ae3289b9c92ca4cc429dacc8104979e2056cee173d965db0b5f87f3a20c927fa948da9036ea8517f8126e30140639b29ac4a8b64a66bfa367b94aa931a004f5657ca37d3e530a8ed9300ff0c5b1869b8a284c5b6e146ea486fa0f599db3c705690ed11767bae7982db42c0f49ddec8a7d3f2e68798da305a03b0618cd268453e24b4e3b1a773c0496c174a869d2327c9aee7672bfe87f002e3aa7d4f5fa7d4c259697406b6704651770dc4862d2e4e5cb07a725be616591e2c52b9cd55826fd10e30a1795caffea10586db564b7429d1323e769869e3166404dacdbc38dad45eeffd6a713fe0492d2d27a2737fed5d1bbd094b56c2b6fed59d70a3180bb135009c661621f84ca889310628ee842d424e8ae55aa77f51da91ece2c8669ad9cb9ab1cfed90de73e694860193900debd9bde6accf8816ab4a8e9b0b0a5f59d1d1825d19f29598c6c4f7982fc6a494fe6f7f69129b8511df60c06fa50b99a13e156497051d1dcf22aa73c74d958a61b5507ad650ff72b10a77a5265152978bc46313f8459d5407cb7627b95ef0ba0f41ccfcb1d43930ebcb7b3afe020410b80e5553565c4451545acfd55e04c675964f052e78859ce4fac6bfc32cb9b2fb5bac15694664f90d5cde901cdb82917ef2bf31c8997934450a13d0e3ae7d93fbed31d9a70dd1f0d03769056538001d7ad6b5d4ea617923f97dd7d17e89e8c64da513f7f47f924901e744690923024ae2f382340ff406c389887fe10dc9c55f1fc04f38f2261f59c6abf2bce832fb1500fc681b0cf5893bc4f6e546f6e05aa6c2b00f391b8f1c8653d4f5bc5527b0528e9cfea5eb84ea96bf81825c52a708a06d845bd145ea724133df252a72eeaf3abef4ec4e149a720819e949439bbb2f3944e6ad7573195b1d5cab7827bab6e861c8ab5473d555added8253df01ea88947d97c21bbb2f4cf89879e288dc907c36cfd4a163d2d742bc80bd77e29d6a7d5e429de5831f6db4576391709b9270198ecadeeb516d259a338015214275ba47e7e91bbb2c39426acc6cdeceadcb36bb98328b4e6c296f41e6a3207f5948916ca37183e34807d3b8e80506c805f4cb07762bc7a7d8eb831af083fe82cb201bd23c639dca8525f0dc7477b1550b4e05f26016870b6649d7802fe02d68e11cfe370fdc9ebadc01743f90a62b9613ac428cc82839501c0292fc20028808d9c5b8393496bc4a7b9577dfa150eff728e6a0125736e44d873ec968809c172c40f2b521686e089f466ed8b8ba2308ccbc2ca3e28a5f17e5750deffeda8eefd2bdff03fccbf6afead475454fba1c0a4d9bfb9428266405ecc108e2f46f19794316c15ad922bce722193e19e2f43f4b5cade9e78bd070b1112b8ef0d8260fc5fdd30a37a8417fa5cedb30acc0640115ecc2834aacfd221a0e16c3f36e1b3dcc293698d14d0a730b6578d477b4989b20b18c43422a8c46bf9988dae59ac708e6a7e85859eae04116ef1df5031ddba3fddaddcc07ad7026f6e1a8c985e0444bbb48528c29f2e17a42445486bddce2662f4f3e956fdfc609c9b194aa5493918cbb97ebf147a3c5a906a67cebe14f493ca9b38470411f924fc39b22489b691f4837d39f20af23f017eab264166b2d3a15677296cf3469aeeebd984811a0e6230170ab3332b0f0f4144a46071d188ee93584f9eba9daeae5c01941b73b35cefcd70cec8b0c390fbaf1a612b4501e77e65c0d31158572cf90db3a32fd43e3bf71557d84e9d628f72d0258a547e8d6cd726d795cb766287bdb85c97566320a9cd9360c778be76f098b9d0cd3670d7e248b05f2164d4cb8d422d6dcc6d781fcaff3f60f91d54a6979853f0798171446e55b1ba13f0155314760c55453ff462394a36a732a11e5b2f5c330ff1fb25f1c50bff297c85ba0e469b99ef9137b28a3c1610d9ea2f4a03365777efbe43808035af75a6b06d8ff3e67624768437ac05189390e2612556ffd3c08199d03c4358c1dbe300093f019807333910e8097fcf6db171f77cbe8b8b0dbfb25fa07c9dc7d4af2b3abef380a9e310a33601ce0a7d13dc1f6bf90a94ba1b44c8db78104a902f195bcaded8ec7a4695a66fc46471a712d6ad0148fbef380ca857066bf9e76c5b2008c17fdb18171cea61af8cb48f0251a759a3f78ce222b667fa692d4ee21cf9f1d04113be12eadc184c6a359dd9fe3529dc04794f1c18619cbe3aa0b25b23ef75c4ec75d373429083edd253a96a027890b04e65d53b1644a8a65bbcf058dde9016f4f3f896c753f76b672330b733f5641168f85f8cb4b297d773447de8ef20d512f97dd5942bdff77ada33c845afd5a9026952c6c58baa8340d06fe0d997ad4a3c0859daeba27e3482376f605f7498e25960bb14a3d684b91650ebd82e1e671391ef64a7416b7a9bfda41b6e0aecf16c59e3fae0913e4a2defb52afd7490b41ca52143142bbac9902b8487eeb825831d078cc25ffc9fd02cea50630ba1d7ed24ba4831fe838659a33eaf56134102c6a9fe838f61451a275248c3c5b8fb8c2917384ee645ce0089dd7b2ec986c6d477a6492f91b270783f67c1f4bd11e1f4376e43a2d4cf8c163981721fd75d2c04a34c20ae2e9369cea55b4f75b8146a8dc601cc0206165272d30937a66f5b3b9cfd3d45ffedc963605083da41fcbc3c63471f729eb4e54f4924c4efe085b96730e818d6c24a419979a6264559e5a24fe335eca47a9e68fc39cf4cb03362fceecb1d1c04bcaf6f3833aedc7d63846ba4010ccc0f202f65b71d3280e6f6d7f49c11fbbd2cb6bf0192d69f86de3024f12f49a17c7bbbee0935607d7e511cae98582f988e6b6b78c2e017d98663a9ae841acf72f6796cb6342e10023b1c9b8b0d27745d9d8a7867f134eb0071c5cd09bb8965e6b2ab4cdbcd1b5ad763d1db885c0fc784da07546435062b2be6283d493cebf5cb68c2e86c9799e1b5bf666d8cfcd4e38ede83111efe2da6cd55d0b49391726e85fcf7e95c60db7bee1c171d9d1a0d0bdcb0ea1896b8750ebf9d87291fc263a3389cb69778069ce349458b75f420df4d87ef4615db79df7c5577567f66d881e189ec8cb9732a884568079c8fbec378d99dce7ea0139db5cac61a6394ef97cb087d43607436ee74e334c2e461377ab4aca99405ac4bb01faf01c843ce315283523c4a13773228a93f7151d5180618788a55692de091df7397b43b5f8b87da7086c849457f906784ca090b0dc86206ee4596ef4d8d49243a27025c689c06269a26904c22bc301591994fed16b94f621bd5373ca301a0c67f804a0774f0557b1e08943590ed72873161e4903c7fce3e4fbebe92a0182d2923bbd1df8c4bf60cc0d5b2c01c186581132f18939224d53b8f4339ba0be666af861e94358f93e869e8aba2210602c9d0a68d6af354c1f10afd1772e929a0bf0725635caddcd7066781b85cc18bfec0f7862d7e6a9a265797ce3581ecb5e0f5adc773a6a5e0454d65f8aa826dd399a64f95b645633e32b8bbc67c41b3109f7072e0ed1f5c175c0843c96c0e63cef0f8b8a57d146468dc03e4c9d7ab1bdd62ff41942afd9c3d55a081f08748116840f654ec6022a54953466fd0c2829dae9536675ecd846f680ab3669bccf9c52d74b06db82dae492102fb74a390ba874df0e5c43c468691ba0a72db503d902dc9555115d5e936c5648eb2f23ad8d38f1f4338575ce23e2448392e3b96ad1c9cd096b55a3d72f2d38eb0b50b9c9299f4ac9c5b85c5abef91c70ce8508e0213e1f2b2770ffc06aa749e0b268ddd3ed1d884cf879f6b4027b92276747746537b70454f0bbb96977f06471b1eac113b5bc32a03bbce5123fd828cf9a2f3c2cd604c998f585ddbdf804661d76b1ec536418eb29e4982897208f068f896a07e5f1b4b4b19f3cde72981a190228a26bbad5287c2f563a44eb574a4548f0fb415f7f68be47464cc22f0857caccce209aa4e74ae79d093d8def5211642d4e9ec9b802792b43a5c83d620e59343c619fd481c5f6ed29682c6502b7e8fef06587266198cb1c29c7b8957ea5e518e234024ab6fdd72295ebc23d1a4aeb62542d0736a67808f2b0e58fd80df7a28ee877f160b66d58844e7b7e3cc4e09876b3f685092487cd1f1d9abe0e649207950adf08b1eae5319de31e5360076f37c0b72ec5468a88afd7675d6eb14c325e5887954b46810ea7d1f533122a436a3f5d01b0e6d0f3f3908dd4b2060327f8f196fe3a9e66dff779494ab15775438d6f5ff700ba6820ec0d456952da1a6762d20b1308981d725977d0b99a0ddf8bb691c545e4492cd6000aa7a4cc18bed9eb4a963fbf949c3412869afd0349446b723389f119f3d0097ca3f261cd202e5aa983ccc6e5fae7846adad67347cbb6dfc9782104ed33a36dc5c6965eb77a609b85a7770ee10c481c1c9076c98cde12e188c8b5403a6ffb46dd4dc62915d46cc3600198ca693d3b8cf542fcba176974180f5495a218537a9ec19431b28f2091e36e2405934d06d923af34d049cccc4b8a3495569228e1ae61955bc2235394a456f008f3d2a41e97f68e19617b847f013cab6974642a321f71963bb044af568634ab4e28026c3b08f75599487f4887d33ae503ca454a56a88eee4a8901fc23856f896beb8470c73fd59175b3cb5a6d8e4e41f75505a894a92ee315839d1f26548bcaf8d5736a3b0ff0f1736b9fb13da80f79355ed5ed7e0f7b6c630d186737ed3b3420e75ae9dbf3f97d2b7fa200cfea8302305e1ec76160b203148f919202412a2a0d0f9a3918b1a9a16c1a1fc3e97004ca4bc33d3df105dd04eae1af90e63d3e094ce95af76dc50a4dddf57c5f04110d47d1ef86a39c1367303bfcc13799c9053ca9e7a02e5e9cc73c091730025a0bb2342188f68e28fb3c1394f6317b60e6cfbb3c25aa43f75c748dc9b69b5b13e5d53f5fb852e766fe7b5d0965c42d5f9aecedaf668398f798e86db06f1888f57e24bc66f7e3197c8125bf52e818ff53884e17337b1a893fe6555c3f83d06f5526c63cf796ac745d8deba44c0761e0f5a8af15e52d91be07d7d67c380968e74d0f7001d43a90bf2d6e52aa0cac4a77960f5cc54a0872b482332f36b8bd0b3cc4ab36131f7ddf187f2c47540f00bcf2cdcf4dfb763c07381489ee7351510e47cbd5df38f1c5fda7cfbad46910da62dc6112bb5fe8fa6be41d973596b8aa9e23eeb2c2874214478a5d9ad81adeb76be4bbb059659abc75f10b952c1f60433c7a23b4a8c752afc0f36347deace04ee9d532e59701ff59358ce93c61ac64d0bf60acb3619eec7d28190bcd23a4f2f996306f288a1f14f951b56994665ef83ada9abfcf3974c5062ad20ccc7a130ea0430fdac1395289f94069e7b3b5b787ab75b07c55208190438dcb365ba418404fb1609970d41b5de10b665cd08c5c6ba26454dfaf69d6f7ef09a3a57eab16b3498461e19bd67a9f050d0c6d989b4c28110bb7e9d56f80bdd1eda586572f13d15ff0204eadf04d682a15fde4a56d243c2123753ad86dad82436dcb5f92a7c66496043a1eaacc762de98e757b2444a818429f852ceec3d8e70087860325319544ecdf9fbd877293bc7bce6b627060b6ecd8fcf6ae4462cb5bda134de36f330d7b237c665925a648933213985cc077b2dfc2dae1f513d349f5221dbd13b7e9c19d0b998e06d6ca4a7adb8c280629d94e19e637f75e0c5dc5c9f1e7dad60f97c9778c790be39c513869f9281f626c64d0441f62a18f470bf1ced211b71b32292c8827a8805f4b2d8f42d6e6a588330589b898d7a977a8a078c41d3247194f907ba5488da0cdfff5c13a9e724c837e4ec7e5d0e03c9729506035c0166ba3cb419928a01624b811311d330ad68b4f57cfedc63f523e356651c0a8fe0c0a8ba94f6db4d75fd72bc793975932a9edef0380e01efd0893e0d126a6451ddfc273bbe90ce5d185a6de5b5c70d50aff095508d0a18ddb0f8ba3541352102ffed48d9cc6b5493c89cb297b2e8aaf3ff77df3969c9d45e33e2cca980f92e16ab84a31b08ca69322c6e225d9c0735715326d2eb21da17c4cf00e7fcc1bd9e26e6532709f9b654c0ef593159ce4465b12f42824394edc684fbf177f88736923efabf890a4f3a86e04ac5944490f6fbd1607fb9baa7e612cf042e1922e41d6746613855095350085be95df325b0b1c5d41d2ca4231da9fa36c8ebdaf3d135f18ff5cbc2b76dc67445f926ecac48dfba1fb5a8ba9cca85233b46e9a8315801764c81d6dcb2df1a93187f60c8c4e221ffe3b46d5d5c41df3b41e2805e61dc65cb8d61b893ae6e7ba0b2adb8c862cd29a667870f1c2d73e883279b027d373fc2ac03b73968cb5d4bd6220c0556f93f1d9dfcc7e1e30fb1703c691b2776ec0589efe79f5c83b0ee24c2fed14d4a8a3dc81300d1215d3646dfac19428dba3b3f33e456b14979c51d1240baada8016869427d40d70584c4d457318188fbcf7dff806ecfc20aa77d7eaaecc1edb10841900a0e14fe42fa4baae12460f13ab2646f2e090b82924e18a044c223f348b48483cddb479af1d61fc3b63ed1a16119d069ec2a2f4509813d92505d6a8d1c1bad3f843c5de60e0914323da4dbbb4623730cdb3249788467ab7bec4f319e0dd11b6053be4ec1fbe460fcd53efd40f338cee6fb2cf0dd17f06390c794e9422745d663967f7504d677f9413b57cdc819a63b75930411546c82cd248e440b8be9c87ad4fa6460bb356dc3af989ee425d5e7054767d1fbc9cf36af8b12d012b72b7af6840bd3f5b090cb8a02c69c9b807c64abaa6ced1e86e289ba1a470cde3011babd632e717c22914ebb0bafd6b4e5842b0dd85a9c171c509564e608078e2fea76ee86f878c44699e47afc23e8eae2b2fb1e94729301fbd7036eae7692068223adcbdf44586734d2d897131904a071444f6fdc03234d01c84c1acf1fce81a3e2c298df076c49f222a5fc4be31ff76c6467d371817cecf9ed24ba5ccf78acbd5fc3f30e6607ca58bd5999dee00f091162383e252bdaeb4db402c2fa4ed970ec5786f2e6ca329d878f1239b4946842b4ed2f9f289874e0d8525c423a200bdf3924dcea6f13596325bcc66a84e899797c8a065f61d98e7ea1cd39a770a113ea25ef14646f9b1e488d5c0a54207a8f65cf4a3c7b5294a0a977d1ce0303b97640075f6d8ff01702857e71ea9c8dfb0f8cb886ce4a27042cc8ab7c362014b67f88483fb298b2795e77cdd205929d335b557d1e4650f3393a9bf50eb2eed223c176b2f1531b9fd9f23277e7fff42ecd5c3960ffb01557ad4710a86b30cf20a5ed657358805093d40de783dd7c55ba9ebeb564755d8daa2a036320097774a43c1a0eb6515cb50b27068bb52af5b420c55090c273af409600cdbb7c5d2f4a7061e468f1b8f2d8adc1906b0bbee6708e98bca6ae40099c5885cf6d8641bb951698dff2000f8230ed3050381b0b8330d3cc82b66cc7cf7ca27cf7ded7c3d55a0471bfb13c6d8dc1824438eb37e9fbb66c956a52e3c0a7b9cc16c39b4e9a5de359d5b8b5d1c9f1f3b3612f34d553c7e7fba2eb82746b63440db5d521c86d4829d8d5c47443257f55eca1e9f5d8801ada32a8414c13c21f7af0bff3c36c22c9c61a80b205dac6beffea74667afc99f76754ae0d899be80be8ac2ad30980709cedd34f3a73f8b1b2e70c740820472dd34efcc6e66eedfd53af9d8ef3a3abf5f8437897af4a8891a9c08338f97a012dd45902a73e4957372c01dfd6197fa31c391526a36289e1711bcce1f3fcb7244615037cad245c5d2a2a63a61b4812fb5b57c2eba041f034edc5a0eb219a073ba409a01c9540d5848746c61a19fb8cf846dfc435c48aee3f52997a5dc12326b0f8ac7f534ccb0679e55ed6d212e6204fc9af72ee06360f6a5e7fefa5600e7265b2c12c6b6a5359d3b04c418bced3cecde1e7183474d47e9ddfa5b373609bb4359376567ef74cb7a14f8f36342a81c1d5975b4424c375a0f9f2bae228d0af263231517f65a9550b03ae2fb05bfc4b1c4840da51ea6a93a4faccb4b8a4a4435d40219d99c0b799a5cb9651912709faf98c6436700a7f0e48b79f09adbef7687650f44d3183b5c353211d72ddca2b28792ee04ea7c3094103ee65a1cabfc0ed008f0fa9548021b57c145a768a7b8d612091903c734ddf3569751a88e2932aba077a899549ea403b7f06e86f6f3e85fccdd2c8ee9e319dc6c58ee4f6986ed0c2c98027de3bf5c4abc8b6fe5470e1f9aa9f33e15465b7a8a94f40c222d0833cfa61086ce23eaf64ed83be2bf5e8f59ec8541933c715c43152a3987b1f15854156d10cb1a043a852c57d923bd0f70c06df6e93bdada3079b5cd2012cdfad12062bbd8c987f772b7928678e13bf193015f61ed1fa9bfccefc08c76802651f164f921ff8fa4b6a3b7a5532e2f4479df2d8c8088f59463cd4dde3c40ab5e02c018e0d0c63caa7a4f026ae1581a6a1ba7c50150652f6d7cad3c2ef53583c6b3dabfe4eabe22246a7ab33fa9401063c60509280f3e56bb2d659cc0e6ee5a576422b2be1f5bd2cdd6c0e5050453295d519e44fff676133688fb361591994b3c3d664c0f23d90b7c77c6cbf2fec2cf80e4b7ce64c300fcf01a37776579284753b00b61814a94a0ae6bc46e02efa66e9e51fa82214d23681fe1142c8cd1da570d0fc577e7616ac7e6027d40f628ecc0f31b86b2a43eac2197c4859ff0af7a7882867562be867792196896eb2c5f688475ab4451d40d07a225a8d03b06ba553f3942365927a43d9cf3b04a18980ecaf0bc18687bb86ea34c9abbef3862f2d6cea697d5d216c3e4ed99b465acbf976557ba518047b043ecb660147350632e5baf7b7d4b1877e14479b5d9a71ad959c826977ab137bdf63f9c6db5c4de9f45ab6eae23c67eba113a570070bd80d3373ce173aaa975715e3a8309a3d8cc160c23f4071c517f2a0bb5837af1c24d5500e17e8147173b464e4346e13f6c2127be324b55868f356c37a7a884ad9f2b27bea8e0c7a9a63bec88d5ed0969f86b6f20c17d69d4ac42646a0d57c7749a92164d1348caaf21e4e3ec214cae7d0b17eb1131755627f55c51b15a05f9955da01f9d2cf4895e42c314cd342864c716d2af1d638384bc9f4627ccc0b6c623276c12c3c8e38bfa95ee40ac8876223867cf1134fea7b4b1dc5273eb1f7a037175b1f64e37cbd2462a5c86f6ff7d9b6b83c0b4c4cd3e32d9a443d30df199a566c06ac8441b10dafeca709cfa4326298419ce2f768a5a3ed19d3b67909f14de164668eaf512dae2390716f4cfd154887219410ce0442933d014a02ab4bc0f1ea4dfc3f1abcf7d20344269c07196dd8ef1a7030c137dba125d4de3169ae305581a12a9835d2033a8eaf2302854e4e93b1ebfd79965208ca60fd0caf5e2f884b2a4b4d9ba2e80a72304f25cc5b0981fe556ce0e66072894645a308038912c0db038151e2e423e25fa99fd81854cbd8fb0c382e197fe5f0457d50850a6c322ece27410f3bd77e8061250b859f052c551df3f7158c85d630adbc641d42f978dd76d48bb5816745abc1d88771ac6d332ebb9d29095c9c83c9fc74f48f54ed9f51b3fde53a3a3619bb24b5d6d06ce9132e0e47492c6f3c347c5f7689579fb4d8334f51576dfa33127b461e697ddb38771616278ee5d45fc30cfb508564e3a808afcdf47dbb5b44bee94bf1c2d11dee6736c8d97b403a3619c5f28ceae12359d5f23f13d519b9c8420ef55090bedd5b12b6153275f9bf6e503bc1bf79553833e633358138fecee8f3cfb850acbde0bf69fdfa1093d8da8a6a32f3e32c075e55f69895eadac2c638176c4aabee0891c511dd8636efd8faead07b4135348e56630afe2dae503fef143d7753370ec13bcdb0c3ea959a8603d4236d87d221e735986c3325648ff72ee13f950ce8225f9b004f0df82c2b3655cc5e17f7b719d24c780a81b0eddfc759e8669980f969836c727f1e127438a050587d4d4357bdab29b3dfbb82f4360ef7e65c5f9e8e0f52bd8533d6f75aa66b998d549b59f9fc54082acbbfef92167d5b864844aa587e59dfb39df668c9af8fb71a5b14142bad70f40c09d4c547a2244d12f820de2bb8eced37b129e15d59a25227b502dac5290ab6b6f3f2fb86f89d48bbe3aa4cb12191f820e44d22d0c1128c3a4fd2ad03fb832b80dcaa3db3f32af112c9796039e40f4d0f47a686e67740690ee87d84c525f9ed3ae474877c9a31160cf725000d2003d8570b75637c0176b68a1263cf6841875ff103cbfa7286851e5845178a64ce047cdd5a005e4b9cfa610c19cf9811276a27386506c8a6f9cb1eff45abe7287bb02025f3ccb8bd8a5bfb788433c00f517e5036fb4fc57dbb07eb85ad302680267799cfd249df52d6010537e812762cf2a3f270add14550631190ae74829f407d0b652dda3491a0825561844eb5d70983cb3f9b127af7957d9524e3223dbe57ab57ad14058943d399abc0e8ed7f603ce7de2a28bac659db3161329d1246283b80cc87a306680db2165536245d540e51c8df51028d0cee10e06e7f5a3062e652c2557381a0d1b9ae351056a52390a829d4d5d791702ab82121661da3f6441c028837082e6d77e8151ce5aa8b13335f4fe2140bcfd5419ecb96f7945fc16c3772fd8b9be2f11fc8ed66e29a21eba0171ac7a64ac912ce2c2e5ee88aee127f34dde4401d0e005ea56a0baf3124d80fb256f7996036346d983c4cd9ac01788373856c37f4262766e55b17828bcd563ab486f3efa76f1e288e558ab029c2fbb7c98c08ee5d51c16702d8f28118a1f1b213f926a2f442aa17750a47e3e6190153a5279390f0063365c96ebc574a2d6fb3bec88a2b95372b68ffe604d4516566317d8f1e1e6daa1a7fa711f158f04fc74b2271e118d3def4daece9c3c316931bdfaf5594bc84bbec5582efa7a21e562fb9f68333a9fe72fb93c2809aaf13814bf18e7b493d8eed36aba857ff1bdcbcaeeed819900650d16a6136f8f63338b46389ce3d10522ad8317fc50dc94b277ccc7f0f27dfcafad95fdc2f21bcee2cf08be7b0058abf3afba1ad6ee8ec0e56e1f64315d305c11fa233ddee852624bed169b298ed92b13a63c1ab523318c1684634eb7c2a22b23f9a46cba0d5059548bdfdbbff55ab59951ac0a87d638944f0af74204b1eaa98be888ccace4e8050535234354c6c1b1a8e1a4ff3c4e645ddb92f12e162ad6fc9852fd823c6056a279351e8d01699ec71eedc9bb98d6085a38dd46d0e292b2426ce87696e7cddf2d00f5be06cc46fb6ddee3ad460ac4770d762d70f2f7baafb94b6b8290ef73bd801a3878292f68f9477f3cd1c98689cb44a2b5ec59663c260b850f8bae9b70db23cbc7b58e7d05e2a2d326bba6c792abfb27a3448d445e4aba79c559475dd8d7ca84973c59104cb2cdd801a9c253818442f7abec360295a29219d2ae7f312cdf791edb130285a96435d4f96aaa5bfb0659dd0d1c866faa094211add498180a0a71c05e7a6a790f481f9ae8b4cc8c5718afc9949ece79dad04734f2dfd2504036e8f0fd5c022869ce2f2a1f831605ddcef06fb9ed0aac50c376c7d8e90ee338c4ea6d150f732d64633e19bb43f4759cade8d58e51c72fdc35709bdec4d5cb5f406bf61a7b2565ecf4862771ff1df34bb4eb2f59532562efafeea215f4e40835615c88b3a39135a686996be2f8f47126ae04d7f955b958be4b0e6ef8a2267ddbfc27ce07ea1448259b86cb9e9538257ea15d547e59311e4d7ea4c58d3cd31bac3828ee7691ef852dd1e5d2e956d0fed82b1a1a41986b1051faeaeca6bb25b7521ba99233a1b496cc164efb389e79f5fe649bfe118c601088cd777d5de5c350cb4a2c066fa62a36aaf543a6ec917e45b817f0d3cb27ca8430db6f2acbc0ce265f5a9005dbfbdb09e0d872bae5f71ef1c04eb6ed56bd9b3127633177174424de8d8edf5bef1c18e4b0fd7aad9dfd2586a37f82f052ba8b9039e715de6b7118b4c16e2ad0ccde682af15f084641ab63d674cec0f9f4b9b492852cfeca0e1ff81e27b49362283d0fbb73de21321631a562349107b4306a2c3051123e92c0d84cb859620287713908023d133d05e44142350a321441168333c1aa071581bbe8ce5fe0559847ddc48edc4044a4220079c72036a4644bca857031b252b4d2bc1b959537a8bc5bf73be4b5e768885eeefc46e6a2c6e92f2b78923f0ec12cbfe29d484b5a57a5ecd8a9453ab10c8b436766b374a4105949c847a3db43ef238bf0a8389df1701c7fff51d0ff200c821f36da6e4853f2e1334f2423d07a1a469c68a27a1e836d08c92439e3f5de4ad34879c7e50349af77b8393e68e7fd3262aacdc46ab4645eae0bb7496bb9c7e8961efaf630aa806d630a2a2b265001844e76a5d59cd34b4fda95e536e43a45c1bc2822944d86ee0f6611832774c0779aa8b18654239cd824f476ce9829aa8b41f53bd67f39e4a1bdfdcbdb5d582c631f729c225d16369ed6b74702c925951be3a86f86598621d19ac8dce58b9a7bb7654ebdb8e89bb49bc3227967b6a75a9a334364b8bc601571b3ed60dc2f7b875eeb31b5b403c49890b50043a73e790130d44a8a2c12a0da8a3343a962430d32cd64552161b4b7ff471b08751f9a82ebdcb2ba17727fc09ac143c354f797a6373693877c4178780c68cb5deae985944f97a7d3ac22ebdea58b3ebe495958de901eaf0ff65fed25ecb3e16e14b07fd3624fd4f6f07b7460aceca3a6dc6341fd97a9088edd2571ea5ea1b44b2e1eea0b21feabe76deb5dc5714435f0a1eaac5a8778dbdb65356135af7c091c731b338da78ac6477807b486f3d0166f04a6e6d269b98ad8ed6a8f92663e8210cd1d302e95ce01979d0bbccfd861bc943c6545a41000fa226aa4861445c43a60bfb0078cd64471326870f7feef747ebbf69b024d50474b2d358a0a55a605d19d125e8737d75</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Array</title>
    <url>/2020/01/01/20200101-offer/</url>
    <content><![CDATA[<h3 id="（1）二维数组中的查找"><a href="#（1）二维数组中的查找" class="headerlink" title="（1）二维数组中的查找"></a>（1）二维数组中的查找</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==0 || array[0].length==0)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        int i = array.length-1;</span><br><span class="line">        int j = 0;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=0 &amp;&amp; j&lt;array.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target)</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><ul>
<li>第一反应的通常做法是对二维数组的中每一个一维数组都做遍历进行查找，从上到下，从左到右进行遍历。可以实现但是不是最优。</li>
<li>讨论区大佬的更优思路：<br>1、矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，<br>2、因此从左下角开始查找，当要查找数字比左下角数字大时。右移<br>3、要查找数字比左下角数字小时，上移</li>
</ul>
<h3 id="（2）数组中重复的数字"><a href="#（2）数组中重复的数字" class="headerlink" title="（2）数组中重复的数字"></a>（2）数组中重复的数字</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//借助辅助空间记录</span><br><span class="line">public boolean duplicate(int numbers[],int length,int[] duplication) &#123;</span><br><span class="line">        boolean[] tmp = new boolean[length];    //初始化默认全<span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[numbers[i]] == <span class="literal">true</span>)&#123;</span><br><span class="line">                duplication[0] = numbers[i];</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[numbers[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//不借助辅助空间，在原数组中标记</span><br><span class="line">public boolean duplicate(int numbers[],int length,int [] duplication) &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;length; i++)&#123;</span><br><span class="line">            int index = numbers[i]&gt;=length? numbers[i]-length:numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(numbers[index] &gt;= length)&#123;</span><br><span class="line">                duplication[0] = index;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><ul>
<li>常规做法是使用一个length长度的数组记录重复，boolean只占一位所以使用boolean[]占用空间较小，空间复杂度O(n),时间复杂度O(n)。</li>
<li>不借助辅助空间的思路是如果数组中存在两个A，那么他们的numbers[A]指向同一个元素，在遍历的时候每次都对number[number[i]]执行+length，那么在遇到number[i]重复时就会检测到number[number[i]] &gt;&#x3D; length，而正常情况下数组元素是0～n-1。空间复杂度O(1),时间复杂度O(n)。</li>
</ul>
<h3 id="（3）构建乘积数组"><a href="#（3）构建乘积数组" class="headerlink" title="（3）构建乘积数组"></a>（3）构建乘积数组</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]&#x3D;A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int[] B = new int[A.length];</span><br><span class="line">        <span class="keyword">if</span>(B.length &gt; 0)</span><br><span class="line">            B[0] = 1;</span><br><span class="line">        <span class="keyword">for</span>(int i=1; i&lt;A.length; i++)</span><br><span class="line">            B[i] = B[i-1]*A[i-1];</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        <span class="keyword">for</span>(int i=B.length-2; i&gt;=0; i--)&#123;</span><br><span class="line">            tmp *= A[i+1];</span><br><span class="line">            B[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>每个B中元素可以看成由A中左右两边元素的积的积，分解为两次遍历分别求出左右两边的积最后合并是合适的思路，类似矩阵上三角的累积。<br>取一个tmp&#x3D;1，从A的最左边元素开始累乘，每次将值赋给B中对应的元素；再从A最右边累乘一遍，最后合并即可（第二遍顺便合并也可以）。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-array</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍 III-lc337</title>
    <url>/2020/01/09/20200109-lc337/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<p>输入: [3,2,3,null,3,null,1]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \ </span><br><span class="line">  3   1</span><br></pre></td></tr></table></figure>

<p>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.<br>示例 2:</p>
<p>输入: [3,4,5,1,3,null,1]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   1</span><br></pre></td></tr></table></figure>

<p>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii">https://leetcode-cn.com/problems/house-robber-iii</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(TreeNode root) &#123;</span><br><span class="line">        int[] res = helper(root);</span><br><span class="line">        <span class="built_in">return</span> Math.max(res[0], res[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    public int[] helper(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)</span><br><span class="line">            <span class="built_in">return</span> new int[2];</span><br><span class="line">        int[] left = helper(root.left);</span><br><span class="line">        int[] right = helper(root.right);</span><br><span class="line">        //计算偷root和不偷root的情况</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);</span><br><span class="line">        res[1] = root.val + left[0] + right[0];</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rob(self, root: TreeNode) -&gt; int:</span><br><span class="line">        res = self.helper(root)</span><br><span class="line">        <span class="built_in">return</span> max(res[0], res[1])</span><br><span class="line">    </span><br><span class="line">    def helper(self, root: TreeNode) -&gt; list:</span><br><span class="line">        <span class="keyword">if</span> root is None:</span><br><span class="line">            <span class="built_in">return</span> [0,0]</span><br><span class="line">        left, right, res = self.helper(root.left), self.helper(root.right), [0,0]</span><br><span class="line">        res[0] = max(left[0],left[1]) + max(right[0],right[1])</span><br><span class="line">        res[1] = root.val + left[0] + right[0]</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h2><p>lc中等难度题，题目容易让人想到二叉树的层序遍历，但在这个题中一层偷一层不偷的两种情况是不完全的，因此不能用这种做法。<br>取而代之的是使用动态规划的思想</p>
<p>对于每一个节点root，都保存一个长度为2的一维数组</p>
<p>数组中的第一个元素代表不偷root节点所能偷到的最大金额</p>
<p>数组中的第二个元素代表偷root节点所能偷到的最大金额</p>
<p>然后通过递归的方法自底向上获取每一个节点的数组，最后取跟节点数组中大的那个元素就是要求的值。<br>这种方法非常巧妙利用动态规划的思想将求解。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-String</title>
    <url>/2020/01/07/20200107-offer/</url>
    <content><![CDATA[<h3 id="（1）替换空格"><a href="#（1）替换空格" class="headerlink" title="（1）替换空格"></a>（1）替换空格</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//use other space</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    StringBuffer res = new StringBuffer();</span><br><span class="line">    char[] tmp = str.toString().toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(char x:tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            res.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.append(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//without other space</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        int spacenum = 0;//spacenum为计算空格数</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        int indexold = str.length()-1;  //indexold为为替换前的str下标</span><br><span class="line">        int newlength = str.length() + spacenum*2;  //计算空格转换成%20之后的str长度</span><br><span class="line">        int indexnew = newlength-1; //indexold为为把空格替换为%20后的str下标</span><br><span class="line">        str.setLength(newlength);   //使str的长度扩大到转换成%20之后的长度,防止下标越界</span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">&#x27; &#x27;</span>)&#123;  </span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>两种方法分别是使用辅助空间的和不使用辅助空间的，前者简单后者重要，另外要熟悉StringBuffer的使用。</p>
<h3 id="（2）正则表达式匹配"><a href="#（2）正则表达式匹配" class="headerlink" title="（2）正则表达式匹配"></a>（2）正则表达式匹配</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean match(char[] str, char[] pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str==null || pattern==null)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        int sIndex = 0;</span><br><span class="line">        int pIndex = 0;</span><br><span class="line">        <span class="built_in">return</span> modelMatch(str, sIndex, pattern, pIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean modelMatch(char[] str, int sIndex, char[] pattern, int pIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        //匹配成功即双索引同时匹配到尾</span><br><span class="line">        <span class="keyword">if</span>(sIndex==str.length &amp;&amp; pIndex==pattern.length)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        //pIndex先到尾说明匹配失败</span><br><span class="line">        <span class="keyword">if</span>(sIndex&lt;str.length &amp;&amp; pIndex==pattern.length)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pIndex+1&lt;pattern.length &amp;&amp; pattern[pIndex+1]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>((sIndex&lt;str.length &amp;&amp; str[sIndex]==pattern[pIndex]) || (sIndex&lt;str.length&amp;&amp;pattern[pIndex]==&#x27;.&#x27;))</span><br><span class="line">                <span class="built_in">return</span> modelMatch(str, sIndex, pattern, pIndex+2)||modelMatch(str, sIndex+1, pattern, pIndex+2)||modelMatch(str, sIndex+1, pattern, pIndex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">return</span> modelMatch(str, sIndex, pattern, pIndex+2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sIndex&lt;str.length &amp;&amp; str[sIndex]==pattern[pIndex]) || (pIndex&lt;pattern.length &amp;&amp; pattern[pIndex]==&#x27;.&#x27;))</span><br><span class="line">            <span class="built_in">return</span> modelMatch(str, sIndex+1, pattern, pIndex+1);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>这道题第一眼看上去没有思路，同样看了评论区大佬的思路才会写，可以通过双指针一次匹配进行判断，最重要的是pattern出现’*’时需要分成几种情况讨论，这里直接贴上评论区的精选思路：<br>链接：<a href="https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?f=discussion">https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?f=discussion</a><br>来源：牛客网</p>
<p>当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。<br>2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<p>而当模式中的第二个字符是“<em>”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、模式后移2字符，相当于x</em>被忽略；<br>2、字符串后移1字符，模式后移2字符；<br>3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</p>
<p>这里需要注意的是：Java里，要时刻检验数组是否越界。</p>
<p>总结这题其实有思路后并不难，但是重要的是要非常的细致才行，一个细节错就满盘皆输，能够完全做对也是很有成就感的，string类型的题铺普遍如此，多练习。</p>
<h3 id="（3）表示数值的字符串"><a href="#（3）表示数值的字符串" class="headerlink" title="（3）表示数值的字符串"></a>（3）表示数值的字符串</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//正则表达式解法</span><br><span class="line">public boolean isNumeric(char[] str) &#123;</span><br><span class="line">    String string = String.valueOf(str);</span><br><span class="line">            <span class="built_in">return</span> string.matches(<span class="string">&quot;[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">以下对正则进行解释:</span><br><span class="line">[\\+\\-]?            -&gt; 正或负符号出现与否</span><br><span class="line">\\d*                 -&gt; 整数部分是否出现，如-.34 或 +3.34均符合</span><br><span class="line">(\\.\\d+)?           -&gt; 如果出现小数点，那么小数点后面必须有数字；</span><br><span class="line">                        否则一起不出现</span><br><span class="line">([eE][\\+\\-]?\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，</span><br><span class="line">                        紧接着必须跟着整数；或者整个部分都不出现</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//逻辑判断方法</span><br><span class="line">public boolean isNumeric(char[] str) &#123;</span><br><span class="line">    //标记符号，小数点，e是否出现过</span><br><span class="line">    boolean sign = <span class="literal">false</span>, decimal = <span class="literal">false</span>, hasE = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;str.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;e&#x27;</span> || str[i]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasE) <span class="built_in">return</span> <span class="literal">false</span>;//e只能出现一次</span><br><span class="line">            <span class="keyword">if</span>(i == str.length-1) <span class="built_in">return</span> <span class="literal">false</span>;//e后面必须还有数字</span><br><span class="line">            hasE = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span> || str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            // 第二次出现+-符号，则必须紧接在e之后</span><br><span class="line">            <span class="keyword">if</span>(sign &amp;&amp; str[i-1]!=<span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i-1]!=<span class="string">&#x27;E&#x27;</span>) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后</span><br><span class="line">            <span class="keyword">if</span>(!sign &amp;&amp; i&gt;0 &amp;&amp; str[i-1]!=<span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i-1]!=<span class="string">&#x27;E&#x27;</span>) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            sign = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            // e后面不能接小数点，小数点不能出现两次</span><br><span class="line">            <span class="keyword">if</span>(hasE || decimal) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            decimal = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]&lt;<span class="string">&#x27;0&#x27;</span> || str[i]&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>正则表达式和另外一种catch异常的方法都算是比较巧妙的方法，并且我对正则表达式一点也不熟所以就贴上评论区大佬的方法和解释了，万一哪天我接触了呢（嘿嘿）<br>常规的方法就是进行合理性的判断，将所有不合理的可能情况都if到即可，同样是string类题目的通病，比较繁琐细节较多，要非常细致才能做对。</p>
<h3 id="（4）字符流中第一个不重复的字符"><a href="#（4）字符流中第一个不重复的字符" class="headerlink" title="（4）字符流中第一个不重复的字符"></a>（4）字符流中第一个不重复的字符</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    List&lt;Character&gt; c = new ArrayList&lt;&gt;();</span><br><span class="line">    //Insert one char from stringstream</span><br><span class="line">    public void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(ch))</span><br><span class="line">            map.put(ch,map.get(ch)+1);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch, 1);</span><br><span class="line">            c.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char <span class="keyword">in</span> current stringstream</span><br><span class="line">    public char <span class="function"><span class="title">FirstAppearingOnce</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(char x:c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(x)==1)</span><br><span class="line">                <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>求出现次数这种类型的题很明显的可以借助<strong>Map</strong>来做计数处理，同时因为是要求输出第一个只出现一次的字符，所以再借助一个<strong>List</strong>来有序存储字符流即可。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-string</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Linkedlist</title>
    <url>/2020/02/08/20200208-offer/</url>
    <content><![CDATA[<h3 id="1-从尾到头打印链表"><a href="#1-从尾到头打印链表" class="headerlink" title="(1)从尾到头打印链表"></a>(1)从尾到头打印链表</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        <span class="keyword">while</span>(cur != null)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode i = pre;</span><br><span class="line">        <span class="keyword">while</span>(i != null)&#123;</span><br><span class="line">            res.add(i.val);</span><br><span class="line">            i = i.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>由于之前做过lc中的翻转链表的题目，第一反应就是把链表翻转了做。但其实利用栈的特性 或者存储list后翻转list也都是可以的。<br>题目比较简单做法都比较容易，自己做的时候注意到返回值要求ArrayList用List去返回是不对的，lisk替换原则是不能倒过来用的，所以一定要用子类。</p>
<h3 id="2-链表中环的入口节点"><a href="#2-链表中环的入口节点" class="headerlink" title="(2)链表中环的入口节点"></a>(2)链表中环的入口节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//利用辅助空间做法</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==null || pHead.next==null)</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        List&lt;ListNode&gt; helper = new ArrayList&lt;&gt;();</span><br><span class="line">        ListNode index = pHead;</span><br><span class="line">        <span class="keyword">while</span>(index != null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper.contains(index))</span><br><span class="line">                <span class="built_in">return</span> index;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                helper.add(index);</span><br><span class="line">            index = index.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//不利用辅助空间做法</span><br><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public ListNode EntryNodeOfLoop(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=null &amp;&amp; fast.next!=null)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==null || fast.next==null)</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>利用辅助空间的做法比较常规很容易想到使用一个list来存储出现过的节点，第一个重复节点就是环的入口。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4?f=discussion">https://www.nowcoder.com/questionTerminal/253d2c59ec3e4bc68da16833f79a38e4?f=discussion</a><br>来源：牛客网<br>不利用辅助空间的方法比较巧妙，用到两个结论：<br>1、设置快慢指针，假如有环，他们最后一定相遇。<br>2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇于环入口。<br>结论1不解释，结论二是可以通过数学公式证明的：</p>
<p>链表头到环入口长度为–a<br>环入口到相遇点长度为–b<br>相遇点到环入口长度为–c</p>
<p>则：相遇时<br>快指针路程&#x3D;a+(b+c)k+b ，k&gt;&#x3D;1  其中b+c为环的长度，k为绕环的圈数（k&gt;&#x3D;1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。<br>慢指针路程&#x3D;a+b<br>快指针走的路程是慢指针的两倍，所以：<br>（a+b）*2&#x3D;a+(b+c)k+b<br>化简可得：<br>a&#x3D;(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离&#x3D;相遇点到环入口的距离+（k-1）圈环长度。其中k&gt;&#x3D;1,所以k-1&gt;&#x3D;0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<h3 id="3-删除链表中重复的节点"><a href="#3-删除链表中重复的节点" class="headerlink" title="(3)删除链表中重复的节点"></a>(3)删除链表中重复的节点</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplication(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode dummy = new ListNode(-1);</span><br><span class="line">        dummy.next = pHead;</span><br><span class="line">        ListNode pre = dummy, cur = pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next!=null &amp;&amp; cur.val==cur.next.val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(cur.next!=null &amp;&amp; cur.val==cur.next.val)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><ol>
<li>首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况<br>2.设置 pre ,cur 指针， pre指针指向当前确定不重复的那个节点，而cur指针相当于工作指针，一直往后面搜索。</li>
</ol>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Tree</title>
    <url>/2020/02/10/20200210-offer/</url>
    <content><![CDATA[<h3 id="1-重建二叉树"><a href="#1-重建二叉树" class="headerlink" title="(1)重建二叉树"></a>(1)重建二叉树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//直接递归求解</span><br><span class="line">public TreeNode reConstructBinaryTree(int [] pre,int [] <span class="keyword">in</span>) &#123;</span><br><span class="line">    TreeNode root = CreateTree(pre,0,pre.length-1,<span class="keyword">in</span>,0);</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">public TreeNode CreateTree(int[] pre,int preStart,int preEnd,int[] <span class="keyword">in</span>,int inStart)&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd)</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    TreeNode node = new TreeNode(pre[preStart]);</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;in.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(pre[preStart] == <span class="keyword">in</span>[i])</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    node.left = CreateTree(pre,preStart+1,i-inStart+preStart,<span class="keyword">in</span>,inStart);</span><br><span class="line">    node.right = CreateTree(pre,i-inStart+preStart+1,preEnd,<span class="keyword">in</span>,i+1);</span><br><span class="line">    <span class="built_in">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//借助一个Map存储中序序列求解</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] <span class="keyword">in</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;in.length;i++)</span><br><span class="line">            map.put(<span class="keyword">in</span>[i],i);</span><br><span class="line">        TreeNode root = CreateTree(pre,0,pre.length-1,0);</span><br><span class="line">        <span class="built_in">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode CreateTree(int[] pre,int preStart,int preEnd,int inStart)&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd)</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        TreeNode node = new TreeNode(pre[preStart]);</span><br><span class="line">        int index = map.get(pre[preStart]);</span><br><span class="line">        int leftTree = index - inStart;</span><br><span class="line">        node.left = CreateTree(pre,preStart+1,preStart+leftTree,inStart);</span><br><span class="line">        node.right = CreateTree(pre,preStart+leftTree+1,preEnd,index+1);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>经典二叉树数据结构算法题，使用preOrder和inOrder的特性结合递归求解。</p>
<p>两种做法都可以，前者不需要辅助空间但是细节较多。</p>
<p>此题要多刷熟练掌握！<strong>Important</strong></p>
<h3 id="2-二叉树的下一个节点"><a href="#2-二叉树的下一个节点" class="headerlink" title="(2)二叉树的下一个节点"></a>(2)二叉树的下一个节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == null) </span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(pNode.right != null)&#123; //如果有右子树，则找右子树的最左节点</span><br><span class="line">        TreeLinkNode node = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(node.left != null) </span><br><span class="line">            node = node.left;</span><br><span class="line">        <span class="built_in">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pNode.next != null)&#123; //没右子树，则找向上找满足把当前节点作为左子树中节点的父节点（上面已经判断过了节点没有右子树）</span><br><span class="line">        <span class="keyword">if</span>(pNode.next.left == pNode) </span><br><span class="line">            <span class="built_in">return</span> pNode.next;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> null; //退到了根节点仍没找到，则返回null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>需要非常熟悉中序遍历的顺序和特点。<br>中序遍历中一个节点root的下一个节点只有两种情况：<br>（1）root右子树中的最左节点<br>（2）一个节点node，他的左子树中最后遍历到的节点是root（在root不满足（1）的情况下这是自然的）</p>
<h3 id="3-对称的二叉树"><a href="#3-对称的二叉树" class="headerlink" title="(3)对称的二叉树"></a>(3)对称的二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//递归方法</span><br><span class="line">boolean isSymmetrical(TreeNode pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">return</span> JudgeTree(pRoot.left,pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line">boolean JudgeTree(TreeNode node1, TreeNode node2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node1 == null)</span><br><span class="line">        <span class="built_in">return</span> node2 == null;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node2 == null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1.val != node2.val)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">return</span> JudgeTree(node1.left,node2.right) &amp;&amp; JudgeTree(node1.right,node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//DFS非递归方法，借助栈实现（BFS借助Queue实现，类似，略）</span><br><span class="line">boolean isSymmetricalDFS(TreeNode pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == null) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();</span><br><span class="line">    s.push(pRoot.left);</span><br><span class="line">    s.push(pRoot.right);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">        TreeNode right = s.pop();//成对取出</span><br><span class="line">        TreeNode left = s.pop();</span><br><span class="line">        <span class="keyword">if</span>(left == null &amp;&amp; right == null) <span class="built_in">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == null || right == null) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        //成对插入</span><br><span class="line">        s.push(left.left);</span><br><span class="line">        s.push(right.right);</span><br><span class="line">        s.push(left.right);</span><br><span class="line">        s.push(right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同<br>左子树的右子树和右子树的左子树相同即可，采用递归<br>非递归也可，采用栈或队列存取各级子树根节点</p>
<h3 id="4-按之字形次序打印二叉树"><a href="#4-按之字形次序打印二叉树" class="headerlink" title="(4)按之字形次序打印二叉树"></a>(4)按之字形次序打印二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == null)</span><br><span class="line">        <span class="built_in">return</span> new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    boolean flag = <span class="literal">true</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; t = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(tn != null)&#123;</span><br><span class="line">                tmp.add(tn.val);</span><br><span class="line">                t.add(tn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span> &amp;&amp; tmp.size()!=0)&#123;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="literal">false</span> &amp;&amp; tmp.size()!=0)&#123;</span><br><span class="line">            res.add(ReverseList(tmp));</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;t.size();i++)&#123;</span><br><span class="line">            queue.add(t.get(i).left);</span><br><span class="line">            queue.add(t.get(i).right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList&lt;Integer&gt; ReverseList(ArrayList&lt;Integer&gt; list)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=list.size()-1;i&gt;=0;i--)</span><br><span class="line">        res.add(list.get(i));</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>层序遍历输出的基础上添加一个标志位在偶数行的情况下进行逆序即可，注意细节。</p>
<h3 id="5-把二叉树打印成多行"><a href="#5-把二叉树打印成多行" class="headerlink" title="(5)把二叉树打印成多行"></a>(5)把二叉树打印成多行</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//层序遍历方法</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == null) </span><br><span class="line">        <span class="built_in">return</span> new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; t = new ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tn = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(tn != null) &#123;</span><br><span class="line">                tmp.add(tn.val);</span><br><span class="line">                t.add(tn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;t.size();i++)&#123;</span><br><span class="line">            queue.add(t.get(i).left);</span><br><span class="line">            queue.add(t.get(i).right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() &gt; 0) res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//DFS方法</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    DFS(pRoot,res,1);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(TreeNode root,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,int depth)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null) <span class="built_in">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(depth &gt; res.size()) </span><br><span class="line">        res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    res.get(depth-1).add(root.val);</span><br><span class="line">    DFS(root.left,res,depth+1);</span><br><span class="line">    DFS(root.right,res,depth+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>经典题，常规思维使用层序遍历可以解决，做法注意细节要牢记。<br>还可以使用DFS的方法用递归做，比较巧妙，代码简洁。</p>
<h3 id="6-序列化二叉树"><a href="#6-序列化二叉树" class="headerlink" title="(6)序列化二叉树"></a>(6)序列化二叉树</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<h4 id="java-5"><a href="#java-5" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int index = -1; //计数器</span><br><span class="line">String Serialize(TreeNode root) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    <span class="keyword">if</span>(root == null)&#123;</span><br><span class="line">        sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(root.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    sb.append(Serialize(root.left));</span><br><span class="line">    sb.append(Serialize(root.right));</span><br><span class="line">    <span class="built_in">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">TreeNode Deserialize(String str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str == null || str.length()==0)</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    index++;</span><br><span class="line">    String[] arr = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    TreeNode root = null;</span><br><span class="line">    <span class="keyword">if</span>(!arr[index].equals(<span class="string">&quot;#&quot;</span>))&#123; //String用equals切记</span><br><span class="line">        root = new TreeNode(Integer.valueOf(arr[index])); //类型转换</span><br><span class="line">        root.left = Deserialize(str);</span><br><span class="line">        root.right = Deserialize(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-5"><a href="#思路-总结-5" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>需要选择一种遍历二叉树的方式（我使用了先序，中后层也都可以），然后按照这种遍历方式去序列化二叉树，在空节点的地方要插入一个标识。<br>反序列化时，按照遍历方式反相解析即可<br><strong>任意一种遍历方式加上空节点标识即可确定一棵二叉树</strong></p>
<h3 id="7-二叉搜索树的第k个节点"><a href="#7-二叉搜索树的第k个节点" class="headerlink" title="(7)二叉搜索树的第k个节点"></a>(7)二叉搜索树的第k个节点</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<h4 id="java-6"><a href="#java-6" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//递归中序遍历</span><br><span class="line">int n; //计数</span><br><span class="line">TreeNode res;</span><br><span class="line">TreeNode KthNode(TreeNode pRoot, int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot==null || k==0) <span class="built_in">return</span> null;</span><br><span class="line">    n = k;</span><br><span class="line">    Judge(pRoot);</span><br><span class="line">    <span class="keyword">if</span>(res == null) </span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public void Judge(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null) <span class="built_in">return</span>;//递归终止条件</span><br><span class="line">    Judge(root.left);</span><br><span class="line">    <span class="keyword">if</span>(n == 1)&#123;</span><br><span class="line">        res = root;</span><br><span class="line">        n = -1;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> n--;</span><br><span class="line">    Judge(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TreeNode KthNode(TreeNode pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        //非递归中序遍历，借助栈</span><br><span class="line">        <span class="keyword">if</span>(pRoot==null || k==0)</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || pRoot!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot != null)&#123;</span><br><span class="line">                stack.push(pRoot);</span><br><span class="line">                pRoot = pRoot.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pRoot = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(--k == 0)</span><br><span class="line">                    <span class="built_in">return</span> pRoot;</span><br><span class="line">                pRoot = pRoot.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-6"><a href="#思路-总结-6" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>充分利用二叉搜索树的条件，二叉搜索树的中序遍历序列是一个升序序列。</p>
<h3 id="8-数据流中的中位数"><a href="#8-数据流中的中位数" class="headerlink" title="(8)数据流中的中位数"></a>(8)数据流中的中位数</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h4 id="java-7"><a href="#java-7" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//使用一个list获取数据流，获取中位数时进行排序处理</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void Insert(Integer num) &#123;</span><br><span class="line">    list.add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Double <span class="function"><span class="title">GetMedian</span></span>() &#123;</span><br><span class="line">    Collections.<span class="built_in">sort</span>(list);</span><br><span class="line">    <span class="keyword">if</span>(list.size()%2 == 1)</span><br><span class="line">        <span class="built_in">return</span> Double.valueOf(list.get(list.size()/2));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (list.get(list.size()/2-1)+list.get(list.size()/2))/2.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//使用优先队列处理，效率更高</span><br><span class="line">private PriorityQueue&lt;Integer&gt; leftQ = new PriorityQueue&lt;&gt;();</span><br><span class="line">private PriorityQueue&lt;Integer&gt; rightQ = new PriorityQueue&lt;&gt;((o1,o2) -&gt; o2-o1);</span><br><span class="line">private boolean isOdd = false;</span><br><span class="line">public void Insert(Integer num) &#123;</span><br><span class="line">    if(isOdd)&#123;</span><br><span class="line">        leftQ.add(num); //左右互搏</span><br><span class="line">        rightQ.add(leftQ.poll());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rightQ.add(num);</span><br><span class="line">        leftQ.add(rightQ.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    isOdd = !isOdd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Double <span class="function"><span class="title">GetMedian</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(isOdd)</span><br><span class="line">        <span class="built_in">return</span> Double.valueOf(leftQ.peek());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (leftQ.peek()+rightQ.peek())/2.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-7"><a href="#思路-总结-7" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>第一种方法不多说，只要注意index-1常识即可，比较容易。<br>第二种利用优先队列的方法，是利用一个升序和一个降序优先队列（小顶堆和大顶堆）存储数据流，控制两个优先队列长度差不超过1（你加一来我加一）。<br>从而将中位数一直暴露在两个堆的堆顶（注意奇偶情况）。<br><strong>注意有一个左右互搏的操作，是用来确保两个堆中的数据没有大小交错的情况产生</strong></p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Stack&amp;&amp;Queue</title>
    <url>/2020/02/17/20200217-offer/</url>
    <content><![CDATA[<h3 id="1-用两个栈实现队列"><a href="#1-用两个栈实现队列" class="headerlink" title="(1)用两个栈实现队列"></a>(1)用两个栈实现队列</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">public void push(int node) &#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() &gt; 0)</span><br><span class="line">        <span class="built_in">return</span> stack2.pop();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>两个栈一个负责入队列一个负责出队列，注意stack2为空时要将stack1中的所有元素都依次拿过来。</p>
<h3 id="2-滑动窗口的最大值"><a href="#2-滑动窗口的最大值" class="headerlink" title="(2)滑动窗口的最大值"></a>(2)滑动窗口的最大值</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//代码简洁，复杂度高</span><br><span class="line">public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==null || num.length==0 || size==0 || size&gt;num.length)</span><br><span class="line">        <span class="built_in">return</span> new ArrayList&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;=num.length-size; i++)</span><br><span class="line">        res.add(getMax(num,i,size));</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public int getMax(int[] num, int start, int size)&#123;</span><br><span class="line">    int max = num[start];</span><br><span class="line">    <span class="keyword">for</span>(int i=start; i&lt;start+size; i++)</span><br><span class="line">        max = Math.max(num[i],max);</span><br><span class="line">    <span class="built_in">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//经过优化，效率更高</span><br><span class="line">public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==null || num.length==0 || size==0 || size&gt;num.length)</span><br><span class="line">        <span class="built_in">return</span> new ArrayList&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    int start = 0, end = size-1;</span><br><span class="line">    int index = getMax(num,start,end);</span><br><span class="line">    <span class="keyword">while</span>(end &lt; num.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=start &amp;&amp; index&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[end] &gt; num[index])</span><br><span class="line">                index = end;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            index = getMax(num,start,end);</span><br><span class="line">        res.add(num[index]);</span><br><span class="line">        start++;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public int getMax(int[] num, int start, int end)&#123;</span><br><span class="line">    int index = start;</span><br><span class="line">    <span class="keyword">for</span>(int i=start+1; i&lt;=end; i++)</span><br><span class="line">        <span class="keyword">if</span>(num[index] &lt; num[i])</span><br><span class="line">            index = i;</span><br><span class="line">    <span class="built_in">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>略。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-stack&amp;&amp;queue</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Sort&amp;&amp;Recursion</title>
    <url>/2020/02/19/20200219-offer/</url>
    <content><![CDATA[<h3 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="(1)旋转数组的最小数字"></a>(1)旋转数组的最小数字</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">    int low = 0, high = array.length-1;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        int mid = (low+high)/2;</span><br><span class="line">        <span class="keyword">if</span>(array[mid] &gt; array[high])</span><br><span class="line">            low = mid+1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])</span><br><span class="line">            high--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> array[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>摘牛课评论区大佬的总结，非常到位。<br>链接：<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion">https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba?f=discussion</a><br>来源：牛客网</p>
<p>采用二分法解答这个问题，<br>mid &#x3D; low + (high - low)&#x2F;2<br>需要考虑三种情况：<br>(1)array[mid] &gt; array[high]:<br>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。<br>low &#x3D; mid + 1<br>(2)array[mid] &#x3D;&#x3D; array[high]:<br>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边<br>还是右边,这时只好一个一个试 ，<br>high &#x3D; high - 1<br>(3)array[mid] &lt; array[high]:<br>出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左<br>边。因为右边必然都是递增的。<br>high &#x3D; mid<br>注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字<br>比如 array &#x3D; [4,6]<br>array[low] &#x3D; 4 ;array[mid] &#x3D; 4 ; array[high] &#x3D; 6 ;<br>如果high &#x3D; mid - 1，就会产生错误， 因此high &#x3D; mid<br>但情形(1)中low &#x3D; mid + 1就不会错误</p>
<h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="(2)斐波那契数列"></a>(2)斐波那契数列</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;&#x3D;39</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == 1)</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">if</span>(n == 0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == 0) <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= 2) <span class="built_in">return</span> 1;</span><br><span class="line">    int f1 = 1, f2 = 1;</span><br><span class="line">    <span class="keyword">for</span>(int i=3; i&lt;=n; i++)&#123;</span><br><span class="line">        int temp = f1+f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>略。</p>
<h3 id="3-跳台阶"><a href="#3-跳台阶" class="headerlink" title="(3)跳台阶"></a>(3)跳台阶</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int JumpFloor(int target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(target==0 || target==1)</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="built_in">return</span> JumpFloor(target-1) + JumpFloor(target-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>略。</p>
<h3 id="3-变态跳台阶"><a href="#3-变态跳台阶" class="headerlink" title="(3)变态跳台阶"></a>(3)变态跳台阶</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int JumpFloorII(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == 1) </span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="built_in">return</span> 1 + 2*JumpFloorII(n-1) - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>跳n阶可能步骤 -&gt; 一次跳n阶【1种】<br>                            跳1阶 + 跳n-1阶【共JumpFloorII（n-1）种】<br>                            跳n-1阶 + 跳1阶【共JumpFloorII（n-1）种】<br>所以递归公式：JumpFloorII(n) &#x3D; 1 + 2*JumpFloorII(n-1) - 1<br>减一是因为全跳1步被重复计算了一次</p>
<h3 id="4-矩阵覆盖"><a href="#4-矩阵覆盖" class="headerlink" title="(4)矩阵覆盖"></a>(4)矩阵覆盖</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们可以用2&times;1的小矩形横着或者竖着去覆盖更大的矩形。<br>请问用n个2&times;1的小矩形无重叠地覆盖一个2&times;n的大矩形，总共有多少种方法？</p>
<p>比如n&#x3D;3时，2*3的矩形块有3种覆盖方法：<br><img src="/images/20200219offer/111.png"></p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int RectCover(int target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(target == 2)</span><br><span class="line">        <span class="built_in">return</span> 2;</span><br><span class="line">    <span class="keyword">if</span>(target == 1)</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">if</span>(target == 0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> RectCover(target-1) + RectCover(target-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>同（2）略。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-sort&amp;recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Mess</title>
    <url>/2020/02/20/20200220-offer/</url>
    <content><![CDATA[<h3 id="1-二进制中1的个数"><a href="#1-二进制中1的个数" class="headerlink" title="(1)二进制中1的个数"></a>(1)二进制中1的个数</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0, flag = 1;</span><br><span class="line">    <span class="keyword">while</span>(flag != 0)&#123;</span><br><span class="line">        <span class="keyword">if</span>((flag &amp; n) != <span class="number">0</span>) //注意位运算符优先级</span><br><span class="line">            count++;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    <span class="keyword">while</span>(n != 0)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n = (n - 1) &amp; n; //n最右边的1被消去了</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>见注释，略。</p>
<h3 id="2-数值的整数次方"><a href="#2-数值的整数次方" class="headerlink" title="(2)数值的整数次方"></a>(2)数值的整数次方</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    double res = 1;</span><br><span class="line">    int n = exponent;</span><br><span class="line">    <span class="keyword">if</span>(exponent == 0) <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; 0) n = -n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n != 0)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%2 == 1)//偶数时这个<span class="keyword">if</span>只用最后一次，奇数时这个<span class="keyword">if</span>第一次和最后一次用两次</span><br><span class="line">            res*=base;</span><br><span class="line">        base*=base;</span><br><span class="line">        n = n/2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> exponent&gt;0?res:1/res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == 0) <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">if</span>(exponent &lt; 0)&#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        base = 1/base;</span><br><span class="line">    &#125;</span><br><span class="line">    double res = 1;</span><br><span class="line">    <span class="keyword">while</span>(exponent != 0)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent%2 == 1)</span><br><span class="line">            res*=base;</span><br><span class="line">        base*=base;</span><br><span class="line">        exponent/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>见注释，略。</p>
<h3 id="3-调整数组顺序使奇数位于偶数前面"><a href="#3-调整数组顺序使奇数位于偶数前面" class="headerlink" title="(3)调整数组顺序使奇数位于偶数前面"></a>(3)调整数组顺序使奇数位于偶数前面</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//借助辅助空间</span><br><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    List&lt;Integer&gt; odd = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; even = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            odd.add(array[i]);</span><br><span class="line">        else</span><br><span class="line">            even.add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;odd.size(); i++)</span><br><span class="line">        array[i] = odd.get(i);</span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;even.size(); i++)</span><br><span class="line">        array[i+odd.size()] = even.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//不借助辅助空间，但时间效率增加</span><br><span class="line">public void reOrderArray(int [] array) &#123;//冒泡</span><br><span class="line">    <span class="keyword">for</span>(int i=array.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]%2==0 &amp;&amp; array[j+1]%2==1)&#123;</span><br><span class="line">                int tmp = array[j];</span><br><span class="line">                array[j] = array[j+1];</span><br><span class="line">                array[j+1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void reOrderArray(int [] array) &#123;//插入</span><br><span class="line">        int start = 0, index = 0;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; array.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[index]%2 == 1)&#123;</span><br><span class="line">                int tmp = array[index];</span><br><span class="line">                <span class="keyword">for</span>(int i=index; i&gt;start; i--)</span><br><span class="line">                    array[i] = array[i-1];</span><br><span class="line">                array[start] = tmp;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>略。</p>
<h3 id="4-链表中倒数第k个结点"><a href="#4-链表中倒数第k个结点" class="headerlink" title="(4)链表中倒数第k个结点"></a>(4)链表中倒数第k个结点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ListNode FindKthToTail(ListNode <span class="built_in">head</span>,int k) &#123;</span><br><span class="line">    ListNode p1 = <span class="built_in">head</span>, p2 = <span class="built_in">head</span>;</span><br><span class="line">    int i = 0;</span><br><span class="line">    <span class="keyword">for</span>( ; p2!=null; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> i&gt;=k ? p1:null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>目前最优解：设置两个指针，p1，p2，先让p2走k步，然后再一起走，直到p2为null时，p1即为倒数第k个节点。<br>可行解：使用计数或者倒置链表的方法。</p>
<h3 id="5-反转链表"><a href="#5-反转链表" class="headerlink" title="(5)反转链表"></a>(5)反转链表</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ListNode ReverseList(ListNode <span class="built_in">head</span>) &#123;</span><br><span class="line">    ListNode pre = null, cur = <span class="built_in">head</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != null)&#123;</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>熟记，略。</p>
<h3 id="6-合并两个排序的链表"><a href="#6-合并两个排序的链表" class="headerlink" title="(6)合并两个排序的链表"></a>(6)合并两个排序的链表</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h4 id="java-5"><a href="#java-5" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//非递归</span><br><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">    ListNode dummy = new ListNode(-1), index = dummy;</span><br><span class="line">    <span class="keyword">while</span>(list1!=null &amp;&amp; list2!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            index.next = new ListNode(list1.val);</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index.next = new ListNode(list2.val);</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        index = index.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(list1 != null)&#123;</span><br><span class="line">        index.next = new ListNode(list1.val);</span><br><span class="line">        list1 = list1.next;</span><br><span class="line">        index = index.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(list2 != null)&#123;</span><br><span class="line">        index.next = new ListNode(list2.val);</span><br><span class="line">        list2 = list2.next;</span><br><span class="line">        index = index.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(list1 == null)</span><br><span class="line">        <span class="built_in">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span>(list2 == null)</span><br><span class="line">        <span class="built_in">return</span> list1;</span><br><span class="line">    <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">        list1.next = Merge(list1.next,list2);</span><br><span class="line">        <span class="built_in">return</span> list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2.next = Merge(list1,list2.next);</span><br><span class="line">        <span class="built_in">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-5"><a href="#思路-总结-5" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>熟悉递归做法，略。</p>
<h3 id="7-树的子结构"><a href="#7-树的子结构" class="headerlink" title="(7)树的子结构"></a>(7)树的子结构</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h4 id="java-6"><a href="#java-6" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root1==null || root2==null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    boolean res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1.val == root2.val)</span><br><span class="line">        res = Judge(root1,root2);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="literal">false</span>)</span><br><span class="line">        res = HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public boolean Judge(TreeNode node1, TreeNode node2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node2 == null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1 == null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1.val != node2.val)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">return</span> Judge(node1.left,node2.left) &amp;&amp; Judge(node1.right,node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-6"><a href="#思路-总结-6" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>注意题目是子结构，所以只要将root2对比完没有出现比对失败即可。<br>两次递归，第一次递归寻找节点相同的头节点，调用方法进行第二次递归判断是否子结构。注意中间最好使用一个布尔类型res中间值进行结果记录。</p>
<h3 id="8-二叉树的镜像"><a href="#8-二叉树的镜像" class="headerlink" title="(8)二叉树的镜像"></a>(8)二叉树的镜像</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           &#x2F;  <br>          6   10<br>         &#x2F; \  &#x2F; <br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           &#x2F;  <br>          10   6<br>         &#x2F; \  &#x2F; <br>        11 9 7  5</p>
<h4 id="java-7"><a href="#java-7" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null) </span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    TreeNode tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line">    </span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-7"><a href="#思路-总结-7" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>略。</p>
<h3 id="9-顺时针打印矩阵"><a href="#9-顺时针打印矩阵" class="headerlink" title="(9)顺时针打印矩阵"></a>(9)顺时针打印矩阵</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h4 id="java-8"><a href="#java-8" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    int n = matrix.length;</span><br><span class="line">    <span class="keyword">if</span>(n == 0)</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    int m = matrix[0].length;</span><br><span class="line">    int k = (Math.min(n,m)-1)/2+1; //层数</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;k; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int a=i; a&lt;m-i; a++)</span><br><span class="line">            res.add(matrix[i][a]);</span><br><span class="line">        <span class="keyword">for</span>(int a=i+1; a&lt;n-i; a++)</span><br><span class="line">            res.add(matrix[a][m-i-1]);</span><br><span class="line">        <span class="keyword">for</span>(int a=m-2-i; a&gt;=i &amp;&amp; n-i-1!=i; a--) //注意重复判断</span><br><span class="line">            res.add(matrix[n-1-i][a]);</span><br><span class="line">        <span class="keyword">for</span>(int a=n-2-i; a&gt;i &amp;&amp; m-i-1!=i; a--)</span><br><span class="line">            res.add(matrix[a][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-8"><a href="#思路-总结-8" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>（1）确定层数，注意奇数偶数情况<br>（2）针对层数进行循环，循环体内是4个for遍历一组打印出当前层。<br>tip：注意后面两个for的起始受前两次输出影响要多-1，然后要进行重复判断。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Decompose and Efficiency</title>
    <url>/2020/02/22/20200222-offer/</url>
    <content><![CDATA[<h3 id="1-复杂链表的复制"><a href="#1-复杂链表的复制" class="headerlink" title="(1)复杂链表的复制"></a>(1)复杂链表的复制</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public RandomListNode Clone(RandomListNode pHead)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == null) <span class="built_in">return</span> null;</span><br><span class="line">    RandomListNode dummy1 = new RandomListNode(-1);</span><br><span class="line">    dummy1.next = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pHead != null)&#123;</span><br><span class="line">        RandomListNode tmp = new RandomListNode(pHead.label);</span><br><span class="line">        tmp.next = pHead.next;</span><br><span class="line">        pHead.next = tmp;</span><br><span class="line">        pHead = pHead.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomListNode pre = dummy1.next;</span><br><span class="line">    <span class="keyword">while</span>(pre != null)&#123;</span><br><span class="line">        RandomListNode p = pre.next;</span><br><span class="line">        p.random = pre.random==null?null:pre.random.next;//注意random指针也可能为空</span><br><span class="line">        pre = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    RandomListNode dummy2 = new RandomListNode(-2);</span><br><span class="line">    RandomListNode d2 = dummy2;</span><br><span class="line">    pre = dummy1.next;</span><br><span class="line">    <span class="keyword">while</span>(pre != null)&#123;</span><br><span class="line">        d2.next = pre.next;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        d2 = d2.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dummy2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>解题思路：<br>1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random &#x3D; A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p>
<h3 id="2-二叉搜索树与双向链表"><a href="#2-二叉搜索树与双向链表" class="headerlink" title="(2)二叉搜索树与双向链表"></a>(2)二叉搜索树与双向链表</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//非递归版本，利用中序遍历方法</span><br><span class="line">public TreeNode Convert(TreeNode root) &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    TreeNode p = root , pre = null;</span><br><span class="line">    boolean flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || p!=null)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p != null)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            root = p;</span><br><span class="line">            pre = p;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = p;</span><br><span class="line">            p.left = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//递归版本</span><br><span class="line">public TreeNode Convert(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null) <span class="built_in">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(root.left==null &amp;&amp; root.right==null) <span class="built_in">return</span> root;</span><br><span class="line">    TreeNode left = Convert(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left != null)&#123;</span><br><span class="line">        TreeNode p =left;</span><br><span class="line">        <span class="keyword">while</span>(p!=null &amp;&amp; p.right!=null) p = p.right;</span><br><span class="line">        p.right = root;</span><br><span class="line">        root.left = p;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode right = Convert(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right != null)&#123;</span><br><span class="line">        root.right = right;</span><br><span class="line">        right.left = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> left!=null?left:root; //return the <span class="built_in">head</span> of the list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>利用二叉搜索树的特性：中序遍历是升序序列。<br>非递归版本和递归版本都是通过这一特性，然后记录前后节点的方式解决问题。<br>非递归依托栈的特性记录前后节点。而非递归则每次返回list的head解决问题。</p>
<h3 id="3-字符串的排列"><a href="#3-字符串的排列" class="headerlink" title="(3)字符串的排列"></a>(3)字符串的排列</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span>(str==null || str.length()==0)</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    fullPermutation(res,str.toCharArray(),0);</span><br><span class="line">    Collections.<span class="built_in">sort</span>(res); //字典序</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public void fullPermutation(ArrayList&lt;String&gt; res,char[] num,int start)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == num.length-1)&#123;</span><br><span class="line">        res.add(String.valueOf(num));</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Character&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=start;i&lt;num.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==start || !set.contains(num[i]))&#123; //借助<span class="built_in">set</span>排除重复</span><br><span class="line">            set.add(num[i]);</span><br><span class="line">            swap(num,start,i);</span><br><span class="line">            fullPermutation(res,num,start+1);</span><br><span class="line">            swap(num,start,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void swap(char[] num,int a,int b)&#123;</span><br><span class="line">    char tmp = num[a];</span><br><span class="line">    num[a] =  num[b];</span><br><span class="line">    num[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>（1）固定第一个字符，递归取得首位后面的各种字符串组合；<br>（2）再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合；<br>tips：递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。</p>
<h3 id="4-数组中出现次数超过一半的数字"><a href="#4-数组中出现次数超过一半的数字" class="headerlink" title="(4)数组中出现次数超过一半的数字"></a>(4)数组中出现次数超过一半的数字</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array==null || array.length==0) <span class="built_in">return</span> 0;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int item:array)</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(item))</span><br><span class="line">            map.put(item,map.get(item)+1);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(item,1);</span><br><span class="line">    <span class="keyword">for</span>(int k:map.keySet())</span><br><span class="line">        <span class="keyword">if</span>(map.get(k)*2 &gt; array.length)</span><br><span class="line">            <span class="built_in">return</span> k;</span><br><span class="line">    //for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())</span><br><span class="line">    //    <span class="keyword">if</span>(entry.getValue()*2 &gt; array.length)</span><br><span class="line">    //        <span class="built_in">return</span> entry.getKey();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><h3 id="5-最小的K个数"><a href="#5-最小的K个数" class="headerlink" title="(5)最小的K个数"></a>(5)最小的K个数</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k &gt; input.length) <span class="built_in">return</span> res;</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(input);</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;k;i++)</span><br><span class="line">        res.add(input[i]);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;input.length || k==0) <span class="built_in">return</span> res;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1,o2) -&gt; o2-o1);</span><br><span class="line">    for(int i=<span class="number">0</span>; i&lt;input.length; i++)&#123;</span><br><span class="line">        if(heap.size() != k)</span><br><span class="line">            heap.add(input[i]);</span><br><span class="line">        else if(heap.peek() &gt; input[i])&#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int item:heap)</span><br><span class="line">        res.add(item);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>任意排序方法都能解决。或者使用堆来解决，时间效率更高。</p>
<h3 id="6-连续子数组的最大和"><a href="#6-连续子数组的最大和" class="headerlink" title="(6)连续子数组的最大和"></a>(6)连续子数组的最大和</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h4 id="java-5"><a href="#java-5" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//暴力法</span><br><span class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;array.length; i++)&#123;</span><br><span class="line">        int tmax = 0;</span><br><span class="line">        <span class="keyword">for</span>(int j=i; tmax&gt;=0 &amp;&amp; j&lt;array.length; j++)&#123;</span><br><span class="line">            tmax+=array[j];</span><br><span class="line">            max = Math.max(max,tmax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">    int res = array[0];//记录dp过程中所有子数组的和的最大值</span><br><span class="line">    int max = array[0];//dp过程中当前长度数组的连续子数组和最大值</span><br><span class="line">    <span class="keyword">for</span>(int i=1; i&lt;array.length; i++)&#123;</span><br><span class="line">        max = Math.max(max+array[i], array[i]);</span><br><span class="line">        res = Math.max(res,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-5"><a href="#思路-总结-5" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>动态规划解法较优。见注释</p>
<h3 id="7-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#7-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="(7)整数中1出现的次数（从1到n整数中1出现的次数）"></a>(7)整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<h4 id="java-6"><a href="#java-6" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;=n; i++)</span><br><span class="line">        sb.append(i);</span><br><span class="line">    char[] num = sb.toString().toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;num.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(num[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            res++;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-6"><a href="#思路-总结-6" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><h3 id="8-把数组排成最小的数"><a href="#8-把数组排成最小的数" class="headerlink" title="(8)把数组排成最小的数"></a>(8)把数组排成最小的数</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h4 id="java-7"><a href="#java-7" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public String PrintMinNumber(int [] num) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num==null || num.length==0) <span class="built_in">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] arr = new String[num.length];</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)</span><br><span class="line">        arr[i] = String.valueOf(num[i]);</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(arr,(o1,o2) -&gt; (o1+o2).compareTo(o2+o1));//匿名函数</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)</span><br><span class="line">        sb.append(arr[i]);</span><br><span class="line">    <span class="built_in">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//比较器常规写法</span><br><span class="line">Arrays.<span class="built_in">sort</span>(arr,new Comparator&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1,String o2)&#123;</span><br><span class="line">            String c1 = o1 + o2;</span><br><span class="line">            String c2 = o2 + o1;</span><br><span class="line">            <span class="built_in">return</span> c1.compareTo(c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-7"><a href="#思路-总结-7" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>数组转为String类型，然后进行排序，利用比较器修改排序规则：<br>（1）如果a+b&lt;b+a，那么说明a和b组合时，b越靠后最终结果越小。<br>（2）每次这样比较两个元素，将（1）中的比较遍历全数组后将数组拼接即是最小的数。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-decompose and efficiency</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Space&amp;&amp;Time</title>
    <url>/2020/02/23/20200223-offer/</url>
    <content><![CDATA[<h3 id="1-丑数"><a href="#1-丑数" class="headerlink" title="(1)丑数"></a>(1)丑数</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= 0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(1);</span><br><span class="line">    int i2=0, i3=0, i5=0;</span><br><span class="line">    <span class="keyword">while</span>(list.size() &lt; index)&#123;</span><br><span class="line">        int t2 = list.get(i2)*2;</span><br><span class="line">        int t3 = list.get(i3)*3;</span><br><span class="line">        int t5 = list.get(i5)*5;</span><br><span class="line">        int min = Math.min(t2,Math.min(t3,t5));</span><br><span class="line">        list.add(min);</span><br><span class="line">        <span class="keyword">if</span>(min == t2) i2++;</span><br><span class="line">        <span class="keyword">if</span>(min == t3) i3++;</span><br><span class="line">        <span class="keyword">if</span>(min == t5) i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> list.get(list.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>这道题其实真的不太容易想，首先如果从1～♾判断丑数，那么会超时。<br>我们只能通过丑数的三个因子2，3，5和第一个丑数1进行累乘求一下个最小的丑数。<br>需要注意的是每次求出下一个最小的丑数，那么使用的因子要相应的做好记录，方便下一次的计算。</p>
<h3 id="2-第一个只出现一次的字符"><a href="#2-第一个只出现一次的字符" class="headerlink" title="(2)第一个只出现一次的字符"></a>(2)第一个只出现一次的字符</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个字符串(0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    char[] num = str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(num[i]))</span><br><span class="line">            map.put(num[i],map.get(num[i])+1);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            map.put(num[i],1);</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(map.get(num[i]) == 1)</span><br><span class="line">            <span class="built_in">return</span> i;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>出现次数，首先联想利用map计数解决。</p>
<h3 id="3-数组中的逆序对"><a href="#3-数组中的逆序对" class="headerlink" title="(3)数组中的逆序对"></a>(3)数组中的逆序对</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int res = 0;</span><br><span class="line">public int InversePairs(int [] array) &#123;</span><br><span class="line">    mergeSort(array,0,array.length-1);</span><br><span class="line">    <span class="built_in">return</span> res%1000000007;</span><br><span class="line">&#125;</span><br><span class="line">void mergeSort(int[] array,int low,int high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    int mid = (low+high)/2;</span><br><span class="line">    mergeSort(array,low,mid);</span><br><span class="line">    mergeSort(array,mid+1,high);</span><br><span class="line">    merge(array,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line">void merge(int[] array,int low,int mid,int end)&#123;</span><br><span class="line">    int[] tmp = new int[end-low+1];</span><br><span class="line">    int index = 0, l = low, r = mid+1;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[l] &gt; array[r])&#123;</span><br><span class="line">            res = (res+mid-l+1)%1000000007; //这里很坑，不加余就会报错</span><br><span class="line">            tmp[index++] = array[r++];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            tmp[index++] = array[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= mid)</span><br><span class="line">        tmp[index++] = array[l++];</span><br><span class="line">    <span class="keyword">while</span>(r &lt;= end)</span><br><span class="line">        tmp[index++] = array[r++];</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;tmp.length; i++)</span><br><span class="line">        array[low+i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>1、暴力法可解，但时间复杂度高一般都会被卡时间。<br>2、利用二分+递归思想，借助归并排序过程可解，研一高级算法课上原题。<br>tip：这题的%1000000007我依旧没有搞懂，尤其是结果累计那部分，如果不加%1000000007就只能通过50%的case。</p>
<h3 id="4-两个链表的第一个公共结点"><a href="#4-两个链表的第一个公共结点" class="headerlink" title="(4)两个链表的第一个公共结点"></a>(4)两个链表的第一个公共结点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//天秀</span><br><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode p1=pHead1, p2=pHead2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = (p1==null ? pHead2 : p1.next);</span><br><span class="line">        p2 = (p2==null ? pHead1 : p2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line">    ListNode p1 = pHead1, p2 = pHead2;</span><br><span class="line">    List&lt;ListNode&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(p1 != null)&#123;</span><br><span class="line">        list.add(p1);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2 != null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.contains(p2))</span><br><span class="line">            <span class="built_in">return</span> p2;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>三种解法<br>（1）先遍历两个链表获得长度，计算出长度差k，让长的链表先走k步，然后同步即可找到公共节点。（略）<br>（2）借助一个list存储一个链表，然后遍历第二个链表找公共节点。缺点空间复杂度O(N)<br>（3）两个指针同时走，走到头就从另一链表的头开始重新走<br>    因为len1+len2&#x3D;&#x3D;len2+len1并且公共节点到尾部的长度是共享的（即相等长）<br>    所以最晚第二次走一定能找到公共节点，两条链表等长则一次就能找到。<br>    tip：如果两条链表没有公共节点会死循环，可以借助标志位只让循环两次解决这个问题。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-space&amp;&amp;time</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Abstract</title>
    <url>/2020/02/21/20200221-offer/</url>
    <content><![CDATA[<h3 id="1-包含min函数的栈"><a href="#1-包含min函数的栈" class="headerlink" title="(1)包含min函数的栈"></a>(1)包含min函数的栈</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minNum = new Stack&lt;&gt;();</span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(minNum.size()==0)&#123;</span><br><span class="line">            minNum.push(node);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node &lt; minNum.peek()) minNum.push(node);</span><br><span class="line">        <span class="keyword">else</span> minNum.push(minNum.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minNum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    public int <span class="function"><span class="title">top</span></span>() &#123;</span><br><span class="line">        minNum.pop();</span><br><span class="line">        <span class="built_in">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    public int <span class="function"><span class="title">min</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> minNum.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>辅助栈记录最小值。</p>
<h3 id="2-栈的压入、弹出操作"><a href="#2-栈的压入、弹出操作" class="headerlink" title="(2)栈的压入、弹出操作"></a>(2)栈的压入、弹出操作</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean IsPopOrder(int [] pushA,int [] popA) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pushA.length==0)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    int index = 0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;pushA.length; i++)&#123;</span><br><span class="line">        stack.push(pushA[i]);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[index])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<h3 id="3-从上往下打印二叉树"><a href="#3-从上往下打印二叉树" class="headerlink" title="(3)从上往下打印二叉树"></a>(3)从上往下打印二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode tmp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(tmp != null)&#123;</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            queue.add(tmp.left);</span><br><span class="line">            queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>二叉树的层序遍历。</p>
<h3 id="4-二叉搜索树的后序遍历序列"><a href="#4-二叉搜索树的后序遍历序列" class="headerlink" title="(4)二叉搜索树的后序遍历序列"></a>(4)二叉搜索树的后序遍历序列</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence==null || sequence.length==0)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">return</span> Judge(sequence,0,sequence.length-1);</span><br><span class="line">&#125;</span><br><span class="line">public boolean Judge(int[] sequence,int start,int end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    int index = end-1;</span><br><span class="line">    <span class="keyword">while</span>(index&gt;=start &amp;&amp; sequence[index]&gt;sequence[end])</span><br><span class="line">        index--;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;=index; i++)</span><br><span class="line">        <span class="keyword">if</span>(sequence[i] &gt; sequence[end])</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">return</span> Judge(sequence,start,index) &amp;&amp; Judge(sequence,index+1,end-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>利用后序序列的特征递归即可。<br>后序序列特征：<br>（1）序列的最后一个元素e为根。<br>（2）去掉e后的序列T可以分为[T1,T2]，其中T1为e的左子树（所有元素小于e），T2为e的右子树(所有元素大于e)<br>（3）T1，T2都是后序序列。</p>
<h3 id="5-二叉树中和为某一值的路径"><a href="#5-二叉树中和为某一值的路径" class="headerlink" title="(5)二叉树中和为某一值的路径"></a>(5)二叉树中和为某一值的路径</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Find(res,list,root,target);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public void Find(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; list,TreeNode root,int target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    target-=root.val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)</span><br><span class="line">    res.add(new ArrayList&lt;Integer&gt;(list));</span><br><span class="line">    Find(res,list,root.left,target);</span><br><span class="line">    Find(res,list,root.right,target);</span><br><span class="line">    list.remove(list.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    target-=root.val;</span><br><span class="line">    <span class="keyword">if</span>(target==0 &amp;&amp; root.left==null &amp;&amp; root.right==null)</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">    FindPath(root.left,target);</span><br><span class="line">    FindPath(root.right,target);</span><br><span class="line">    list.remove(list.size()-1);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>深度优先遍历。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-abstract</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Mess2</title>
    <url>/2020/02/24/20200224-offer/</url>
    <content><![CDATA[<h3 id="1-数字在排序数组中出现的次数"><a href="#1-数字在排序数组中出现的次数" class="headerlink" title="(1)数字在排序数组中出现的次数"></a>(1)数字在排序数组中出现的次数</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在排序数组中出现的次数。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int GetNumberOfK(int [] array , int k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length == 0) <span class="built_in">return</span> 0;</span><br><span class="line">    int index = getK(array,0,array.length-1,k);</span><br><span class="line">    <span class="keyword">if</span>(index&lt;0) <span class="built_in">return</span> 0;</span><br><span class="line">    int l=index, h=index;</span><br><span class="line">    <span class="keyword">while</span>(l&gt;0 &amp;&amp; array[l]==k)</span><br><span class="line">        l--;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;array.length-1 &amp;&amp; array[h]==k)</span><br><span class="line">        h++;</span><br><span class="line">    <span class="keyword">if</span>(array[l]==k &amp;&amp; array[h]==k)</span><br><span class="line">        <span class="built_in">return</span> h-l+1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(array[l]==k || array[h]==k)</span><br><span class="line">        <span class="built_in">return</span> h-l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> h-l-1;</span><br><span class="line">&#125;</span><br><span class="line">public int getK(int[] array,int low,int high,int k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[low] == k)</span><br><span class="line">        <span class="built_in">return</span> low;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="built_in">return</span> -1;</span><br><span class="line">    int mid = (low+high)/2;</span><br><span class="line">    <span class="keyword">if</span>(array[mid] == k)</span><br><span class="line">        <span class="built_in">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; k)</span><br><span class="line">        <span class="built_in">return</span> getK(array,mid+1,high,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> getK(array,low,mid-1,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>有序肯定用二分，递归写法和非递归都可以，二分不难写但是要考虑到所有情况需要非常细致。</p>
<h3 id="2-二叉树的深度"><a href="#2-二叉树的深度" class="headerlink" title="(2)二叉树的深度"></a>(2)二叉树的深度</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int depth = 0;</span><br><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">    DFS(root,1);</span><br><span class="line">    <span class="built_in">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">public void DFS(TreeNode root,int curDepth)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != null)&#123;</span><br><span class="line">        depth = Math.max(depth,curDepth);</span><br><span class="line">        DFS(root.left,curDepth+1);</span><br><span class="line">        DFS(root.right,curDepth+1);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> Math.max(1+TreeDepth(root.left),1+TreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>DFS递归，第二种极度简洁。</p>
<h3 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="(3)平衡二叉树"></a>(3)平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=1)</span><br><span class="line">        <span class="built_in">return</span> IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">public int getDepth(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> Math.max(1+getDepth(root.left),1+getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">    <span class="built_in">return</span> Judge(root) != -1;</span><br><span class="line">&#125;</span><br><span class="line">public int Judge(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    int left = Judge(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left == -1) <span class="built_in">return</span> -1;</span><br><span class="line">    int right = Judge(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right == -1) <span class="built_in">return</span> -1;</span><br><span class="line">    <span class="built_in">return</span> Math.abs(left-right)&gt;1 ? -1 : 1+Math.max(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>借助平衡二叉树的定义：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>第一种做法：自上向下递归判断，缺点会重复遍历下层节点。<br>第二种做法：自底向上递归判断，剪枝重复步骤，借助获取二叉树最大长度的方法，每次判断高度差超过1返回-1标志子树已经不满足平衡，不需要继续遍历。</p>
<h3 id="4-数组中只出现一次的数字"><a href="#4-数组中只出现一次的数字" class="headerlink" title="(4)数组中只出现一次的数字"></a>(4)数组中只出现一次的数字</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;array.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(set.contains(array[i]))</span><br><span class="line">            set.remove(array[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(array[i]);</span><br><span class="line">    Integer[] num = set.toArray(new Integer[set.size()]); //方法一，注意此处一定要用封装类型</span><br><span class="line">    num1[0] = num[0];</span><br><span class="line">    num2[0] = num[1];</span><br><span class="line">    /** 方法二</span><br><span class="line">    * Object[] num = set.toArray();</span><br><span class="line">    * num1[0] = (int)num[0];</span><br><span class="line">    * num2[0] = (int)num[1];</span><br><span class="line">    **/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>借助set快速解决，注意set.toArray()的两种用法，要么使用Object[]数组，要么参数写入封装类数组。</p>
<h3 id="5-和为S的连续正数序列"><a href="#5-和为S的连续正数序列" class="headerlink" title="(5)和为S的连续正数序列"></a>(5)和为S的连续正数序列</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int <span class="built_in">sum</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1; i&lt;<span class="built_in">sum</span> ;i++)&#123;</span><br><span class="line">        Judge(<span class="built_in">sum</span>,i,new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public void Judge(int <span class="built_in">sum</span>,int n,ArrayList&lt;Integer&gt; list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sum</span> == n)&#123;</span><br><span class="line">        list.add(n);</span><br><span class="line">        res.add(list);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sum</span> &gt; n)&#123;</span><br><span class="line">        list.add(n);</span><br><span class="line">        Judge(sum-n,n+1,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int <span class="built_in">sum</span>) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    int i=1, j=2;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        int cur = (i+j)*(j-i+1)/2;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="built_in">sum</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(int k=i; k&lt;=j; k++)</span><br><span class="line">                list.add(k);</span><br><span class="line">            res.add(list);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; <span class="built_in">sum</span>)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>递归或滑动窗口（更优）</p>
<h3 id="6-和为S的两个数字"><a href="#6-和为S的两个数字" class="headerlink" title="(6)和为S的两个数字"></a>(6)和为S的两个数字</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h4 id="java-5"><a href="#java-5" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int <span class="built_in">sum</span>) &#123;</span><br><span class="line">    int i=0, j=array.length-1;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]+array[j] == <span class="built_in">sum</span>)&#123;</span><br><span class="line">            res.add(array[i]);</span><br><span class="line">            res.add(array[j]);</span><br><span class="line">            <span class="built_in">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i]+array[j] &lt; <span class="built_in">sum</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-5"><a href="#思路-总结-5" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>首位指针做法。</p>
<h3 id="7-左旋转字符串"><a href="#7-左旋转字符串" class="headerlink" title="(7)左旋转字符串"></a>(7)左旋转字符串</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S&#x3D;”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h4 id="java-6"><a href="#java-6" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public String LeftRotateString(String str,int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length() &lt; n) <span class="built_in">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    char[] num = str.toCharArray();</span><br><span class="line">    Reverse(num,0,n-1);</span><br><span class="line">    Reverse(num,n,str.length()-1);</span><br><span class="line">    Reverse(num,0,str.length()-1);</span><br><span class="line">    <span class="built_in">return</span> String.valueOf(num);</span><br><span class="line">&#125;</span><br><span class="line">public void Reverse(char[] str,int start,int end)&#123;</span><br><span class="line">    <span class="keyword">while</span>(end &gt; start)&#123;</span><br><span class="line">        char tmp = str[start];</span><br><span class="line">        str[start] = str[end];</span><br><span class="line">        str[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-6"><a href="#思路-总结-6" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>原理：YX &#x3D; (XtYt)t</p>
<h3 id="8-翻转单词顺序列"><a href="#8-翻转单词顺序列" class="headerlink" title="(8)翻转单词顺序列"></a>(8)翻转单词顺序列</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h4 id="java-7"><a href="#java-7" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public String ReverseSentence(String str) &#123;</span><br><span class="line">    char[] ch = str.toCharArray();</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; ch.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;ch.length &amp;&amp; ch[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;ch.length &amp;&amp; ch[j]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            j++;</span><br><span class="line">        Reverse(ch,i,j-1);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    Reverse(ch,0,ch.length-1);</span><br><span class="line">    <span class="built_in">return</span> String.valueOf(ch);</span><br><span class="line">&#125;</span><br><span class="line">public void Reverse(char[] str,int start,int end)&#123;</span><br><span class="line">    <span class="keyword">while</span>(end &gt; start)&#123;</span><br><span class="line">        char tmp = str[start];</span><br><span class="line">        str[start] = str[end];</span><br><span class="line">        str[end] = tmp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public String ReverseSentence(String str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.trim().equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    String[] tmp = str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    StringBuffer sb = new StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(int i=tmp.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">        sb.append(tmp[i]);</span><br><span class="line">        <span class="keyword">if</span>(i != 0)</span><br><span class="line">            sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-7"><a href="#思路-总结-7" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>方法一：同（7），将每个单词反转，最后将整个字符串反转即可。<br>方法二：利用split方法获取每个单词，逆向输出补上空格即可，缺点在于无法处理“ a”这样的情况</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess2</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Mess3</title>
    <url>/2020/02/25/20200225-offer/</url>
    <content><![CDATA[<h3 id="1-扑克牌顺子"><a href="#1-扑克牌顺子" class="headerlink" title="(1)扑克牌顺子"></a>(1)扑克牌顺子</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean isContinuous(int [] num) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length != 5)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">    Set&lt;Integer&gt; <span class="built_in">set</span> = new HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;num.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(num[i]))</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[i] == 0)</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        set.add(num[i]);</span><br><span class="line">        max = Math.max(max,num[i]);</span><br><span class="line">        min = Math.min(min,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> (max-min)&lt;=4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>按照规则，五张牌满足如下条件即可：<br>（1）最大值与最小值之差小于等于4（由于有0的存在）。<br>（2）没有重复的数出现。（对子情况）</p>
<h3 id="2-孩子们的游戏-圆圈中最后剩下的数"><a href="#2-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="(2)孩子们的游戏(圆圈中最后剩下的数)"></a>(2)孩子们的游戏(圆圈中最后剩下的数)</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;n;i++)</span><br><span class="line">        list.add(i);</span><br><span class="line">    int index = 0;</span><br><span class="line">    <span class="keyword">while</span>(list.size() &gt; 1)&#123;</span><br><span class="line">        index = (index+m-1)%list.size();</span><br><span class="line">        list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> list.size()==1 ? list.get(0) : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>约瑟夫环问题<br>（1）使用一个list模拟游戏过程即可（使用数组也是可以的）<br>（2）如果想要代码效率大大提升，那么可以先推出数学公式，然后套用公式求解。</p>
<h3 id="3-求1-2-3-…-n"><a href="#3-求1-2-3-…-n" class="headerlink" title="(3)求1+2+3+…+n"></a>(3)求1+2+3+…+n</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int Sum_Solution(int n) &#123;</span><br><span class="line">    int a = n;</span><br><span class="line">    boolean condition = (a&gt;0) &amp;&amp; ((a+=Sum_Solution(n-<span class="number">1</span>))&gt;0);</span><br><span class="line">    <span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>链接：<a href="https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1?f=discussion">https://www.nowcoder.com/questionTerminal/7a0da8fc483247ff8800059e12d7caf1?f=discussion</a><br>来源：牛客网</p>
<p>解题思路：<br>1.需利用逻辑与的短路特性实现递归终止。<br>2.当n&#x3D;&#x3D;0时，(n&gt;0)&amp;&amp;((sum+&#x3D;Sum_Solution(n-1))&gt;0)只执行前面的判断，为false，然后直接返回0；<br>3.当n&gt;0时，执行sum+&#x3D;Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</p>
<h3 id="4-不用加减乘除做加法"><a href="#4-不用加减乘除做加法" class="headerlink" title="(4)不用加减乘除做加法"></a>(4)不用加减乘除做加法</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、&#x2F;四则运算符号。</p>
<h4 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int Add(int num1,int num2) &#123;</span><br><span class="line">    <span class="keyword">while</span>(num2 != 0)&#123;</span><br><span class="line">        int tmp = num1^num2; //非进位相加</span><br><span class="line">        num2 = (num1&amp;num2)&lt;&lt;<span class="string">1; //计算进位</span></span><br><span class="line"><span class="string">        num1 = tmp;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return num1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-3"><a href="#思路-总结-3" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>链接：<a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?f=discussion">https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?f=discussion</a><br>来源：牛客网</p>
<p>首先看十进制是如何做的： 5+7&#x3D;12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。<br>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p>
<p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111<br>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。<br>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。<br>第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。<br>     继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果</p>
<h3 id="5-把字符串转换成整数"><a href="#5-把字符串转换成整数" class="headerlink" title="(5)把字符串转换成整数"></a>(5)把字符串转换成整数</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h4 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int StrToInt(String str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str==null || str.length()==0) <span class="built_in">return</span> 0;</span><br><span class="line">    int res = 0, i=0, flag=1;</span><br><span class="line">    char[] num = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(num[0] == <span class="string">&#x27;+&#x27;</span> || num[0]==<span class="string">&#x27;-&#x27;</span>) i++;</span><br><span class="line">    <span class="keyword">if</span>(num[0]==<span class="string">&#x27;-&#x27;</span>) flag=-1;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;num.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; num[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            int part = num[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag==1 &amp;&amp; res*10&gt;Integer.MAX_VALUE-part)</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            <span class="keyword">if</span>(flag==-1 &amp;&amp; res*10&gt;-Integer.MIN_VALUE-part)</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            res = res*10+part;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> num[0]==<span class="string">&#x27;-&#x27;</span> ? -res : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-4"><a href="#思路-总结-4" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>转换方式：<br>（1）判断第一位是否带正负号，使用一个标志位记录。<br>（2）向后判断每一位是否符合’0’~’9’<br>tips:唯一难点在于int溢出的判断，如果是正数那么溢出情况为<br>res<em>10+part &gt; Integer.MAX_VALUE<br>变化一下使判断式合法即可：<br>res</em>10 &gt; Integer.MAX_VALUE-part<br>负数溢出同理。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-mess3</tag>
      </tags>
  </entry>
  <entry>
    <title>PES-Gmair权限划分</title>
    <url>/2020/03/01/20200301-tec/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="65ef9b6385d4f2ff08c12a110ebb95d7a82888a77e471b397b17424d4615acc3">4d94d3e2ea964a9497276ed6e2e3b252f7448996904b2d22e4065ed40f4d7e9820f3762c45d6cbdf9bdce19c3334dec7958c66ab6f6a69930450e914b93ff12edc2be17e8f1bb535973f5b066adf452a76c30c784439363132764048afb28ef071d1aea1fd8f14e531bf0f3f141e1879ed5612e1d761341f53927e15496b5e0b6f78830e96216a94e3c31201e0955805d76dae1fbdd6015ba3c21afc7515c1c8ace57edbdedd08e3398591c4c64abeb59f4becc312731c01cf0a801810eb5f1d3014b5ca90f22c435f0435a024b4bb99ed52ce05cdebf49e9d5f684e1e7f76bee67c229694ff038ac7919656ef12350112a9103d21fe5d28dd954e422fa0335335c7d2af72453120497dcfc8cf8bddf689560f48b18c1ae3a0b93ad6003134d78befcb2bc655495b5a698d9b9ea2e7d1c8bf9556f142869ca8b0577580dc746550ef1e2a7acc98eeb24a32dd7f091ba6bdd4a82a68ef4010d644957aaed26bdb627eadbcae21cae9644ad0ec77bef4d6c81099f581652bafc93893d507683aec85c48250faf1e3a96c5421a298fc87671489102094cbbfadbe980c4453f59c2c20037b99800b4a6ee2205cd2c0319cba21a745cc77f81af1d3716937c18d2ebad42e602d0d0b1ee89f2e499e8f3cc0b2bc70c83f6fdf700706c21feff3726eb70410c61781b87b2a3c27bb8146f3c2bc31d1bf46aba654c3953aa79d2ae63233985e88bdfffa9e07af2d5033c5ccc5065f002bf005304efc02ac8a0018097f0dfe1fd1cbb8188ac7b3001bf4b78829117a049747f7b2f818b5cec847faa67e96efb2e858aa746e8599e9207eba086a748c704782a9b7822981a3856be52b3e4524450f161fcef14ef1b987af95d9f9a594af3421da66c0e3fa37d5dc4a9957997a3691881a555c8badba4984d26831380424d5ef1f1e32ef1538a8e44637394bd4766973bdf79cb5ff84db7cbbe9e5429b7deb2ed2c1e90c24a1cf8a1124098639496f740d9c027e59a3787d3706beb9e99b9ba8c4a17e3615d16764bbebd80b4d723b3021deddfb30b92d15e89ffd21c3ad402064724cf8415330b5f2262a555f088650812ca946fd893bb0dc06c37b8f4c849008112960d0f9b8b72cb28c52abaa71665bbe960bcbc8d0e2212dfd0ff13dc71908439ee515d097d194163d851f87bb75f49e04fa87209afcc3ff6077e041049e43f359832fc940b246bf75b8dd3f14d5effbe1581b833afdfbdcc8fb343f6f97003fdd134e619f1edd7e655aedc3316f9aa458ebbbd0d2e35028e704c969744046ad450863fe9bc1a8c7f935f51e8a8ac7cee1c3d2e0f8a61f2bd9c857cfda89d9929f3f123ed88ad18e6ee9c95d2b95b3f1ee35efe67d576b8adcd05a25f02c09603cd856039207ac0161d4fbe6403568d791c32c44f9730cfb5cf4b81b323f03159ede28fac0b979348cab39b3f5cf4a772b99c771b278a03153a99a997d64898ceb8f0e556c7c2fa283a01f5c0a99174aa9056ef063b93462a2b40fa445d8beaaf249ace0711398fb643a0d0b4e7f3e319f36379380e0edf1facb9e438fe62348aae29c13454d4c404483e4ac04ff0c72aa02c8681169a57d01bc2750df6d1d3e88f7c677ef17e9d28c78296cc32e8622abbe65ff7a69445870f992298c497c3e18e982eef730e35fb8895d0cbf45b8fc1a5da583eea49cee74a6022c984f0f33ba8a1260e36ff1fc249a032cf4241b33bfde7a42765e47fe9f87e511302d6c002c7b3009a8d078c3901aa3413e097dd4a872846ce84df0d738cdc5036ddee97df60a6ca2178732d916faaf44b89cce2a53b710c322f9d8bf62d5f4a0e2ccbfaf8f06b0c9636d73191334998ceed0e93d3835e1121d4602c234717c1840470fb3bda082890ed730045c1a8779385a72fda1e730a48f6b6ad8f2c6723723cc9c7888a6b682a39e4624422dd5bbc8e678d52250c183254e7eb465cc6c0cf796ca759ee97f4d7684aacac95616c8cb7ee85b2cc0e4532b99e58b052598fe24a894a659b626d441ea821edfc6f1f22fed07caadd8bce0caab42c8559e27fc8c5384f1ef0ffa826a58a8a42f4bf0704c01291c8be801d8daa25b9f0e69f9c54094aa73e455184440f5ded10b40c0ff425dd3cd0c53a96f27a8c802a077d1e1975b17acb9c44a72d108859c5c6cd73b642ac472c5d25f167d1108b415df39df7273bfc62a811fc95f040a99b569a50a595d2eaf8160627f2b979f11f9d6e625b0087b06be661c500a4d28b5d5ec7685e7f7f7687aecb953ba7566eff7d18978d0cf6403b61c431a34855eb13339f18417916b44c1bb51f8924de5f103f49c2a213a107b2990aa3964778d3cd73838f4b23d2cfe01881289e7643fed5d86cd36cc8685042f3fc805d9b4f1dae13b31fd904c9138de6a45c0a02d238aa7bca4251990626ab2cb6cca95085802389ec1bb82c1e752ae1c4a4c82a750073f8468b7a7a438b556fe3d8c7b4097f6d66c4f325c8ae2dca744864e6af516b6640cf9f284b4de37967e284fd2c42303d63765628f2f459279a127096396af9356ac484d2c812a2559770d4726f34b0584c019c4c63ed8831bbaa666096eb052a0feb6f01a1baafa36ac52fd18199ce1f16cd21ce0cb7bc41058d6107cc7a264faf738f0efe0d2855e3e51f4a9680d31f921be2d237ed72b50adfdc57e1a1eec362af2e4f88b73dd3b639ecb03016cc62f9e23a64ad1172b7d2c7f809d4c0f641e32d209373049c0dd54f165fcc8ce8741d5e0a6c38d0ef98270e5cbee131885ef733d539c82e768c64bd4ab41c7b415cc4e9235482f602bf9b4c1a133af7f72d38abd046bc2cea50e03317aa1e27bfbd0cb83c1c5907fd60e0df38ee13bfe463b3cbf141bb78da4f6ce3d127cc2027b10057672785f9dc5ff2fabeff4b68782f427d7f3873554902799dc994ea03db0a6ffaf2d8d4c8edf2f1fcad7c61833c822a15b4033b9141e324dea399fe1cf44c4ffdb1e3e5de6feedd1c073a562345aab9a8d9b757dd6bade3f4467dc44958a6b4d409db33568f537e1c672565c73b86b4774a3c1cc967e936aecf066ea5f4564df1d646ba299d97bc5bd38985360bd66db614c567aaed633a0d5b76bc683fd5fcdd6a45fa14c0d2d1ecd9c5661f737c2e3cf4521b48beacebfa90906d8021d330a5f78ecacd0cacc426c701344a4acdac931426dc5be2618fea8ac8b34f9ff59990cdc18dd42f5e9029fd9fcd7e278ec1ab3be9d20237ae8bd5ba1d1ff816a0194f4378187015b0ac9b398805e8de3a82f0acda25fcf401ad6804616941f1c94b055a1b1ff027a92bb565494c2ac1599ce6728fe68ba62464c66cacd88a12b873ba975a8b551c07e0bf1ddfe21844e0c6b7de21660a03ade0a7d6362f4c836483cae9adab2fb8804181fcf0e03110790296759f930bfc182b31ad05ca35ad3a67771988e58ba201dc20a445334e54c5e15d575ade61c7f5249e28580d9a263ce49e2782ccaa233cfcf604b6f7fe15cb6b61c1452859e665bb6986668d4bc8952955b9b6850d8882a159f4f351197470a1ba56ff9fb99fbf2ed3c279727765a46f2d27a57bf9eba5c1a5735d6ca369468271e09ea50e20a1654772733dd48d225bb532a3602ea777d7fdff0b46ed04c2ef09e670df08e0b94421dfe43e8040baa40740bb9f55c4e66204338756f4782466aca626c9a5d3fb11994751242330b162dd8509fb7dc3fdf4bef377404422b4abbc76cecc0474f7867fb821e157ddd72db6c553d34d007f779a91c8289021fd483c5e59708248944b4e014e4754838b09f465f327ed87407e8bbd9eaccfd962cc7710b39ea6668c1a2152355b59b8d80d91d63ab9636158417c44c69530bd244b7755c151dc27b3c948596cdd2a7b1ed94d65d2b4880fa8c81e2e1b73793768da5f6e0c0c51f34e605877492c7c5887b076ddb885d46e69bf74037c0e3884c8a6ca82b4e582be5ae21ca72180674d54d92db8d8cba87ed033e26b0a7b659202d0da25331e8e68e47556b14204417b2378b2a1855088e4bea60be40725f77096a57f885038a1d4f6abce8bee5190564e873b0aa4daf7eb4ae38919a648b2d431cf8251bf2e436218be2199348b443a05954b80a9f88e6fbf6dc6fc9527466253678e2dcbb6bd1fdcddbadfdb51f5984725d70d9841348b091128ab7ac6a2cdb7695c791af9399d2bef05db6df987a90371343782ba4be0a620e25ff77fc728fba1a0ae684cd69a25f1d5047cda95e87ef5bfdc86dc40918a9678ff5848f74ee1f1708bbc48fb1b99d9991ca8d54da35f3e25e3bf0bbbcd7d443f450e0fef2f512561e6014c2d42fe0ee20f09f1ad50d2a4f3250d32a3d21c1acbdd5d1cdbc4ad9fb86fe8e922e263f54965a0e1ef1d9c075e8a5d98e67a534c07b9f1648837f4be32a232f8f6dd0098b9b8f8a73970aea2d02596128c7f314729c0cba610b2b3152ac8316efc6e6c8dd1aa384c50b12364915a4c68ed562411e6f6c73e22be2907f43042d8e98dd0b541c6e1d180aea12cb8539a1d8e70b49064f63288a0d1194ceaea232b2caa821738d3e0a278c1db2cb17526a95fa25c4845f0016c5176141129a32b3b0d27a848cfbf6f2b5a9dd032e35b4141ff5874c69adc9a563aa377d48de83948d2717a1e81cc10f084cb6d74c4e0992d5ca286909bbb23f8943dc221d59cdf9c3e4abd11193ab8d883d8158e0ecd8dba0eb06ec819b0f52deac1f69fbaa146186b422456e7d01035ad828a131ea865d06c249fc952d4ed47a50e24897c25cdc0d65e9093aeb9ce735a298d9176d70882498f06fa6377b1f1607a50c0ae840fffb991ff95c0054c2e57a53ca958f2ddad291bb413bdb330b6783db274f636b83d67e6cd9eb63b32975f8ba2a33a7c69e70d0a17ea5b4e38f23bbba8ad0202a16577620b10f1e26125b593fbd4d9d844c7309234a414b7487c767731920daa1f92ff39388b7aa2603314b7d15fa9b86aad7aee9e454096185374ef0c8d10c0d5444f549b1e8f27c70bcfd446b5ddb06af62d3b522669c44db527badbbd24c44d229fc51f9633a51a8f3d89728b878fff6e39a7b68725b1bb20659e986fd706b428701b9b382eaabdec708589a0432cb1494d9dedb2c668ff27e052babaaa1b2117859e8cbe81920adc400b8fe02d1e2fec7fcc0e129292751ae7351ace4befdff68ac7121d7d048f395fbce1b6c116cf225c2f986ddfa9a9ca12942afbea61de9f20cc8a21f8124c6923779d9581806e86a25dc012c952273fd516d37a48514d2e48196954c7cd5e06960b2354333db112cbf5e3e80ae372ff0bcc313a27a7d02131458e06d0f81ff52688b6dd32975a1dd34e6407f3e107c3658cf6d3c90b561b95619867ec4532b09f94ea2735ff85fa284560a29ddd9a65a4a6da73a68e870150615aa2239cae93cd56d5f72a182f20e354043987a81b827b2d3ee3ca52da7b485181e9df5742aed3f80f7c75baa13e7e227e26a78d920f2d72bb4854c856d63416e6358f75993644b2fe47ea611b46f4673ada45ae1a5c88fbdd368304c0798c282fd13467fba90f1eed82c8e4e0d0a028f9826ed8a86bf68d4ea9035201260f2bc31a57df38719ae61322e5ee9267125066e585e5f0ba8f5b2dd17a9f4af46db5a899be37944c22f4bdffa21aa27ab65ec4ecd1ae3834ffa57a467db03ea2d1e52bce6e7910f2a74de6034dff0da91f5b529de4d2e0b93161cafb1ddda10b8c5ba8600618ca709d39f7ff8253df2656deec04e94ac9c9c9ec33de77432f5a07b0280daec12964ab4e60d916b17058f4243d77759acc10a05bec25ada25c98f19f4f1d19a057843f691e9228e2a7b3a36d9ce64798bc67270429937ab3e0de80fb145b1aea15113ec8dfcb275c14f7b928bd47f08bfeba240878a5f1eb6fddc9913439f38460fc9060207da335abec098bfe34c46278a2bd81571fadb0b0b0a48523790553503f79fad11a920494f519726532e9be85caa95180957a9947740a5a2fe3607fc750f492c01560fbaf879e459aef26372a0490191af13e1adff08cbc2ca95fbddada7a2629e1c3e959e5bfb2416d427377f5e7106207902e0f6cce040a5cbd1188802033361174951553c45adc60367ebf68df3661c70ed708bd76ef41dacd30629eca786267d3d450c8eedabed0850589a8ae402b4fea344269fbf246a811c3c3b7ee67872b2193f91fe4bfc8db716631c2c03079b181032488d6afe914ebd02ca1a26443d42599e62e6f475dd3e39f013d5be44e5f955173d2e9bce7d7b20008f9bee236aff7fb06fd3386210668810daa76f3c7f694a72ad53418bdae808e9d717737d01e545327b311c474edc4344c339ebea1e51ef4728346f784a3d18b8f3b34cdd7a28ab0b9d8d035af7960f1cd5dde52589d6cbd8fd35e8a50b051fc9dceafe4094d93885e43bff4f2821e9587d2d53cb7487e0de5d6252c74fddbd2b1ab0bafb5e3515872ec12b30eccff31ca98775abf209bb2fca529a859b5d162c5ffa8af963f22a64b6bfc8e7ee28dd3434a22796d826ebb60a75e944d0fec0f54bb7348035a220f19cea3b33d09a725bee8157e597829583fde17657f2126f24658245400348641938e80453a10d4bc70e7588d3598a0bd7bcb8d9a5e71d79b5dfc0425e459d4c4fa6fa445c1a8cd63f0ec66e076778ae68f361c4ae3484b38288008b131b535ca9bd0300b50f5085475ee9c44fc05a688cc5241b3ddac62c117ed4427a65504b85db1532b3eb3b9c72f15ab267b4a99acdbb506cd2ecdc3edea3f6f2d2b99cd705d0e972f659003a05e70846dbea8340f5c867dab8e29d46381e43b50c05c38b39b040d11ad46826e2b32d96514d756f386e95c752bfcca9ac4723f97f4e8c7e8595944af6ec5246fa9674da7f753a8fbe0f7ce43b10f39af517076112f4d062864a30ad9c268eba831bb8edb5e9d6bb32e8c36911d5e8f6d404390e4143695ffca0b297f9891bbc882afc19c8b6457bcbe012851520c3060552f3bc2e5565cf0b847f0c23c8e3be85d83d72d912aff68ee5782932bae86f6745cfe61f1f63c4db5464ffdcef442d9f7f48cb01a388f0a7956a8e7215606daa552eea25eb3bf1730fddfe38f9270f2084b062d59f0bd0164aad47a15bf7a44d2ee1ecf49250dae61014c72891f0f225f81c5e6b753976a3afa2fedac0fffaf41bd9c896f6b6567f74dbbcf96abb28d5b343bfd6fd68023d24ef03e0d84c95eb3189e827e9e0f43e54102e1310f59b2798ed4ac60b56e08f09a36b1814ad4244a46503fef368b67b1b87b98b05dbdc56943a3203a8127f35b810e3a0f88ccc41a06911d3585ce4ebc339c463e9bc7d345cd1c384192ce47c7ba7f10f0a21ffe15399f18deb57df65231b156591662b2f1f92e82534ec1f7068e16fd32f927fe70061d2de9ec4d4434a38c55c1474f28bad581a970c7bcddb9632b4b641c3e73b2686850fb5aa11b3692e4d0bbf514b8bef6207f4ebe4e94703326e64ca9454d2f108ae33a3ab87311c681a6ee8a1fc060d92588eac9b5c52310e63251918b31bafd27561c97284f51823a5996f8848e6559d251c9dfb14b25e5db68b1ddeda6aabcaf72c3593ece31e5fa435c3224685916c214bc0ad200cab3941429e6070d137f3637519936a22e829cf1c1dafc2416c656d129bcb34fc24b4ef92c37815dd92339f14be901f0ee650577b4865d381bfa7ecd81b113479147c55a3971143a42e20ef7f3f73f3539cae68c3af9c9f544fad71b10c4145126c96f97e4711f990b9f8999089db2b7bb6c55541bb4c42ba8c175dc1cbd6dca0d68df25ad7cbf84abae4890f0e5abb4699c2a948a2991538f6573593ac59fde23bef4afc81e744af498794618b01b98a9899dd370064d1388f4e75d9004d17dbcd4c22918a27ed38ae2700123fd39a6f3c963078c34f222790dbadde847ff0774f1e6d3a67a12d6d861299fe00d94d20c7f00fd8668125483a0b61021576716409da2b8af08232586e3edc4f19b7b6fe849324efc2985243ab88f07dad658d0b158669ada9a4da15adaa512919714a2ae8ca67d3554fb89355562b9dde5ce03ae31eea467e4b33a30da5d8bf78c35006dcabbdbf53e811d1e38e7eb233bd18e1eed50d57b5e2ed3419cad07bdb14302356d9059ca0fccd120c10bc66c4e037e71e582f12eb78567dd33fcddb8719c8188e8072b7d1d42c290cd4d4391712a82400dcfcb59b909284c0a602ae25da89fc279b82483b5ce18ccc290ea13b11f180287a5fcc4ce8a5500cd50d1fbf45b82fbc33c8b0ad7cad0a65d295d6c81a06af0a47a765112b7d62760e0fdabd6a60d99a108432e65df5b5d41f101cae60b675f0f68e262eb3de3305aabd5d1c616d9f28dd60c62fe9d534767e421553d0ccd6167caadc7db4ee79b25ea6455c68f9a52f66fa054f344cbb5e3db6268ecbc0df0af88506fb9a2a9831c8de62a6634af622966759d92643599055ba8d73ab4b796fe3f80d51320ed418ac7a462a0745d96e604c969c175837e61eda69bef98453f85203167e52c5f9faafd857407e75fae6929c4594d05a46e7c337b3f5c4cfb204ed4eb2b553b54a55c057aca80c0a5831edaa2d0fec6bf1f0579647f0dce050233d524bcc8e65af2a3c422dffdb36bcd993eef122c129d8142ab4cb76a159eb05fcd85034a32cb84af00f70ec3b2b0c70651b7383accf1a6e35090dc45715ba3d89ff9a61af93289bff1b92060e333484b9f9fdc34d51d297ed73f764a1c63cae30203522e42cbeb94e5409c5ef03b348b95dff315b110047bfaf586a979bfe65f0f3d2829c0e4cbe73b7de8a7b30e97d0e8eddc92ec6cb926a69d4f11ed8c761f20033e5221b5f732498b7f659874416fb7fd7f30eb66e6ab83257434eb29d5ed7f4ff7f44b8d582292091c07bd7d808993d88c99fa979b383ec31e0a70249765a90300ae9108a56f393396779c4d82ea87e01e0038d527c2ca689a6276b7cd8cf11d021cb7169197e49d36fdc1a9bdb9fb6b00ac7aaf7fc621c60e04409690add3b85505b85e9b90f196525064d8c1286d17c1d8158008fb02bf8a356b33cf88758633b81d210a109c1442b3ebc65f407be0318af2387f0d0c342ab0cee071326bd40fb4a859050dd78d1ce61aaa5939bf0abd9cb9899e20b5599e13f4799fd2ce4bdfc1d6646342a364a84570dd7bf1f3263077fe10293d1c1db52a80dbaab162d34e99972e956c92a0898a070eeb1b1778f7c01311c6b6e0e8aec849bd3181e157a637356fd67fdd8ea80b2ee8f2754bae7e77b6adf2114e8562e1db9321551102451d1489576dbe879272db220485548884354d2078bd7d258633025c160b85a033877a6152b0082661f5f5b8f0c3230b4bb1542aee6d8dc237f2ac0e7d12098a553a1d3552fa54db51d5ebfb584264ad886d9e5a454de87dc48e938e1e21dc13264a0e6be69ba3d62253e4b34cda649af2a70b226406f26a1973b31b45cd508941c75c911e1a5ec8fb7d973dc063e59d894ce3cf8514379158d58d4f82dec97e537a8f042fe42a351b6b691a288281ca9b3a10bc56e6c68d4472bf49588b7592615de7cbaf6982b34cf6efa9b4b9a07f357740fe57aa3aed6b1b4132c08049305a6059dfccc968a05efa2646a326a53d6657b939397f1fc2f7ec072792aff191b7027279586166a911b15fafad62d4716dd0700d384169c5c38972324bc354cfecb5fa2132ffbc6d8ceddd39015b704da019c9544c8e29705818c4d6ee998ee35aebc8cc3b3bf6bc7f729d2aef3f36acfcba264429ca385922686a286a0e41d81b949f56f9b65754bee29cfd9c7a30d1503441a26e4c121c9279b0380ea7248aa29270147054faabdea3fec6c3f5a9283af2e7f6af6c11559f93dfd9cee6aa2fa0bc8c3bc69166c13eb02fe0c226d0c04a824b49ca9dc929d6669e5f2c0b3d85b78e91415d0bcf6668f045c472e21b6a656748c93a789cabbbe276831efa2a719c78c480b64ac387b05b3ef6893a1d0199e23fba593cde74f29e026f750f5f151c3af107e8a8307e342a0899ca739dafba315068617259cf2613ac0cc9c6c3e73ce5457a5f751e1e58351b0f63328176ca8ed71742d7c5a698bcccfd4792b5f6d51a1e512995db08b72737201e23dab08279a5e5eb9e83a86478e89acba2d50cc23a2862777b1769fa64af9c44f977a5db0fb336f6de3d032bb4ed7b75b74ca103a0cce5f49f569bddc5424b8bd566eaf3486af0d03557646b01abdace0684fa988cb9bdc122122a987d145c239d200853f0064e3c201c32c7566beef4fde0faae1f25d4317c40f99f934cfa8dd861ec045313b30c9335093cfaac018800c443e3ff51778d9609125f7aa1b1bf87ea6c1332d0786bf831438888a60b36336a99c41c20322651056077b87907c72daf82e8e49bd9b6b80bbd6ce6903c4c3b9701ef42de23fd304a8518a865df940d99b8022791b185959806475abbe691f0887116c011ebd9370ce5b354d9ae13a724e3931abe939b0ff17dfbd0dcb7447f180811cf5ac6939ac5553601a3519771cbe202f00d613fbdd51fa20c43d0dce738a5e61547e673d6cbbefe0a6a15a6b1310c37c62be8a531f5470cd45cf20b11929a1b9fb283795d22fa64cf0d32f521cb6d3792bd436b8c3af2f3e2d74c85870ffd1a728c58f1e27e5f5f327990e730ffe57da7bf4bdcc67e256145aadc6da35b4088d6624ad477108fba56ca7c78707b75992c157116ad09c184ef31a7013885d7f6a1d1a37c86633c58b7db3f3ef109629b7da7e5370022c3a5a38693f0e9ed9cef4a1c154d04f334d5877a6cde8bdb94ddaf5c49c0df8173a86b852610babdc0814efb2d979a56187eb50e70aec525b1ab652da3c5a732e4475e59fb3cf2433499b8fe447385e8e772f56a015197a9dad515a7ddc66893ec00f8eaef22b7d466eaa271e2be37e83b16e7f5bcf421023eb0eee66c35076493cf5fe013e0f3e7b78c21feb07fdbce218063d81f7ba0d2ac48fb42a7873ab7b057b2f466eaa52d24306abd6a69e80225a5f5830a3895c7d430102e308122bd1b01cb4668a5f5f36833898e145ba52ddf4868096714c24323b8f41c2bf925bdb1967390438af8aa2f973d2f3d516f1a362d3bebfb44fd48aa02c48959111cd9b19cce9b4a086c9f671bcb974215322ad439f60839f1d8ddef2de8aa457a7a41b11e3503b53ffd887d8a850a6feb52840274f53699a4ad91846cb08130f9db3d5fb7c1376c30a31f8c2c1ba34a1a26a2e32c5562382f7ae7d259e49e3af094875953e223f5700ccb72194605e518f33fe66078383d344dd669009b62f5f393cb67a90225758f5f95d7465461e72ca86d8d072504ccaab202c5990a40ff9b6c4a92dfdc1a0ebf87126640d01dbb1482434ec0416079fad17d5bf042d543511a50c60ab2caec7bf45d013efe7d08d8285448d517f09917c3d3fabbfbd56ba4e03f7804d002937d6467a2317f29878edfe6c68571ab43c08f424b8657fa09529b7c19ae45913185b5d0772c0c1647c09b7fbb08a6f60c5f5f326b6f7def25b28b750f7b5986b2b7efc4a26dfca230073aec566be419d22c594812f2350584f58607ab05ad71937c1a73c8203743dcadb3d810700de5575f8c24b7714880617b168271a75a8c63a4d3bc546228af0eb088d0506a378359107ca8e0263b6644f3a7d13cb1139d47e2003c54c046a810f8055b82f62935e8cd135a9cda98cefb5f84921628c16b5a82f44ea14d5721fec2c8c22d6d0a5632e5011eba6f4cee3921b139b6a9a358d66b441f03a8aa7f45d17d82835c3323a5d56cfd0aafd12c3bb38e7f590b89400cd4ed073939a116ae25e7b2989b411b3c5d48813915c5b39c0e5c7dd943ba101fccb6a3d0f39a3bf7aea5b13f0f3e4ad0f97706673b10e83f1bf62e568a3f66d2eceae89ee2cd530c8e380d0bf2e1cdd801e4a7ad59850b42e51be0b03db7881721ee8365465cfbf98104e52b38e4b01636569428e69bfcead5027128672418195f06afac63b011086f4e0e57b56d360f7aee551f796be4953954c4749ad0a3641f36c70ce403362a949b249684df919a129d5be39b9a58239297f63f52a326bc96253b5e9252e1be999b74cbc9ed72255893ec7e4d16a98f76dccf7929c3a0a5549e14f3856e71274ae8e25325b94d61878b86c09f2ed1a70aa2eef3f91183446adbebb6aed9d51525b21c2074a16ebd69d487f115a9f944d8a617bb783b977240879fb4df193abace51a344cf88c9470291550a29c3a33e7963a17ea04431a440e3f8c2bbe48ddaf9f6690c2f808b5b25feb4a664b395b10ef737fec3b95ae611cfd55273fa9ec54edcfb4520c0d40a47bd9587e575775f9481a755ee1e7a3596fc6880f6ea6eaf4ad53b3cd1f4700c80319fb633691aa8c0956dfcda189bbb07c43576f2391c08d3f692f719ecd6824e19847b459a25d33c15c34c2a5b0618300a5fdc052cfcc19ec105dd2431d627f1a99fe0a708ded95dd62be221e61b432d4976397ff06972379936815cfb50c7b3d159a0b0375ac50a04bb98afd290786982752e735b7e1217342f3ef28e89d5014163aa1aea28e23263638a167489465492dd662f9136746aa3825c8797c53333456a6f32a529fd2b20915127780885862f96915e114da9cd1013ad5420a817e1d472c5e69095f8233dc5af4f87de5ccd37e826cd2e68771f74612a5eaa47f385ad32a2593f9e4d5155af721e5cf1e1871545ca17eddd1409490701a22eebfd519713a66cc62a0643ddbc4715ce6fd2b7cf79b7462e4896afe1c4f9b0669833f1423eb5a5eda083ecc74861a8e6eeb3fea8542cb5251fb533b3c5b4fe840dd0984cd4a61e9476d90902507bb26e6fdce3ecf4893ef5297a83bc34c35845a7605138be7858a2603a2f48fba7ee01cbd7309b9e03ec6e25de86ed53a8fdc71ca2e89d82925e875e1e30e581606a0dfff012df2c0c0c1aead1975bdddc0790e1036bdbc38aa75626649a48b65fabae0e21ca0ab1a6b9618a65b22106a68db8cfd8c1ccd0600485e62a7287456813d7272d04ca0156404f3339457e94cef3b10214bffacad253f0039e09e2cf6c40cfeb92fda78a08fa53dc9049ad3e59c933e1cad63dd30fb81e91ddb81ec1bfdd3e1551d9eb3f1120b0a0038f59b8c862c23335ccf0a75b5f347fca8b201119a565c2ff476717e57df7094358915a786fc9c3417b9dc263faf43e0516552b856fc40fba52208b2625d46de6caff72573388fe4c436dce197f0fe2b7c6d28c2a5fd4833c3f4c8297ab0434c9d1e21cb4fc78d3da18747c8fa38c9eea6768a2eccbb79e11252d1c454ec5290216a0584181f550983aebd3b6f6e9fbf39c7b9f73192d5b97b2c93f431dbe80cfbb67161b7319931ad3eeef25aa43f650e0d1f46f9a65ac233a7af34703664b16be0871f8732896da814a2e5cd7e16795ae6d851ab32548abd73b0a3c05820a19162c75778001921cce479490e365ffbb504837ba7d46a9b16f36343401141ef93d8ff0d65e17551b37d07ed2226913d0b3e92f2b40fe685deeafafc870dac811f456655bb7a0203f6ea9f44e3e233995f31683cac38250480dee4c7d6baab9a3519ff022c0778477c940e28bf2f10975385cd865845a36b31fb47b30b71f32753c8a75722cbbd5d6e6601e9d5ee2bdc8d77aeee5e9335900eeea9e0209ed7decac6a3b598375bd47fb8019201328dc0823942a9e1ea4c7f9e3680ee60fdabb1c94ef31b145b8cb0f0925d8e399982c36e61dc9239767bb65de5ca9b4ed901d3658f2b7fb7074a738dd79f64e2cb9221b848cc6cabe4f50c9ed784a719de48f2b087b879d255ed375e7f9291669fecc05d1487474b03f29e18cca93ac278796452d7ee4d8bba29668472d4d43430999e29149e0419db4748482b184c2ed5236db9c7cc508874c6bb46d1a5dd71ffa938ae95db7e52248b46d863a2a2bfa542d3d864bc83f60db741ef46c6098a54b9ee797547852fb138a7c7e065899a4978d64785c8e47b61d676434e9597a48926f71240508a0dd6b794b7e276b60507e2d4e45320bd036b2b82ac351caeac1a327b0f78c4edf3d7c9fd7130cabb0285888baeb1f1f75afd15581066e78047404c2f5b3462f2d6e8b3ceacaa97848d6863859262ce014ad8f83f149a898036d749ed1ddbc29c049b0b067fae583ccf1644d23f1ddb701b8dd43f5ca0e009f7e3be47c67cebd3243f51312cbb473d71aacd88a1a238f0faae809d8dfb9ec61fa46eeb77dcac08547e254b060933cbcdbe1f526e45f2770073b0d3945e16eb45f5ccbcbd5e519ffa5cb113af864ce2fce0eb5720122b99bd130ff8364b3888c7217089e3664ffed4add14a39d637e30dda31c05e0b23c4d622433f348433d97d0d46ba877c9df7f17060eee98055dbd2805acb6f4a409968c9211855926c78e6ff860d2baa47cb21d103e03d0ceb08124e2737463badd56e548e7b559a07d9e4eeaac57fa2973cbff350b0264d8a0b4d6aafe94db4d55cc567aa9a8602321e981bdacbca1600471902d687cf56e8cde853e9d52254a9624c6999385d50a4c1e247eca03b10a749c997d2d0a12e742c6990d077c7f5b354699e4c90739405ff22a3aa653ea0bd45e66ea78ed0842fd703941403bf5c9534713a5eabab6378a9d1b248286562f5eee5b0d17a94c2ad9fe452dc542cc0266e5a35d9090ecd80e25656009f1e1320bc1bd73c06e1686344fc82d699925adcf62726c7920fcbad1a125d74c4db651f9dbdfa0810a4211ba3112c92d02a8e0ad2bd95ab942715815e54420778c1f7d3bd3a0f4ef89788e1413dd8a18fc7baf33caf4c0f7119f8d32e06c19704f2fb976952a6f694b2b81d3103b3a57acd5dcf47483740e5ade8deebcd3da8e9631ac4e081cd355ad785398cbed06bbb8b1911c13ddd1f2ace5cd0c150ae97677e891a51af601de04b26f2a7b9429414514d6a010bb6eaffeab81dd4fcc234eba4c66115686164469699ad77971a662f3a48fdf33edc3e2861163c0c45d6d1af48cfdc3041a40fea32d1450cb4bd126cc6bb0e352004c03ab44659b2c81f709a50646049bf3677bf087a8caa31719cc2a18dede38c1b93958c28a454a603e87918b0fd1ea1a1880e7c942a9bf43a31ae3dc367e87863dcdcd0fbd5a06a727f995f978e4170b7d3ae0cef65fd4e4169528852e21a757d3ade19e6a74462e973367adb709a96142deacf1a1973f25785aeca13c301246cb1b266aa512984fc2e46773e7f914da338baa3f8997667ee5af8e124d0cbe6b352a24273d1bacc9078b292240b81f355c2ae5d4ad5a0fc099d4b3e6a42f6492223c1515272d96735d64d5ec424da116f5201c3ae3103bfd9b3218f110ee3728cb87cd619f2c7fe2dff2a4f7cfdb30eebd25cf5448c7b805af5320310ef51f652127d112231b65a827882229badbbdbfebd9696605c5f0dafd0435cafb9c9a04ad3b67e1381c3391123e15ca9d113cfc91f797113c38e93c61f6ef4c1cb943fe8fb45937670a31029a758dd9de7bc82015901380d757f7abc32ddbfca46070f71acf950ebbf7558a45c9297926138913bed4f0f6cdfe16e07925308b50bdd14fd0b06795d1328cd1eae7df1d3d5b86a48658ef6cf26be881eab74ca81056e989485878879a38c591052d38bdbefb4ba689d7e0793997341c423abdbe8fa923f1017f80e046b7f2f4420a40d6a993e43eaf29b264e9c42d68491eafa4883b03a76b178fd0e156ef9c8cdabd7ba79ab57d9a425bb7223bbd6aeb4b95ba69159cd2efdf0a1b6b6b1227bd8ddb294094c4061307bb657c9322060a90aa442b9336257557090cf0ed4c31e85755c0838fc5658c352c225cdce82b775e9973ce7231070f6ec8b7be28b7f6e4f2dda49faf999d483a12591adc665eb1e5801b59f69f9757f1a4d9180abd5f1bd8f476aea462aca8e1ee1bc9d7d46a01accfccb0a4c1b21ae39c04b20e991d178fddb94b85bb893d3c5c2e7e8aaa1bcd1745416fcc812c06fe94418e0977839a33e18b1e65e4b362da8c724bc9c6481df64f778d78be30301624b9375cc2315f6ce30089da7daeb491e5412e89f644d87850ac1faad0cbb8474b9d0b736c4ee06033f24923f49d8a6277dc330414718889b1ce00c190459ce657a662d16b4f1e09931296322ff2ae1bfa8c662aad67fdf17f3b59511ad237c6463149f66bd4668954a95752e2de9410d56b7f958a305b2557cfb803b269cdb7f0c7b8cf6eaddfb6539df62f2fc6c3615af7a7625c522a26bf28514f4327b0c70576ace0cbf54b628b7e5b242d1166efd50b2c5ea1eb090232bea51a4fede6751e174eb2cb4c50596c1f10d03cd3d00314b23675a2435253aab5d81486ad8303b9106394025433126bc767b05984e3cff06cdb888fedc5643b31557d23b71240d0519dfc360a35ba78b333602d7458fe7979c414ccce6d6b95168b728224ae954b32c22b957ef4076bbbde3826be8fe137d17cfe69f7dde99587a0a95a186cd7d213f934782831b8abceffd2d2a762c891841811669557d214f40710322333f080c842dc427cbc1b588c9dd1a64e043eea3621832f7ab715f2aed6ec835aa8331114cbc851097e49e01e4f1b41a726dc5b59a8b59ddf17e4ea5aadf919a77828fb844098517df5fd23596e422dbf498f28a0ace09312068ae4749627b9ba73320c62ae1f8deaabef288a075b0fe1ccbbbb238ac978f86b94049de68c966d5365f3b76d7af22aea635ae33f82901a464e28261f29d9983e89373df823c553556a9d28a6c400d81b436efa40c53f67faa15b8440885daa49a0fb416d500f7679239554692b6cc11e2de5f33c2f644f8570195226211a07cd58f8f12c4e89e05540ce0bebb934818159a3a67a4251471a6872e530c7fc841c9309cb42036d7a83063a4c30c2ae6816060ce888a2e66b6274fc54f42ece6f07058312a529aa4aa4c2b6ba039b7b39ea2fe6cf1fc18aa43542975104c8248fa2d22758203768fb8e0ae44fa033ac20d5e596fc8ba78fc10a3cce91df1a8c96368beef903d173400fe030f3270367d3abacde4625353ab16c44b112e1680768acb2c46cff7044f13b17abc4ce1ebf49c27a5807e2942c8fd4ba1fd31d34fa0f9cddea2bab28abb9a39d3c32c042d96e3ed5d9752f8fd5de5e4aeae9671bedcf0e86563e67236b4719f1395fcc9f14a7daaa8a04243337a813af7efc2069194a1bd8176039cdeb35815a49d6650b44464302014e819e156e36ece3da303f872c5d6a823a722c2c9c6879ae5afa605094195f3dcdeebc07c809cd350e68dc00391a7157404a7a4c6e78114b67c3ac921e654c0f3ac2489e83bf06f151838858026afe91e8abeff19898556e913eccbef3df7dfa586bd8e4560f05e4811319c5b8903bea4b28446c578e59cced9b918018743a0d154fcbf5fb7c9d903c8b4bcc560f35712ef3ed81fdb34bec614d3d4160f7cabfa8ce589aa9ca78ce351429e61cd8e4bc28b36fddfe41c911a05c9a345f8d7d4ebd5e087170c5bd7abb303bef646c132c0cf57c99f62e23bb3f7d03f63fa5b3c58c455a6537f21a0510aa6c0168d94b0ab9a0b77e322932e1dfdbc9d45fa932d921e8352a09eb4613989a9de701092762425bb702de89201aad42834fb0110f9cd37e83a0220a70d90be051182378c1fa72f97385c0b51dcd05204cc9c155638449bad0ee2032fff30b758a9abd4062260a1b34e76cbef90bd3dbf6a0c05a9f564f11d7507d1378564dd8f9c7affd4711bff7141de661178c0ecb32514a0f46545c8d098786bd42ffd9606f16881063a7f83a2089b95428cf27134810e98894c5f08cbfbe974c3b03ddd2fe802a686e0ec43e752e520d8a81d78686c19ee84081222f4cdc1d7707bf952cb1d108fcc538af3fab26636e7f619648dc12fe4bd51ab742349aa36574ecaa48431775c608d65717e167b16e3f4717b549267349f391f4cf753a23c8d17d69adaa5433c6012f7899fc609b3ebe47b2695ffac833e810f9eef6237173029c1fc203e696eb07222e1071a169b0818516df3edc5ace3f056ea73550397fb08fcf9652b7ab2a2a922a466af40f8183cae4990e73fb51829b7e6f783e7a4fed529258870b9aea0f636d1f5a98ff5bbfd84a7db88203ced1a4bf6e4169e09d93aaf2e3ae8cfa82137c0ace609f1692a7bf2e3a0419f17ac0aa6576fc2d76aca7768c4c0bb578065e924346aa168fbe398f5174bd55f9b07917c59817ba427d2a1feb40d0bd96f81b90822a247a321b9a8b3227dec9703eb6f2d7af133c792af71e2ee13be06a5a113a89718162d79b61c50fdffa547999671518b8c7dc375596324a9f9922e2dcda6831045b2acb99a565be527673e216828212a4acd8cc51455ebfc72f1e23219d7a333213acab819655535284f524cad262c991e771cebee23fd3ecbdddd483c868ed05033fc892efa9376c0e92b75824a67459331f15cb05999ec779373163b0ddb6237b5061cebc3c0ecb72c56cc33a3a97ce8f0849958eb16acac136e36a4d3a308f7f41a2b94f2f65f15ca2958b21e96f9e95cf7a1f805032e66416076c1d1e58b89f76c58902b3be7bb043aff776b8b5796d9e25a09946620e4b48700f732c1430e73dc05d036f3404cd75180224187e011ac783a79a386b71e53286a7eced6901ada85184fe19a782e240fa9172d15012cf141b717a256c44c2e36a02b4476505e1b36921351052093c2e4708e11f1bbacf4f86b2b48365d9e67c6078295e2be5c9f2cad42147ff062c68cdc37767c5592ff09f773fa1b91114bb8992910e219f7f29a68a8ccb0fcab440d7d13243db83c3194cdd93bf3c44d991622009632a30ae8d552bb1f3eee38749deb33d99d7412d04c1fdfb58745e2f0ce018114d532777b8a9930e92448ebccbec8b399f94a05a0e6474050d60cf3c56e84471ddc79de338d6cec81dca8d7f45192b531532561ccee8519556b9eb77852547892d66361223302b4ba791b74cb2f8f356f293acba5033e96937d315a2c2d17cbf15f800cd843c31174f2de44b96ed7571edfb9119a14e761c2db3c73fd1d87180c09d2a51139ec6154eb211a511a1ac4b95d172455ab8b91345298712bb3ae6516025d4b5b1b29a5ec87570cbdf41e040fe9dbe922ad4a77b92e3a245c40db6663ca7263e5ac297c0750ee3903faa5ed9262e1617a63ed1f4e1accbe0522009fd0837b06d1e82ba1a8dbba7c6c558dabbd45b53d75ed143255c83f2ad60e04a837aaa473342075467809c004eed28514306b6e6ff0661164e66068dbac99009de762cebd8246b31496f32ef510d7cd9a7dd679275dd752a78af786cd00697c4aed9767a47daa3b520b1b3e7a9ccd68fd85c6843521a26a3be1718832c1d58aa02f79ecce75791d881a3aab8083992d1dfd234f7f982e2c64e28e8ca428c9d1aea511fff8fe671dd453c56ea2dae5b94c3835c287ee2cbc8fb0402562818e38f16f4b21e1df4e445382d401e5e3acfb9e4582be4010fdbb67c8beb0ebf9f39dc5d3dd7c537ac3c1a826127457fa111e8fc1ea1673b07a259f2207b0b6f42dfc493a8ad1dc8e67987a21ecfca7532b5a34c005953b4bcb1f04c5ba9e72e7e92b99a6e1d1de25b81d135a3d870c93817f2a164b5fd8f4cb7ee333ebb10114e68ce956c7a36cf72ccb015c2fa480e17e4c7a235a9d150c28cf0139f987ae7ffd7329e622be148285abe3fb367e2f381cddb0b4d04f15a2fce6d8aef46c21755609f04fc156f9588ce99dd1eec286c8ab8d95cc0440e7a3fbf3dc6d0c04c309f2c4e5cc69d23b5bf7be3d3a79c02d1cc5b7b49e71f7873cf54ef56ec180ee653b0b98285713a5adc6ff0af5960f39bec5e32514b62c362c32fd3e6a3786163723495b426d869d48b7c897304faf15ab048305425b646f64b285b87618b0584f0e5986f875056c01859088e38d3f842aebf6ed6a7f8af2b2855266a69e0c23f6aeae8fa6720dbc993d572f67bdbfada7064050ae20c943a45e1f1f7e13c2bab20c2854effe475370520b203e5b24c9ebe4645caac09a87db1c69c70d875c89bc52f7331a2294124f13a63146809a1d94ad168c2aff28e2de8550779084d117711ad59d465d97b5d58c00df6a4055c171edd38de59cd7fedd9d3924a7d1cbc1b7118275437fb2abb8f19266a7d38893efc84c57d0523e2fa04924b01f23147c85d248da9494cc4791f6e622726244105ac3a403b5c1d6aabe402924b6d0f8281b57ccdf627166613991aa879747c162c85396a811abcf828e97804220251b874d0b056c1b96351fb8c8ff7f0b0ca5a0cfd3f3f1b80092a596986ca67664db9653eb2d5d14f4c3717deba5b9b7a9b120fcf371ed9b95e70482228d7a3ad7c2452b698d6a22affcfcdcfa6f09abcb94e1492146e0cbf729905386c1d28b120375e47d44fe6d8e0e006a0f7dc122c55c4e0143f4007e3ffba52692c2b27783c60de3c2d2c82d3909b94cec6938e210060c336ee7e5a91ad725c74381b5864273566f6ac3eb0e2f8e71511d96dd0171a9c10389e83364a2e122a007f43b814e3fd43d8cda50e339ee50f44c7f5d14c2f8418656d3252b63535abfabc40f98087206400097c997a9595a93a7e00e10e219bdabf4a3ed4c244873bc1bae0e3c0cf5cd7fd63f35948526f599038f6806625050c427b04b57b6d882a72fd9762b573d845b02719ec7b5756aabbba8849af81b1ea346ad4ccbd7fcc86a7ee95eac5d981dd8eb9efe4af1039453b291434d3806e8932899e831bfe01aad38d006c4c35e3495f05a851e06d801604079f8fdfc1dfbc6060f1801fbf593bc90d883c7f474e74c99c270ebf84e360b25a65212d148ddc74e5f44a0601e54398cd376c32e053ea63caeb15c4ca4598cb6845bcd140eaad66f87c3a80a33cc3eeef80f2d7bdf00fc052af2009e2e0d8b11c03b9773971d1a7f8ae3a95bac0b26525bf329d64676534b0bd4d648a12e97a7012693eea6fbe9b816dae6e8e5cfb4c2f67879ab57222a672b3bb17aaa38a70e038ad3ef011bb439cba28472fc6e324bc2f431aa52f6bfd806d14a318af7a7472725f083eff61fd67ca259ce25a055d607b98c627eb1c465c94cf7b9271211057f943ca3c2a369bb43ac1facb919c389b13c081da776a1c51758e50cf979d93fb2c52fd137e2219d89524ab6a1c0d9dc2547d5d8e10ae2b68d7ddca7dca8f387c319b36546429dd8a2a48ffa055ea3d0e597d337a8870275990a66d459b989e1b0a3f61ce2a08ef208a5f7201dc4139e70d0eee2590327e6a664f438f9c5b0efd5ced5835f3024953f32e3d5d2cc1772e652652f5c3b2accad93003bb5b07c45ace9ba2695f5f1a098e33234a5401c6e81cd4d131b142ed1334368fcfba6960bf63c462d0979faa7c9f0613d401a1e278c847c2c7e307eb1bce0314108d1db8df2960046cff648752371cf51f95ed6e20940f4b86f38e4077b5a1104f1862556e75a7830da08f98f097590ed9d22fb59822eef8565ac77fb5e0b203d36afc183eec2a05c191f4041d2bd33cd4e476232408fc2f21200eccf0ea79cd8111e278cc658dbb17a839577b688f98c0c818ea0b38c199e254429be031c2e4daf3ebe36e98f6f6f16b60aae9d47793a231761a9e47d6d6951567e73123d3b7a7837ba8d8b475f0274ae0541fb55451c87036a690008952db78002989d82d86a2bb0680a0fba370989a457a2c212e033b99c5d99e277951c35a5e8c4437f9a06c290b84d9fb706d45ade289b3174445b09cf7901d396cd22081838d0b028f67e61cde1863d651d8f7b4b4207a11ca0911bf16b1cb377bb5f99024541779cdbb31c854ab161cdca168f28c00a143df566978982aff6b495c9c8603ffd2fb73497a2ad5bf38ae8d963a9c22a7208be3e34ed30d76d451c113f2e18224e878fc29419db702ada147c5af7d9ce2a19fd8c0d4c22cd871e67cfce781f34df2b5c91c92d68162bbbcfdc7c65fe86445f3297e511762a7e849c37462ea892f467030a5bf7e18112d5454c058202abe63df27418790f8d46c26cc09c9a39dbd741124242d307a45db42b2f834b5d95903d9ba4cdebc71efffd2485689480bead0edbab31efcc4be077e7d816fdaead28824c79ea5bcd0da707d655ad8f2628489b586d22e60825f646927a2c55e54784826182e7f117263c14f297a1670a967faf52f2c804c0606b89a0de6c98b4c32e6cfc4788136da5aceb3afc0bf57f0cc9b62961a8ff27d9f4c13b0f1ad2b9a6c24eaf3aa4e9bd0ca34f22747c48298fdbb0f9a39e928000ce191811904e1b937e4b3b715dc371cb522da7c5f643bd956274776f45bac500bc08a9eee8c34cc9599af921e188ca427f678a6c7d01b82f5746447a5d67edb80e1fde9ce28dea43010581ef9a1da927fb3ac1bbdce6f987582d6780f1bad8b7e26c7e5dba3c98a9da5879f0f3c120b222e9338ec8f273d7cb6d2c2a6f6894740aee62bae671d50451392d53b1ecb180c127fe8ec0b18f0d6a2f48796a1652fd11e6cf739c8d22181e364ef9ca5d2c24f8e3b351f56c6ef1c2f14f0f8600bb919d2bcfa211a5d21f58e09fac05315374955778d909a28353b940108af88e23e16df541cab4783a592f4ac33fcac0398b8cb87fa5424f6db5be040f97a2fabc46c6550411b55dc211e86f77bd61170c08ac706d837dcc0ad5357177e39eaa376f3261b02fd8a64e51843141bba69002159ee1022c489aa9e765bcb143b51c4cf785bdf4b622913dfe34bd23fc744969ac7f26814230a3356f119c2e93894f82ab85437fdd58d45373c5cfd423f6b6e565ff283a707ebb828cb9e17f09bc1a51022a877dd1534f27c69f9f9ddb9c85cf0b16195e149445143c8468283f8efe1cf11ed2399a98daf434964c274fced33147f80472c570d38059139fd4e9be660a4ad0af4b1328f65db1d1ad7dbbc2a11710ce45d870fe5d3544aa5c7f32820a4cf6209a38e42228b927eecdd9dd77e1ce6d05450d0edaf44830899fed3c3a831781262addb3d7b3e9280748695f656cbc702a923c76b919fe0184a90bc55e599149053719f295d05608b53322078c7bcb9df6fbbfda9575ad8ab4b4ca6d4956eba6d22ab9671bbf1e12020a1576c44d4bcc462cb53d608a263e0f6161b8d1128a851e767e0de709c5dd35e62202dd881c54f89f53654d4afebab4420f95c7e708561a9808e0224968f92b7c87c24d7c742df89e9dcb4b057f09c5c6628c435466617ef61205c1c4e19abb72aaf273df17f913395e79e87647e06940c84be452af413ae714e2cb880fe1034f2a3c397a3aca3ed79c9718314d6c11e98706b9b4e5f57eb31b8661f0df2a824ecd26f966d352ebe17984d1f809d03ac887088514e0e0339d793fcd00dfc6b849bb43d32a370e2bd50c6b95032257b70141a045d66e4fb218758b666c178a1a6632f7a7e6e1f29a2479db43b2566f9875b693f45db42d9c2db4a2964c2235781aec9c3cbf4301e660dd3d6e9f69246cb3cfab0877bd60a5068ea853c78dc89693067875af76f7b71197caee0a4ea636e53e22d8292aef07277f71843f85f5c2eeea19c41053b5fc80af1fe7eab666b954203ccdd384a0527d9db96efa01b77ab96bce8aa7a32eb26d9150363fb75f8de383e9d36b70629f6233d714f2f4f834401d634e6a8b812b43da3d3f1af79ff068a065837b24abe0b2b2f79758584fa12092a90edf4647a14126b6b926a8f6f187a1d9f21853a6f390de5444331db80bc39aa49eee3ad96ef192b19b882e119a824d217e2651315fcd9747bc91688e027aff8c04d4ca49a676fa5a8696c81644f857b3f0de0e6425a3e6d7a2f4fa47268e1d84c4c5a87ad757efb56434a4aa7486f1a59e4885801910146f89bac67e042717b9040736957a187c2169033636d4631f1f4da6cb77fdc42b84aa74cf91b081f320c95782da5f2acf469838bf20722eca57b02dc2d446bf1614800a7e2427ed89471c0d87e9891a0cec915ffd8782424d60c6ea59950d1bb65616e65e800b0539abdf5a14a16112921661ebed989e6992dff1c05705482a5e866f54c183df51dac8ef29835869a55413f3ee9815d151610cf495988e4fa8e09c9404469eab4a65d07f3a140903adf14645895662ae103caa538d95751b7c49c0cb3a4884486ee9598b0f0ae7cd90ca73048b21964b7fbf6ea5d183bcd13ae73f2c5d8a0231d9ec39808436a59df383b943f9cc76f70325924964cdbf65fb7e24472c11e8bfa3fc38970cf9be0c824773808123369595cea90858f77bd462cacab4c6a1200085db734e8b2f6e2bce2100f2cc604fdadf3b5726df181536ad17e3e4288e0537f84e815946b6bcd72d4c7e7bc815101f08e8d727848faf838be080dbff1dbb72f0e63ea133cc84656d3299f0c113d9d50634ad664e09c919c0462c0393b47d3a708814a6311dcc7d358f49ff34991e68648959a10f0e9c61f410f40ab91f22445218a578762047bac6ae825119adb3ae1bce39273a6255cf266f2d20c0757cadc84d5a1b0bb24f39a557dd620e14b81d7f947dca016345d16a47194fec1e53e9143e7ca0212a1bacd9866a5397a1e92f68c6b8c09d3ebcf3be90c601b799a4ddd7fda3bd1fe70d201aff5560b09d3446e43a98eb56cf83c53adf59fc54097a548a6e99fde65bf83ab85e5fefa302cfd38c76248d2f0ab0b937e49002f6e9ab82a1d24d7961b0cf7d341f1b722fa0528b54b663c788f52ed1a7fc12d4494dc1ee3e3add9b185d6d0d49d1345c72f41a0eb87fea31cd0e71c4559a99207db2b5cdedc5bf365a3f2aa79fdb578a95383d9ab6da49f2ee9d47a62e015914fafeb3cfa813d649ff759e96aa67a8fa355d1445147508fba0ce17bce6fe619ef05dd55f053304e1129f8093eb612c7f469e8ad7ca5d9e3be6f475f754dd096aa16bf969ad3743f377bcbac23926aea658da6d08da40ccf7290d77f1508de6ed5fa22f34dbd9313f150b43284ca6254794ce5f7d4ac6ae293c597d4eeae9c04b2379414fd1e5b990fa3f7d6ce6b3f22523587a96d6c77f3726e4a7ca3a6e33f2f49471eccbbd619ed39493d8f0d9e90c3ddf121c8413e466ad7d859a0a3962e6587f0fc092a8426fb95480b3abaf7d021e6bfd8592378ca8608bd4f0ccff94efeb32b45480e15552a7a7de391a69eb07c9fa395a2a545b149205032481408d8cdec2cb09d0d3699895f327b3d5a3e41d24a0e56eff2ae3f28c5fc83826a096541ef734f722835a8e3b1a6759e56a6500116c3fbd2bcd2613aca474eb05ed2840f0558f0974880ee0901921b788ffc7847c3110c8d684c909e4327886e3aef9e82875cb7217cf0a03124d27c49a034a2f733f72c5d329aa39e627c8c66b49d9663d3245e14a0437559473cec41dc081842d87b8650a024c2787b26e13284d892bdc0abeae2a5d1994e2883b17ec17ecb3cce30877af47ca2d7f85c4651cd2d2a0bd0a6cd860c6c9091b60e1e7e26e27a49bda95f2b372d6b3deaa77d4e8b3de337bbbcdfdef9b77504cd84b5b78e4990277b2f0780ee49f738d6db7bef2e7d2fc541ba325391b38df32c2637a2f5d22db4724bea0ef88f60075677dc14a67195e8e554fc653c27c6a35fb019e2bbf9f8c8d7fbb927e92732bddab2d1ae3e8c042f44aef15b1a946d8f7d2fc34d0055a07cb2454a9fd77c0ed81ba94ad226613174dc5d03277bb557fd1c0bc79802be74686d4d7639c9dde461fd31903e4b2148cf822e560030db0494048fbcc1f99d184e8b8654e0be645574ce82d3c73ca7da672dbab49ceb4db50dc84233d5ba2558e7340c52aa4b75dca7666f4335bf0f50127fc8027ce3145df287f3e2210def6e895efd6015e1caa3049c4d680c2a32eba2e1ea713b52c86a1fed66905ce2b4dd903e0742741e70e4c1e1ad8e76c63ea79979f918e3c383eaa65b27a5b9b3084c81ca49f5841535b0cb361fd291ab02e0a9c10cbd1d64638fb5d1cfacb6f4c9d7940e08e084203057077d9b8f6fae8b7ef8b35a346a8f113be2416d1b41e2e5a7ee978cd8c60ea7654c004ad97fd2f904e330ef7fb76ca034343c32e6b121f50ae19644b7be84d27924bac098e283934ad74f28a118955f07a452e81ded2c0cf7087d90c4852e8fc799b1b840d040a6bb6736d14a4ec1c18f894d13e51ae76e90d5be2ba052ba7824b47b716ee58b9eee235dc4867890da69c0d16586e06687df9dd80bce87bfa73958628422f4265eb9a8f8aaa480c6e85f70ea68d37fb8ec7f1dccc78de3e6ba74b1b130540c90e61dabc7a99f2610147fa45910b74455959b115394ad9fc9af8c5eb9cde27fd1ffdf16966caca449d0bb3f32e244e3de1942558fb3b0f52d9efdf0736a9776145129a675a55531d5335ae09721e9a88a4bbe930a8c21c95744f43abd4ed00c6637f70f3059fad761a67ecc6d04f0b01f3c45e05cd56a58737897b012c2de1eaf12ccc42ff16c40a3dbb11922d4b4d506810bb2a38a14c6799ff297669e22d657c88110857619e9cf20aa8d82cd6c205e7c1f666d3954a5f5149d57aaaaa55d3d77e91c1915b98c6f217ec11790a4fcdc0d0ae53a54cfe4f95283ce4a5c3c7cf9e8e8cb40b13d06257b90eda38baba797e3eff6bf7c9048cc1283caa49027549b92826ecad38ff56d53c51b4165d78b5dbcd483cc3622597288e1ce496b618a643fb899bdd540c9bd52fd35fefcfe78499859d9e25eac939bc0e233696193cea2c2ffea222b1684f1acf1452d8853d6be9ea5e26b9b3d1894dd5d613141af6c570723c54f063c84eeece49b1d56304a775ccc40e120884bcecfbfce2670b02cb85bc75975359b81b885a3113cfb0bc98f92b3a4d357f1c6f6122d272ea7ec700f1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title>STOffer-Recall</title>
    <url>/2020/02/26/20200226-offer/</url>
    <content><![CDATA[<h3 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="(1)矩阵中的路径"></a>(1)矩阵中的路径</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如<br><img src="/images/20200226offer/111.png"><br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean hasPath(char[] matrix, int rows, int cols, char[] str)</span><br><span class="line">    &#123;</span><br><span class="line">        boolean[] flag = new boolean[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;rows; i++)</span><br><span class="line">            <span class="keyword">for</span>(int j=0; j&lt;cols; j++)</span><br><span class="line">                <span class="keyword">if</span>(Judge(matrix,rows,cols,i,j,str,0,flag))</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean Judge(char[] matrix,int rows,int cols,int i,int j,char[] str,int k,boolean[] flag)&#123;</span><br><span class="line">        int index = i*cols+j;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;0 || i&gt;=rows || j&lt;0 || j&gt;=cols || matrix[index]!=str[k] || flag[index]==<span class="literal">true</span>)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length-1)</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        flag[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Judge(matrix,rows,cols,i+1,j,str,k+1,flag)</span><br><span class="line">           || Judge(matrix,rows,cols,i-1,j,str,k+1,flag)</span><br><span class="line">           || Judge(matrix,rows,cols,i,j+1,str,k+1,flag)</span><br><span class="line">           || Judge(matrix,rows,cols,i,j-1,str,k+1,flag)</span><br><span class="line">        )</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        flag[index] = <span class="literal">false</span>;//递归树收束，要做还原操作！</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结"><a href="#思路-总结" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>链接：<a href="https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?f=discussion">https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?f=discussion</a><br>来源：牛客网</p>
<p>回溯<br>基本思想：<br>0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次<br>1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge<br>2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组<br>3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通<br>4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的<br>5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。<br>6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</p>
<h3 id="2-机器人的运动范围"><a href="#2-机器人的运动范围" class="headerlink" title="(2)机器人的运动范围"></a>(2)机器人的运动范围</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？</p>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int movingCount(int threshold, int rows, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    boolean[][] flag = new boolean[rows][cols];</span><br><span class="line">    <span class="built_in">return</span> Count(threshold,rows,cols,0,0,flag);</span><br><span class="line">&#125;</span><br><span class="line">public int Count(int threshold,int rows,int cols,int x,int y,boolean[][] flag)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;0||x&gt;=rows||y&lt;0||y&gt;=cols||flag[x][y]==<span class="literal">true</span>||Sum(x)+Sum(y)&gt;threshold)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    flag[x][y]=<span class="literal">true</span>; //记录当前位置</span><br><span class="line">    <span class="built_in">return</span> 1+Count(threshold,rows,cols,x+1,y,flag)+Count(threshold,rows,cols,x,y+1,flag);</span><br><span class="line">&#125;</span><br><span class="line">public int Sum(int n)&#123;</span><br><span class="line">    int <span class="built_in">sum</span> = 0;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;0)&#123;</span><br><span class="line">        <span class="built_in">sum</span>+=n%10;</span><br><span class="line">        n = n/10;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-1"><a href="#思路-总结-1" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p><strong>一定要记得写记录数组，不然无限递归</strong><br>tips：注意与上题区别，是否需要做记录数组flag的回退操作。</p>
<h3 id="3-剪绳子"><a href="#3-剪绳子" class="headerlink" title="(3)剪绳子"></a>(3)剪绳子</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h4 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int cutRope(int target) &#123;</span><br><span class="line">    // n&lt;=3的情况，m&gt;1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,</span><br><span class="line">    <span class="keyword">if</span>(target==1 || target==2)</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    <span class="keyword">if</span>(target == 3)</span><br><span class="line">        <span class="built_in">return</span> 2;</span><br><span class="line">    int[] dp = new int[target+1];</span><br><span class="line">        /*</span><br><span class="line">    下面3行是n&gt;=4的情况，跟n&lt;=3不同，4可以分很多段，比如分成1、3，</span><br><span class="line">    这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span><br><span class="line">        */</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    dp[2] = 2;</span><br><span class="line">    dp[3] = 3;</span><br><span class="line">    int res = 0;//记录最大值</span><br><span class="line">    <span class="keyword">for</span>(int i=4;i&lt;dp.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=1; j&lt;=i/2; j++)&#123;</span><br><span class="line">            res = Math.max(res,dp[j]*dp[i-j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int cutRope(int target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(target==2 || target==3)</span><br><span class="line">        <span class="built_in">return</span> target-1;</span><br><span class="line">    int res = 1;</span><br><span class="line">    <span class="keyword">while</span>(target &gt; 4)&#123;</span><br><span class="line">        target-=3;</span><br><span class="line">        res*=3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res*target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路-总结-2"><a href="#思路-总结-2" class="headerlink" title="思路&amp;&amp;总结"></a>思路&amp;&amp;总结</h4><p>方法一动态规划。<br>方法二数学运算。<br>本体重点在于3这个点，小于等于3的数分段乘积都不如本身长，大于3的数分段乘积就要大于等于本身。</p>
]]></content>
      <categories>
        <category>STOffer</category>
      </categories>
      <tags>
        <tag>algorithm-recall</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树-lc96 &amp; lc95</title>
    <url>/2020/03/03/20200303-lc96/</url>
    <content><![CDATA[<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</p>
<p>   1         3     3      2      1<br>    \       &#x2F;     &#x2F;      &#x2F; \      <br>     3     2     1      1   3      2<br>    &#x2F;     &#x2F;       \                 <br>   2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees">https://leetcode-cn.com/problems/unique-binary-search-trees</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int numTrees(int n) &#123;</span><br><span class="line">    int[] dp = new int[n+1];</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    <span class="keyword">for</span>(int i=2; i&lt;dp.length; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=1; j&lt;=i; j++)&#123;</span><br><span class="line">            dp[i] += dp[j-1]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">return</span> dp[dp.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def numTrees(self, n: int) -&gt; int:</span><br><span class="line">    dp = [0]*(n+1)</span><br><span class="line">    dp[0], dp[1] = 1, 1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(2,n+1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(1,i+1):</span><br><span class="line">            dp[i] = dp[i] + dp[i-j]*dp[j-1]</span><br><span class="line">    <span class="built_in">return</span> dp[-1]</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>lc中等题，动态规划</p>
<p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数</p>
<p>即有:G(n) &#x3D; f(1) + f(2) + f(3) + f(4) + … + f(n)</p>
<p>n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,…,i-1]，右子树节点个数为[i+1,i+2,…n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) &#x3D; G(i-1)*G(n-i),</p>
<p>上面两式可得:G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p>示例:</p>
<p>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<p>   1         3     3      2      1<br>    \       &#x2F;     &#x2F;      &#x2F; \      <br>     3     2     1      1   3      2<br>    &#x2F;     &#x2F;       \                 <br>   2     1         2                 3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii">https://leetcode-cn.com/problems/unique-binary-search-trees-ii</a></p>
<h3 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public List&lt;TreeNode&gt; generateTrees(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; 1) <span class="built_in">return</span> new ArrayList();</span><br><span class="line">    List&lt;TreeNode&gt; res = Run(1,n);</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;TreeNode&gt; Run(int start,int end)&#123;</span><br><span class="line">    List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        res.add(null);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=start; i&lt;=end; i++)&#123;</span><br><span class="line">        List&lt;TreeNode&gt; llist = Run(start,i-1);</span><br><span class="line">        List&lt;TreeNode&gt; rlist = Run(i+1,end);</span><br><span class="line">        <span class="keyword">for</span>(TreeNode l:llist)</span><br><span class="line">            <span class="keyword">for</span>(TreeNode r:rlist)&#123;</span><br><span class="line">                TreeNode node = new TreeNode(i);</span><br><span class="line">                node.left = l;</span><br><span class="line">                node.right = r;</span><br><span class="line">                res.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3-1"><a href="#python3-1" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def generateTrees(self, n: int) -&gt; List[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> n &lt; 1:</span><br><span class="line">        <span class="built_in">return</span> []</span><br><span class="line">    res = self.Run(1,n)</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line"></span><br><span class="line">def Run(self, start, end) -&gt; List[TreeNode]:</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="built_in">return</span> [None]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,end+1):</span><br><span class="line">        llist = self.Run(start,i-1)</span><br><span class="line">        rlist = self.Run(i+1,end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> llist:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rlist:</span><br><span class="line">                node = TreeNode(i)</span><br><span class="line">                node.left, node.right = l, r</span><br><span class="line">                res.append(node)</span><br><span class="line">    <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路-1"><a href="#总结-思路-1" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>lc中等题，动态规划<br>遍历1～n，每次将遍历到的数作为根节点，计为i</p>
<p>递归返回左右子树，分别为0～i-1以及i+1～n</p>
<p>由于1～n本身就是升序序列，按照这种方式也能满足二叉搜索树的性质。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形最小路径和-lc120</title>
    <url>/2020/03/19/20200319-lc120/</url>
    <content><![CDATA[<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自上而下</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">    <span class="keyword">if</span>(triangle.size()==1)</span><br><span class="line">        <span class="built_in">return</span> triangle.get(0).get(0);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    res.add(triangle.get(0));</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;triangle.size();i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int j=0; j&lt;triangle.get(i).size(); j++)&#123;</span><br><span class="line">            int tmin = 0;</span><br><span class="line">            <span class="keyword">if</span>(j==0)</span><br><span class="line">                tmin = triangle.get(i).get(j)+res.get(i-1).get(j);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==triangle.get(i).size()-1)</span><br><span class="line">                tmin = triangle.get(i).get(j)+res.get(i-1).get(j-1);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmin = Math.min(triangle.get(i).get(j)+res.get(i-1).get(j),triangle.get(i).get(j)+res.get(i-1).get(j-1));</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(tmin);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    int len = res.size();</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;res.get(len-1).size();i++)</span><br><span class="line">        min = Math.min(min,res.get(len-1).get(i));</span><br><span class="line">    <span class="built_in">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//自下而上</span><br><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">    <span class="keyword">if</span>(triangle.size() == 1)</span><br><span class="line">        <span class="built_in">return</span> triangle.get(0).get(0);</span><br><span class="line">    <span class="keyword">for</span>(int i=triangle.size()-2;i&gt;=0;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">            int a = triangle.get(i).get(j)+triangle.get(i+1).get(j);</span><br><span class="line">            int b = triangle.get(i).get(j)+triangle.get(i+1).get(j+1);</span><br><span class="line">            triangle.get(i).<span class="built_in">set</span>(j,Math.min(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> triangle.get(0).get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:</span><br><span class="line">        <span class="keyword">if</span> len(triangle)==1:</span><br><span class="line">            <span class="built_in">return</span> triangle[0][0]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)-2,-1,-1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(0,len(triangle[i])):</span><br><span class="line">                triangle[i][j] = min(triangle[i][j]+triangle[i+1][j],triangle[i][j]+triangle[i+1][j+1])</span><br><span class="line">        <span class="built_in">return</span> triangle[0][0]</span><br></pre></td></tr></table></figure>
<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>自上而下或者自下而上遍历三角形，每次保留本节点和上一层节点相加的最小值做动态规划。<br>很显然自下而上的方式可以大大简化判断次数以及边界判断，更适合本题数据结构。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>单词拆分-lc139</title>
    <url>/2020/03/26/20200326-lc139/</url>
    <content><![CDATA[<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-break">https://leetcode-cn.com/problems/word-break</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    boolean[] dp = new boolean[n+1];</span><br><span class="line">    //dp[i]==<span class="literal">true</span> -&gt; s中0～i-1的子串可以被wordDict拆分</span><br><span class="line">    dp[0] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)))</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:</span><br><span class="line">    n, dp = len(s), [False]*(len(s)+1)</span><br><span class="line">    dp[0] = True</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1,n+1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(0,i):</span><br><span class="line">            <span class="keyword">if</span> dp[j] and s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                dp[i] = True</span><br><span class="line">    <span class="built_in">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>动态规划解题，dp[s.length()+1]<br>思路：dp[i]&#x3D;&#x3D;true -&gt; s中0～i-1的子串可以被wordDict拆分<br>对于每一个i，都用j遍历0～i，确保每一份0～j+j～i都被检索过即可。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子数组-lc152</title>
    <url>/2020/03/28/20200328-lc152/</url>
    <content><![CDATA[<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</p>
<p>示例 1:<br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>示例 2:<br>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int maxProduct(int[] nums) &#123;</span><br><span class="line">    //保存一个最大值和一个最小值，碰到负数时最小值将变成最大值</span><br><span class="line">    int max=nums[0], tmax=1, tmin=1;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; 0)&#123;</span><br><span class="line">            int tmp = tmax;</span><br><span class="line">            tmax = tmin;</span><br><span class="line">            tmin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmax = Math.max(tmax*nums[i],nums[i]);</span><br><span class="line">        tmin = Math.min(tmin*nums[i],nums[i]);</span><br><span class="line">        max = Math.max(max,tmax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def maxProduct(self, nums: List[int]) -&gt; int:</span><br><span class="line">    m, m1, m2 = nums[0], 1, 1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; 0):</span><br><span class="line">            m1, m2 = m2, m1</span><br><span class="line">        m1 = max(m1*nums[i],nums[i])</span><br><span class="line">        m2 = min(m2*nums[i],nums[i])</span><br><span class="line">        m = max(m1,m)</span><br><span class="line">    <span class="built_in">return</span> m</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>动态规划思路：遍历数组 -&gt; 遍历指针i，保存 以每个i为数组最后节点的子数组 的最大乘积。<br>乘法的问题在于负负得正可能出现本来是最小的乘积由于乘上一个负数而成为最大乘积的情况。<br>因此在过程中需要保存遍历过程中的最大值和最小值，并且每次都取最大值。</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形-lc221</title>
    <url>/2020/03/30/20200330-lc221/</url>
    <content><![CDATA[<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<p>输入: </p>
<p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>
<p>输出: 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-square">https://leetcode-cn.com/problems/maximal-square</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int maximalSquare(char[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==0 || matrix[0].length==0)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    int max = 0;</span><br><span class="line">    int[][] dp = new int[matrix.length][matrix[0].length];</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;matrix[0].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==0 || j==0)</span><br><span class="line">                dp[i][j] = matrix[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                dp[i][j] = 1+Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));</span><br><span class="line">            max = Math.max(max,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> max*max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def maximalSquare(self, matrix: List[List[str]]) -&gt; int:</span><br><span class="line">    <span class="keyword">if</span> len(matrix) == 0:</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    res, dp = 0, [[0]*len(matrix[0]) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp[0])):</span><br><span class="line">            <span class="keyword">if</span> i==0 or j==0:</span><br><span class="line">                dp[i][j] = int(matrix[i][j])</span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j]==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]))</span><br><span class="line">            res = max(res,dp[i][j])</span><br><span class="line">    <span class="built_in">return</span> res*res</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>动态规划思路：dp数组的每一位表示以这一位为右下角的矩阵的最大边长<br>递推公式：dp[i][j] &#x3D; 1 + min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]))</p>
<h3 id="细节踩坑"><a href="#细节踩坑" class="headerlink" title="细节踩坑"></a>细节踩坑</h3><p>python3中初始化二维list时如果使用 [[0]*5] * 5，那么内部的5个list其实是引用的同一个list对象，因此如果操作list[0][0]&#x3D;1，那么list[1][0],[2][0],[3][0]….都会同步修改，因为是一个引用。</p>
<p>解决方法是使用如下的初始化方法<br>[[0]*5 for _ in range(5)]</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap(堆)总结</title>
    <url>/2020/04/18/20200418/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在计算机专业课程数据结构中我们是学习过heap这一种数据结构的，但是使用频率不如链表数组树这样的数据结构。在最近春招的一次面试中我在手撕算法优化的环节没能敏感的利用heap来解决问题想出最优解，虽然面试时基础知识回答的比较不错但是还是因为算法流程表现不佳被淘汰，那么痛定思痛后决定补上关于heap的知识，希望它能成为我灵活运用的工具去解决问题。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆是一种抽象的数据结构概念，堆通常是一个可以被看做一棵完全二叉树的数组对象。<br><strong>堆总是满足下列性质</strong></p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。<br>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</li>
</ul>
<h3 id="java中的priorityQueue"><a href="#java中的priorityQueue" class="headerlink" title="java中的priorityQueue"></a>java中的priorityQueue</h3><p>优先队列是堆的一个经典的实际应用，java中也有使用堆原理实现的优先队列priorityQueue。<br>其中堆的插入、调整、平衡操作都体现在priorityQueue的增删改等操作中。<br>这里我写下基本的使用demo，具体细节附上priorityQueue的文档介绍：<br><strong><a href="https://docs.oracle.com/javase/1.5.0/docs/api/java/util/PriorityQueue.html">https://docs.oracle.com/javase/1.5.0/docs/api/java/util/PriorityQueue.html</a></strong></p>
<p><strong>demo：topK问题&#x2F;P90问题</strong><br>大数据中的经典应用，找出大数据中topk的数据或者第90%大的那个数，可以使用堆解决，达到O(nlogm)的时间复杂度（m为堆大小）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] num = new int[100];</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=100;i++)</span><br><span class="line">        num[i-1] = i;</span><br><span class="line">    System.out.println(getPNine(num));</span><br><span class="line">&#125;</span><br><span class="line">static int getPNine(int[] num)&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;num.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.size() &lt; num.length/10)&#123;</span><br><span class="line">            heap.add(num[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heap.peek() &lt; num[i])&#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.add(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> heap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>java中的priorityQueue默认使用的是小顶堆，我们可以利用传入比较器参数来使用大顶堆：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2-o1);</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是经典排序算法之一，是通过数组构建堆，并利用堆的特性进行排序的。<br>java实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建堆</span><br><span class="line">static void heapSort(int[] arr) &#123;</span><br><span class="line">    //创建堆</span><br><span class="line">    <span class="keyword">for</span> (int i = (arr.length - 1) / 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    <span class="keyword">for</span> (int i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        //将堆顶元素与末尾元素进行交换</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[0];</span><br><span class="line">        arr[0] = temp;</span><br><span class="line"></span><br><span class="line">        //重新对堆进行调整</span><br><span class="line">        adjustHeap(arr, 0, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调整堆</span><br><span class="line">static void adjustHeap(int[] arr, int parent, int length) &#123;</span><br><span class="line">    //将temp作为父节点</span><br><span class="line">    int temp = arr[parent];</span><br><span class="line">    //左孩子</span><br><span class="line">    int lChild = 2 * parent + 1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lChild &lt; length) &#123;</span><br><span class="line">        //右孩子</span><br><span class="line">        int rChild = lChild + 1;</span><br><span class="line">        // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span><br><span class="line">        <span class="keyword">if</span> (rChild &lt; length &amp;&amp; arr[lChild] &lt; arr[rChild]) &#123;</span><br><span class="line">            lChild++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果父结点的值已经大于孩子结点的值，则直接结束</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= arr[lChild]) &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 把孩子结点的值赋给父结点</span><br><span class="line">        arr[parent] = arr[lChild];</span><br><span class="line"></span><br><span class="line">        //选取孩子结点的左孩子结点,继续向下筛选</span><br><span class="line">        parent = lChild;</span><br><span class="line">        lChild = 2 * lChild + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数-lc279</title>
    <url>/2020/04/20/20200420-lc279/</url>
    <content><![CDATA[<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n &#x3D; 12<br>输出: 3<br>解释: 12 &#x3D; 4 + 4 + 4.<br>示例 2:</p>
<p>输入: n &#x3D; 13<br>输出: 2<br>解释: 13 &#x3D; 4 + 9.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/perfect-squares">https://leetcode-cn.com/problems/perfect-squares</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int numSquares(int n) &#123;</span><br><span class="line">    //dp数组</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    </span><br><span class="line">    //辅助数组，元素为小于目标的完全平方数</span><br><span class="line">    int max = (int)Math.sqrt(n) + 1;</span><br><span class="line">    int[] helper = new int[max];</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; max; i++)</span><br><span class="line">        helper[i] = i * i;</span><br><span class="line">    </span><br><span class="line">    //dp过程</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; dp.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = 1; j &lt; max; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; helper[j])</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - helper[j]] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def numSquares(n: int) -&gt; int:</span><br><span class="line">        dp = [0] + [n]*n</span><br><span class="line">        square_max = int(n**0.5)</span><br><span class="line">        helper = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(square_max+1)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1,n+1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(1,square_max+1):</span><br><span class="line">                <span class="keyword">if</span> i &lt; helper[j]:</span><br><span class="line">                    <span class="built_in">continue</span></span><br><span class="line">                dp[i] = min(dp[i], dp[i - helper[j]] + 1)</span><br><span class="line">        <span class="built_in">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="总结-思路"><a href="#总结-思路" class="headerlink" title="总结&amp;&amp;思路"></a>总结&amp;&amp;思路</h3><p>如果使用暴力法会超时并且难以解决，需要使用动态规划思想<br>动态规划思路：dp数组的第i位表示目标数字i需要的最大完全平方数。<br>我们需要一个完全平方数的辅助数组，其中存放可能会用到的完全平方数，数组大小为sqrt(n)<br>原因：如果n &#x3D; 12，那么他用到的最大完全平方数应该是3*3 &#x3D; 9<br>递推公式：dp[i] &#x3D; min(dp[i], dp[i - helper[j]] + 1)</p>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列-lc300</title>
    <url>/2020/04/26/20200426-lc300/</url>
    <content><![CDATA[<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
<h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p>dp数组的每一位i代表以i为最后元素时，最长上升子序列的长度。<br>对于dp[i],我们已经求得了dp[0 ~ i-1]，j遍历dp[0 ~ i-1]递推公式为：<br><strong>dp[i] &#x3D; max(dp[j])+1</strong></p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == 0 || nums == null)</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    int res = 1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        int tmax = 0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                tmax = Math.max(tmax, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = tmax + 1;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">    <span class="keyword">if</span> nums is None or len(nums) == 0:</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    res, dp = 1, [1] + [0]*(len(nums)-1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(nums)):</span><br><span class="line">        tmax = 0;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(0,i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                tmax = max(tmax, dp[j])</span><br><span class="line">        dp[i] = tmax + 1</span><br><span class="line">        res = max(res, dp[i])</span><br><span class="line">    <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>maven install debug</title>
    <url>/2020/05/21/20200521-mvn/</url>
    <content><![CDATA[<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>实习仍在远程入职期间，今天石冲同学请假了，也没有什么任务可以做，我就在想给工作机的macbook配置一下java，maven之类的环境，毕竟环境配好要是用得上可以为以后的工作节省一些时间。和我自己的机器不同，本次我全部使用了homebrew的安装方式，尽量提高效率和管理能力，但是在配置maven的时候碰到了一个问题困扰了一天多，后来发现依旧是细节问题。</p>
<h3 id="bug-details-and-solution"><a href="#bug-details-and-solution" class="headerlink" title="bug details and solution"></a>bug details and solution</h3><p>首先正常使用brew安装maven</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install maven</span><br></pre></td></tr></table></figure>
<p>但是在使用验证语句进行验证安装时</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br><span class="line"></span><br><span class="line">-------result--------</span><br><span class="line"></span><br><span class="line">The JAVA_HOME environment variable is not defined correctly</span><br><span class="line">This environment variable is needed to run this program</span><br><span class="line">NB: JAVA_HOME should point to a JDK not a JRE</span><br></pre></td></tr></table></figure>

<p>即maven识别的<strong>JAVA_HOME</strong>环境变量没能正确指向JDK。<br>于是我查看<strong>JAVA_HOME</strong>的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br><span class="line"></span><br><span class="line">-------result--------</span><br><span class="line"></span><br><span class="line">/Library/Java/JavaVirtualMachinesjdk1.8.0_212.jdk/Contents/Home</span><br><span class="line">//这里有个坑，shell显示的路径JavaVirtualMachines和jdk1.8.0_212.jdk之间少了一个/，卡了我好久</span><br></pre></td></tr></table></figure>
<p>果然<strong>JAVA_HOME</strong>在java配置环境变量时指向了Home目录，而maven只希望指向jdk即可。<br>因此前往修改maven的默认<strong>JAVA_HOME</strong>路径：<br>打开  ‎⁨Macintosh HD⁩&#x2F;⁨usr⁩&#x2F;local⁩&#x2F;Cellar⁩&#x2F;maven⁩&#x2F;3.6.3_1⁩&#x2F;libexec⁩&#x2F;⁨bin⁩&#x2F;mvn (个人路径)<br>【注意不是  ‎⁨Macintosh HD⁩&#x2F;⁨usr⁩&#x2F;local⁩&#x2F;Cellar⁩&#x2F;maven⁩&#x2F;3.6.3_1⁩&#x2F;⁨bin⁩&#x2F;mvn】</p>
<p>添加如下语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$mingw</span> ; <span class="keyword">then</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">JAVA_HOME=`/Library/Java/JavaVirtualMachines/jdk1.8.0_212.jdk`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$JAVA_HOME</span>&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>【注意shell中字符串要用&#96;&#96;括起来，而不是单引号’’或者双引号””】</p>
<p>保存退出后重新验证：mvn -v 即可</p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式-designPattern</title>
    <url>/2020/06/20/20200620-designPattern/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>早些时候在实习摸鱼期间回顾了下设计模式，刚好也有tt分享，结合scala语言的特性和优势对比java做一些总结，这是早就写好的一部分。下一部分等有空了再总结好搬（鸽）上来。</p>
<h3 id="桥接模式——java-scala"><a href="#桥接模式——java-scala" class="headerlink" title="桥接模式——java&amp;scala"></a>桥接模式——java&amp;scala</h3><p>定义：桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><h5 id="demo场景【来自于知乎https-zhuanlan-zhihu-com-p-58903776】"><a href="#demo场景【来自于知乎https-zhuanlan-zhihu-com-p-58903776】" class="headerlink" title="demo场景【来自于知乎https://zhuanlan.zhihu.com/p/58903776】"></a>demo场景【来自于知乎<a href="https://zhuanlan.zhihu.com/p/58903776%E3%80%91">https://zhuanlan.zhihu.com/p/58903776】</a></h5><p>星巴克咖啡容量有中杯、大杯、超大杯（罗老师别这样，罗老师！）。口味上可以选择不加糖、加糖。</p>
<h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>抽象化(Abstraction)角色：demo场景下即使用抽象类抽象化“咖啡”对象，方便对于中、大、超大这样的具体容量咖啡的拓展。并且持有一个“口味”的抽象引用，方便后续对口味的拓展和具体实现。<br>修正抽象化(RefinedAbstraction)角色：拓展抽象化的角色，即使用新的refined抽象类继承“咖啡”，改变和修正父类对抽象化的定义。<br>实现化(Implementor)角色：对“咖啡”持有的“口味”这一抽象引用接口进行抽象化。抽象只描述最基本的抽象行为，实现化时才具体到细节（接口最小化原则）<br>具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。</p>
<h5 id="demo代码实现"><a href="#demo代码实现" class="headerlink" title="demo代码实现"></a>demo代码实现</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//抽象化Abstraction</span><br><span class="line">public abstract class Coffee &#123;</span><br><span class="line">    protected ICoffeeAdditives additives;</span><br><span class="line">    public Coffee(ICoffeeAdditives additives)&#123;</span><br><span class="line">        this.additives=additives;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void orderCoffee(int count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//RefinedAbstraction</span><br><span class="line">public abstract class RefinedCoffee extends Coffee &#123;</span><br><span class="line">    public RefinedCoffee(ICoffeeAdditives additives) &#123;</span><br><span class="line">        super(additives);</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">checkQuality</span></span>()&#123;</span><br><span class="line">        Random ran=new Random();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s 添加%s&quot;</span>,additives.getClass().getSimpleName(),ran.nextBoolean()?<span class="string">&quot;太多&quot;</span>:<span class="string">&quot;正常&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ICoffeeAdditives &#123;</span><br><span class="line">    void addSomething();</span><br><span class="line">&#125;</span><br><span class="line">//加奶</span><br><span class="line">public class Milk implements ICoffeeAdditives &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">addSomething</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加奶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//加糖</span><br><span class="line">public class Sugar implements ICoffeeAdditives &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">addSomething</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //点两杯加奶的大杯咖啡</span><br><span class="line">        RefinedCoffee largeWithMilk=new LargeCoffee(new Milk());</span><br><span class="line">        largeWithMilk.orderCoffee(2);</span><br><span class="line">        largeWithMilk.checkQuality();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Java主要通过一个抽象类持有一个抽象接口的方式来实现桥接模式下对于抽象分离的实现，这个接口的持有就是搭起两个抽象部分的“桥”。通过这样的设计，两个部分可以独立的进行拓展，实现，不影响最终的组合使用，非常灵活。</p>
<h4 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h4><h5 id="demo场景【来自于石冲的技术分享】"><a href="#demo场景【来自于石冲的技术分享】" class="headerlink" title="demo场景【来自于石冲的技术分享】"></a>demo场景【来自于石冲的技术分享】</h5><p>Circle类拥有draw的方法，但是draw可以进行拓展：greenDraw、redDraw……</p>
<h5 id="demo代码实现-1"><a href="#demo代码实现-1" class="headerlink" title="demo代码实现"></a>demo代码实现</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Circle(x: Int, y: Int, radius: Int) extends DrawApi &#123;</span><br><span class="line">  def draw() = &#123;</span><br><span class="line">    drawCircle(x, y, radius)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override protected def drawCircle(x: Int, y: Int, radius: Int): Unit = &#123;</span><br><span class="line">    println(s<span class="string">&quot;Drawing circle [x: <span class="variable">$x</span>, y: <span class="variable">$y</span>, radius: <span class="variable">$radius</span>]&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait DrawApi &#123;</span><br><span class="line">  protected def drawCircle(x: Int, y: Int, radius: Int): Unit</span><br><span class="line">&#125;</span><br><span class="line">trait DrawGreen extends DrawApi &#123;</span><br><span class="line">  override protected def drawCircle(x: Int, y: Int, radius: Int): Unit = &#123;</span><br><span class="line">    println(s<span class="string">&quot;Drawing circle [color: Green, x: <span class="variable">$x</span>, y: <span class="variable">$y</span>, radius: <span class="variable">$radius</span>]&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait DrawRed extends DrawApi &#123;</span><br><span class="line">  override protected def drawCircle(x: Int, y: Int, radius: Int): Unit = &#123;</span><br><span class="line">    println(s<span class="string">&quot;Drawing circle [color: Red, x: <span class="variable">$x</span>, y: <span class="variable">$y</span>, radius: <span class="variable">$radius</span>]&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var circle = new Circle(1,2,10)</span><br><span class="line">circle.draw()</span><br><span class="line">var greenCircle = new Circle(1,2,10) with DrawGreen</span><br><span class="line">greenCircle.draw()</span><br><span class="line">var redCircle = new Circle(1,2,10) with DrawRed</span><br><span class="line">redCircle.draw()</span><br></pre></td></tr></table></figure>

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>相比于Java通过一个抽象类持有一个抽象的接口的方式来“桥”接两种抽象特征，scala则使用抽象类+Mixin trait的方式实现，调用时的形式是创建circle对象时直接进行with关联具体的draw来“桥”接两种抽象形式，调用时同样简洁，并且在实现时的代码量要略小于java，得益于Mixin风格能够让trait进行动态拓展，scala实现起来更加优雅一些。</p>
<p>Scala的demo中，石冲省略了对Circle的抽象化再拓展实现，可能是实现方式与java是一致的并没有显示出scala的特点，也可能是做技术分享的时间限制关系没有多写。不过不妨碍对scala Mixin风格的学习。</p>
]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Some Daily Words</title>
    <url>/2026/02/22/20260222-life/</url>
    <content><![CDATA[<p>Long time no see! </p>
<p>It’s been quite a long time since I last updated my blog. Looking back now, I updated a lot of algorithm problem solutions around 2020. I must have been busy preparing for job hunting back then. I was really diligent in the past! Unfortunately, I’ve become a bit lazy for quite a long time. (Damn it!)</p>
<p>Over the past five years or so, I’ve worked for more than four years and also gotten married. I’ve grown from a naive and clueless student into an immature adult approaching thirty. My procrastination has gotten worse, and my motivation to study has become really poor (you can tell from my update frequency, darn it!).</p>
<p>Today I dug out my old laptop from my school days and migrated my old blog files to my new computer. Since Hexo is a locally stored static blog, it’s really a bit troublesome to switch computers after not updating for so long. The Node version has even been upgraded from 8 to 24 (time really doesn’t spare anyone). I spent two hours fixing tons of compatibility issues and took a few detours along the way &#x3D; &#x3D;!<br>If it were the younger me, I would’ve given up out of frustration long ago. But now I can control my own patience. It seems I have grown after all, haha.<br>So I hope I can push myself to study and summarize knowledge more often in the days ahead. After all, you’re never too old to learn.</p>
<p>Looking at the time, it’s already past eleven o’clock. If it were the old me, I would probably have opened a can of happy water and played games joyfully. But now, I should get ready for bed.<br>Lastly, I wish myself and everyone a happy New Year, filled with health and peace.</p>
<p><img src="/images/20260222.jpg" alt="I have a lovely wife haha."></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
