<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Diameter of Binary Tree lc543]]></title>
    <url>%2F2019%2F09%2F07%2F20190907-lc543%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/diameter-of-binary-tree python3–递归123456789101112131415161718192021222324= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: res = 0 def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: if root == None: return 0 self.depth(root) return self.res def depth(self, root: TreeNode): if root == None: return 0; l = self.depth(root.left) r = self.depth(root.right) if l + r &gt; self.res: self.res = l + r return max(l, r) + 1 java–递归12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res=0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; depth(root); return res; &#125; public int depth(TreeNode root)&#123; if(root == null) return 0; int r = depth(root.right); int l = depth(root.left); if(r + l &gt; res) res = r + l; return Math.max(r, l)+1; &#125;&#125; 总结本题是一道leetcode简单难度的题，思路比较明确那就是利用递归的思想每次对于一个节点都要获取它的左右子树的最大深度然后暂存这两个值的和，并且每次返回的是两者中的较大的值供上层递归使用，这题比较奇特的地方在于它虽然利用递归但是并不能靠递归的返回值累加来获得最终的结果，需要创建一个全局变量并且在整个递归的过程中维护这个全局变量的值，它才是我们最终的res，所以我抱着传统的递归思路去做这个题的时候总感觉思路很清晰却总有点问题，最后看了评论区大佬的思路才恍然大悟，所以说思路不能固化，即使是递归也有不同的用法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 teaching experience]]></title>
    <url>%2F2019%2F08%2F30%2F20190830%2F</url>
    <content type="text"><![CDATA[前言由于这周回了一条天国的微信消息被老师派遣去干苦力教一名高中生python3编程，并且自己的python3也就是个半吊子于是乎一周都沉浸在现学现卖赶制第二天ppt的劳累生活之中，算是尝试了一把新人老师的心酸生活。 但是，另一个角度来说我也又过了一遍python3的基础语法，可以说收获还是有的。由于本科是c语言作为第一门编程语言学习语法，所以母语思维就是静态语言类型，后来学c++，java可以说由于同是静态语言差别并不大。而python是在大三的时候企业工程实践老师在介绍Jquery和Flask时提到让我们学，当时也没有系统的教我们，只是在用到的部分就去查这样的填补式学习，而这一周算是让我补上了以前缺失的基础部分知识。 安装与使用自己用的macos所以有自带python2.7，但是教学需要还是重新下载覆盖了python3.7，使用的是python3.7版本的anaconda，记得以前本科时使用opencv2踩过坑，当时傻白甜的下载了官网python并自己导入包，老师就说过可以用anaconda。如今才知道anaconda是个python开源版本&amp;包管理工具，如果可以回到从前我一定拍死自己= =。 下载anaconda就意味着python3.7和一些IDE都已经下载好了，配置一下环境变量即可覆盖2.7并使用，python环境变量配置比较简单就略过吧。值得一题的是Jupyter notebook这个IDE，作为新手的IDE来说确实不错，不需要适应新的客户端，网页端就可以用，基础功能也比较全面，非常时候新手学习使用。而且anaconda自带，也不需要另外下了。 动态语言python的优势作为我接触的第一个动态编程语言，python给我的第一感觉是不可思议的，相比之下java就显得严格且死板。 首先接触到的区别在于python对于基础类型的自动转换，使得我们不需要通过基础类型关键字去创建变量，并且可以批量赋值十分灵活。 12345678910===python3x, y=1, 1.2x, y='1', '1.2'===javaint x=1;float y=1.2char z='1'String x="1.2"//......wdnmd 其次python灵活丰富的方法以及运算符重载使得可操作性极其强大，你不仅可以用+号去拼接字符串，还可以去拼接list，set等，用-号去操作set等。而这些高级数据结构的重载在java中是没有的，你只能手动去实现。。。 python与java在看了一周python的基础语法后我发现作为一门OOP语言python与java其实在基础语法方面基本是一致的，只是形式不同，python使用冒号：以及严格的缩进区分方法体，类内容等，同时加不加分号；作为结束都是不影响的。而java使用大括号{}区分方法体和类的内部，并且严格的要求在变量定义和创建参数列表时使用基础类型关键字，并且每一条语句需要分号；结束。 当然除了格式的不同，它们在基础语法的部分也是有一定差别的第一、python中没有char类型的概念，全部使用string类型，也没有数组int[]的概念全部使用list。可以说更加简洁方便 第二、python中没有java中的这种常用for循环用法 123for(int i=0;i&lt;nums.length;i++)&#123; ......&#125; 取而代之的是配合range的for循环，两者功能一致，而且都非常好用 12for i in range(nums): ...... 第三、python的类变量区分为class variables 和 instance variables。而java中与之对应的是static关键字修饰的静态成员变量以及普通成员变量。两种语言的变量相互对应起来功能类似，但是又有细微的区别。 1234567891011===pythonclass Shark(): \# class variable type="fish" def __init__(self, name): \# instance variable self.name = names1=Shark("Lucy")s2=Shark("Lily")s1.type="food" 如果我执行以上的语句，如果是java的静态成员变量，那么s2的type属性会同步成”food”，但是在python中不会，python会认为s1并没有权限修改class variable因此在执行修改时将s1的type属性降级成instance variable从而成为s1专属的成员变量，而不会影响其他Shark对象的type属性。简单说来python拒绝类对象对类变量执行重新赋值“=”的操作，会导致变量类型的转换（我理解为权限的降级），但是以下的修改语句是被允许的 123456class Shark(): num=[1,2,3]s1=Shark()s2=Shark()s1.num.append(4) 可以理解为类对象可以修改但不能重新赋值类变量，这种行为比较奇特也是java中没有的，我暂时还不知道为什么python会有这样的特性。 总结这一周时间都贡献给了python，既没有新技术栈的学习，也没有踩坑解惑的经历，只是回顾了以前的知识并补ß上一些空白，最初的两天我是很不爽的，我觉得这完全是浪费时间，然而现在我觉得这还是有意义的，而且是我以前很少做的事，知识在回顾的时候可能学到更多，而且可以加深自己以前的理解。总的来说这一周不亏。马上后天研究生开学了，期待一个新的生活吧。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ+Mqtt enable publisher/subscriber]]></title>
    <url>%2F2019%2F08%2F17%2F20190817-tec%2F</url>
    <content type="text"><![CDATA[前言这周有空余时间于是补了一下上周的week4任务中的ActiveMQ使用，本来想下载apache apollo的，但是发现apache官网已经没有了apollo的下载提供，短暂的尝试寻找资源后放弃了，反正一脉相承，又是官网主推的，那么就用ActiveMQ代替学习吧。但是不得不说最新版本东西的可借鉴博客真的少的可怜，基本都是讲apollo的，我结合apollo类似部分以及啃官方文档总算是大概用起来了。 经历安装与启用本来还在官网下载了一下ActiveMQ的最新版本然后手动移动解压文件后来一拍脑袋，有homebrew不用的都是傻子，于是删掉后shell里一行装好，不得不说homebrew是真的香啊，不枉我上周踩了好久坑才装好。 1brew install activemq 安装好以后直接用activemq命令就可以开启和关闭服务 12activemq startactivemq stop 这里有一点，启动后官方文档说shell中会有启动的web页面端口号，但是我自己启动并没有发现有端口号提示，一开始是看网上的博主的默认端口号打开的网页端，后来知道activemq的文件家中/../conf文件夹中有activemq的所有配置文件，包括默认用户名密码，网页默认端口，各种连接方式端口等等，都可供修改。 启动服务后，打开网页url输入用户名密码就可以登陆服务端管理界面了里面有topic，queue创建管理以及连接上服务端的客户端的管理，已有订阅者的管理等等。 实现subscriber/publisher在上一步开启服务进入服务页面后，我还使用了两个客户端和它进行连接，分别是：1、mqttfx，之前学mqtt的时候下的，当时没用上现在用了，通过activemq提供的mqtt端口接入，填好mqttfx的信息后connect建立连接。就可以实现订阅topic和向topic publish信息。2、下载的activemq文件夹中有提供相应的简易客户端用于test，我使用了example文件夹下mqtt/websocket的客户端，就一个html页面，页面极度简单，填完连接信息connect后就一个输入框一个按钮一个显示框，像极了刚学C# winform时拖控件的我做出的第一个界面= =，不过这也算是有基本功能了，可以说是易用性极强。 两个客户端都连接上服务端后，就可以动手创建topic，订阅消息发布消息，查看mqtt这种中间件的运作模式了，动了手以后会让理论上的理解更上一层楼。 总结mqtt确实是提供了一个双向交互的中间消息队列服务，其中服务端只是做一个中转站，只要是连接上服务端的客户端，并且订阅了同一个topic，那么他们就可以通过服务端进行双向的交互，可以说非常方便。还记得以前企业工程实践课的老师让我们学socket的时候，说用socket就可以很快的实现类似qq这样的聊天软件功能，现在知道了mqtt这种中间件，看看都是封装tcp协议的东西，如果只是实现聊天的话mqtt这边用现成的客户端一行代码都不用敲= =。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project experience summary]]></title>
    <url>%2F2019%2F08%2F16%2F20190816-tec%2F</url>
    <content type="text"><![CDATA[前言暑假提前来到学校也跟着学长的开发任务做了些事，大概是一周前还做着开发任务，隔了一周配置本地项目又是不知所措，好多熟悉的bug又遗忘了怎么处理，关键是自己寻找问题解决方案的能力还很有待提高总是浪费很多时间才能解决，总是去问学长又太麻烦他，以后我会将每一段时间的项目经验总结在这里，方便回顾学习，温故而知新。 这次主要是springboot+springcloude+mybatis的果麦新风drift模块的开发，需要给订单order对应的快递单号express功能接口的实现，中间碰了很多坑。 踩坑经历1、本地与服务器的配置不同与冲突这一部分是每次git pull整合本地代码以后都要做的事，已经习惯了如何处理倒是没有花费太多的时间，首先检查eureka-server端的properties文件，写一个自己想用的端口号，并且做一些常规的处理 1234567#spring.profiles.active=test 这一行是服务端代码，用于选择需要的properties版本server.port=8080eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 然后检查需要开发的drift模块的properties文件 12345678910111213server.port=8000spring.application.name=drift-agenteureka.client.healthcheck=trueeureka.client.service-url.defaultZone=http://127.0.0.1:8080/eureka/mybatis.config-location=classpath:mybatis-config.xmlspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/gmair_drift?useLegacyDatetimeCode=false&amp;serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=shuge888 以及pom文件中的架包依赖，这主要是修改本地与服务端使用的不同版本的架包依赖，例如我们服务端中mysql的drive驱动版本是6.0.6，但是我本地的mysql版本较新需要使用新一些的drive驱动例如8.0.11否则本地运行会报错。 这里要着重说的是common模块中lombok版本不匹配问题影响了我很长时间，最后是麻烦学长才解决的，lombok是用于自动添加实体类get()/set()方法的工具，但是服务器上的java9版本的lombok版本却与我本地的java11冲突，导致maven重新生成target文件夹失败，进而导致mybatis的XML文件中引用枚举类型enum的handler失败，需要修改lombok架包版本才能解决这一系列的问题。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--这条语句是老版本lombok没有的，但是缺少这条语句又是不行的--&gt;&lt;/dependency&gt; Addition:我对maven的命令使用也不熟悉，常用命令还是要牢记的，例如清理maven后重新安装项目以及依赖的命令；maven打包命令 123mvn -U clean installmvn package 2、总体项目进度带来的对其他模块的依赖在一周前还可以本地运行的项目一周后就不行了，因为总的项目进度在向前，开发的模块可能加入了对其他开发者模块的依赖，例如我这次添加的wechat.properties以及sesame.properties。这两个配置文件缺失的话就无法运行项目，前者是微信模块，可以直接创建一个新的文件里面的内容部分留空也可以运行；后者则是alipay相关模块，里面需要内容，这一部分问学长要了一下填上也就解决了。 3、自己编程造成的bug这一部分我是没有想到的，由于昨天是12点前开始写到1点半写完的接口（别问我之前干嘛去了，我也不知道我的时间去哪儿了= =），在第二天提交后测试的时候发现两处致命的错误。。。（没错有一处还是拼写错误），这两处错误精妙的没有引起编译报错，又确实的造成了软件错误，因为这两处错误一处出在xml文件中的拼写错误，另一处是写Express实体类的时候忘记extend Entity基础类了导致实体缺了两个公共属性。 回想起来这是真的蠢，再次提醒自己编码一定要细致，尽量在自己精力充沛的时候进行开发任务，不然会出很多错。 新学到的东西java中的枚举类型enum早就知道有这么个东西了，但是一直都没有自己用过，这次在开发任务中碰到也算是学习了一下，首先枚举类型的构造十分简单，和class类似。 123456789101112131415161718192021public enum ExpressStatus implements EnumValue &#123; DELIVERED(0),BACk(1); private int value; ExpressStatus(int value)&#123;this.value=value;&#125; public static ExpressStatus valueOf(int value)&#123; //这个方法是重载的，用于枚举值和实际值int转换 switch (value)&#123; case 0: return DELIVERED; case 1: return BACk; default: return null; &#125; &#125; @Override public int getValue()&#123;return value;&#125;&#125; 定义后在后端代码中正常使用即可，主要的不同在于mybatis的xml文件中与数据库表的映射需要调用一个handler处理，在insert方法中调用系统的EnumOrdinalTypeHandler即可正常转换插入 123456789&lt;insert id="insert" parameterType="finley.gmair.model.drift.Express" useGeneratedKeys="false"&gt; insert into gmair_drift.order_express (order_id, express_id, express_status, company, block_flag, create_time) VALUES (#&#123;orderId&#125;, #&#123;expressId&#125;, #&#123;status, typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;company&#125;, #&#123;blockFlag&#125;, #&#123;createAt&#125;)&lt;/insert&gt; 这样可以保证数据插入的正常，但是想要正常的获取数据还需要我们自己写一个handler用于数据的检验和转换，这个handler类的编写是继承并实现系统提供的abstract class，第一眼看上去好像代码很复杂但是其实都是根据实际情况overwrite，而且逻辑简单，只是抽象类的方法体比较陌生，但是其实并不难。这个ExpressStatusHandler的代码较长而且就是实现抽象类就不贴了，写好以后在mybatis中的xml文件中的”resultMap”映射标签中提供这个handler就ok了 1234567&lt;resultMap id="expressVo" type="finley.gmair.model.drift.Express"&gt; &lt;result property="orderId" column="order_id"&gt;&lt;/result&gt; &lt;result property="expressId" column="express_id"&gt;&lt;/result&gt; &lt;result property="company" column="company"&gt;&lt;/result&gt; &lt;result property="status" column="express_status" typeHandler="finley.gmair.mybatis.handler.ExpressStatusHandler"&gt;&lt;/result&gt;&lt;/resultMap&gt; 这样就实现了枚举类与数据库交互的转换。 总结学习总是难受的过程，拿到任务我也总是会畏难，拖啊拖的，但是其实碰到的困难有多难克服并总结后的收获就有多大。今天是8月16号，离开学也就剩两周时间了，希望自己能好好抓紧时间少摸鱼多锄地！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree lc538]]></title>
    <url>%2F2019%2F08%2F14%2F20190814-lc538%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / 2 13 Output: The root of a Greater Tree like this: 18 / 20 13 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree python3–lastOrder递归1234567891011121314151617= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: count=0; def convertBST(self, root: TreeNode) -&gt; TreeNode: if root: root.right=self.convertBST(root.right); root.val=root.val+self.count; self.count=root.val; root.left=self.convertBST(root.left); return root; return None; java–lastOrder非递归12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int count=0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack(); //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考 TreeNode node=root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.add(node); node=node.right; &#125; node=stack.pop(); node.val+=count; count=node.val; if(node.left!=null) node=node.left; else node=null; &#125; return root; &#125;&#125; 总结本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求众数 lc169]]></title>
    <url>%2F2019%2F08%2F07%2F20190807-lc169%2F</url>
    <content type="text"><![CDATA[题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element java–sort+map+摩尔投票法sort后一次遍历处理，时间复杂度O(NlogN)12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; //if(nums==null)return 0;题目保证不会出现的情况 if(nums.length==1)return nums[0]; int count=1; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i++) &#123; if(nums[i]==nums[i+1]) count++; else &#123; if(count&gt;nums.length/2) return nums[i]; else count=1; &#125; &#125; return count&gt;nums.length/2?nums[nums.length-1]:0; &#125;&#125; map一次遍历存储后输出即可，时间复杂度O(N)123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int x:nums)&#123; if(map.containsKey(x)) map.put(x,map.get(x)+1); else map.put(x,1); &#125; for(int x:map.keySet())//keySet方法返回key的集合set if(map.get(x)&gt;nums.length/2) return x; return 0; &#125;&#125; 摩尔投票法O(N)1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int maj = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (maj == nums[i]) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; &#125; return maj; &#125;&#125; python本题投机取巧法（如果有唯一众数，那一定是排序后的中位数） 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2]; 总结本题是leetcode中的简单难度题，只是求解的话比较容易。 但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好 而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pow(x,n) lc50]]></title>
    <url>%2F2019%2F08%2F06%2F20190806-lc50%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000 示例 2:输入: 2.10000, 3输出: 9.26100 示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n java–非递归分治循环123456789101112class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i=i/2) &#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; python–递归123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x, n = 1/x, -n; if not n: #recursion termination return 1; if n % 2: return x*self.myPow(x, n-1); return self.myPow(x*x, n/2); 总结本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。需要注意的有两点：一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n = 1/x, -n」比较方便。二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。tip：注意递归写法的重要习惯————递归终止语句]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯理解+实例]]></title>
    <url>%2F2019%2F08%2F05%2F20190805%2F</url>
    <content type="text"><![CDATA[什么是贝叶斯英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。 在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2/10）而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。 贝叶斯案例有两个一模一样的碗1号碗里有：30个巧克力和10个水果糖2号碗里有：20个巧克力和20个水果糖然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率） 第1步，分解问题1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？来自1号碗记为事件A1，来自2号碗记为事件A2取出的是巧克力，记为事件B，那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率 2）已知信息：1号碗里有30个巧克力和10个水果糖2号碗里有20个巧克力和20个水果糖取出的是巧克力 第2步，应用贝叶斯定理1）求先验概率由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)=P(A2)=0.5,(其中A1表示来自1号碗，A2表示来自2号碗)这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。 2）求可能性函数P(B|A1)/P(B)其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)=30/(30+10)=75%P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)=0.75*0.5+20/(20+20)*0.5=62.5%所以，可能性函数P(A1|B)/P(B)=75%/62.5%=1.2可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。 3）带入贝叶斯公式求后验概率将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)=60%这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
