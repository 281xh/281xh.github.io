<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分发糖果-lc135]]></title>
    <url>%2F2019%2F12%2F28%2F20191228-lc135%2F</url>
    <content type="text"><![CDATA[题目描述老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 输入: [1,0,2]输出: 5解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。示例 2: 输入: [1,2,2]输出: 4解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/candy java1234567891011121314151617class Solution &#123; public int candy(int[] ratings) &#123; int res = 0; int[] candy1 = new int[ratings.length]; int[] candy2 = new int[ratings.length]; candy1[0] = 1; candy2[candy2.length-1] = 1; for(int i=1; i&lt;candy1.length; i++) candy1[i] = ratings[i]&gt;ratings[i-1]?candy1[i-1]+1:1; for(int i=candy1.length-2; i&gt;=0; i--) candy2[i] = ratings[i]&gt;ratings[i+1]?candy2[i+1]+1:1; for(int i=0;i&lt;ratings.length;i++) res += Math.max(candy1[i],candy2[i]); return res; &#125;&#125; python31234567891011class Solution: def candy(self, ratings: List[int]) -&gt; int: can1, can2 = [1]*len(ratings), [1 for _ in range(len(ratings))] //两种赋值方法有相同的效果，但是前者消耗更小 res = 0 for i in range(1,len(ratings)): can1[i] = can1[i-1]+1 if ratings[i]&gt;ratings[i-1] else 1 for i in range(len(ratings)-2,-1,-1): can2[i] = can2[i+1]+1 if ratings[i]&gt;ratings[i+1] else 1 for i in range(len(ratings)): res = res + max(can1[i],can2[i]) return res 总结&amp;&amp;思路lc困难题，难点在于思路。要求中“相邻的孩子中，评分高的孩子必须获得更多的糖果。”这一点要求一个孩子获得的糖果数与左右两边的孩子的评分有关：1、如果一个孩子的评分小于等于两边的孩子，那么给他一个糖果即可。2、如果一个孩子的评分大于左边（右边）的孩子，小于等于右边（左边）的孩子，那么要分给这个孩子“左边孩子糖果数+1”的糖果。3、如果一个孩子的评分大于左右两边的孩子，那么要分配给这个孩子“相邻孩子中更大评分的孩子的糖果数+1”的糖果。 总结来说，对于一个节点的值需要与左右两个节点的关系决定的这一类题型可以尝试分解为1、先从头至尾只考虑与左边节点的关系做一次遍历2、后从尾至头只考虑与右边节点的关系做一次遍历3、2可以建立在1的基础上直接完成，也可以做第三次遍历综合1和2生成最终的结果。这样的分解方式可以简化问题，在上学期的高级算法课程的练习中也有题用到类似的思想，希望自己牢记，作为自己的工具在以后遇见时可以敏感并且灵活运用。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K 个一组翻转链表-lc25]]></title>
    <url>%2F2019%2F12%2F25%2F20191225-lc25%2F</url>
    <content type="text"><![CDATA[题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group java123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while(end != null)&#123; for(int i=0; i&lt;k&amp;&amp;end!=null; i++) end = end.next; if(end == null) break; ListNode start = pre.next; ListNode nxt = end.next; end.next = null;//necessary for function reverse! pre.next = reverse(start); start.next = nxt; pre = start; end = start; &#125; return dummy.next; &#125; //reverse public ListNode reverse(ListNode head)&#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; python312345678910111213141516171819202122232425= Definition for singly-linked list.= class ListNode:= def __init__(self, x):= self.val = x= self.next = Noneclass Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next, pre, end = head, dummy, dummy while end: for _ in range(k): end = None if end == None else end.next if not end: break; start, nxt, end.next = pre.next, end.next, None pre.next = self.reverse(start) start.next, pre, end = nxt, start, start return dummy.next def reverse(self, head: ListNode) -&gt; ListNode: pre, cur = None, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre 总结&amp;&amp;思路lc困难题，参考了lc评论区大佬的解法，主要是链表的细节要非常注意。以及null值的判断一定要全面。步骤分解:1、链表分区为已翻转部分+待翻转部分+未翻转部分2、每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定3、需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来4、初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾5、经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next6、翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环7、特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可作者：reals链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/来源：力扣（LeetCode） 积累基本操作反转链表，作为基本操作一定要牢记并灵活运用，同时也是一道lc简单题 反转链表-lc206 12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; 123456class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: pre, cur = None, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前 K 个高频元素-lc347]]></title>
    <url>%2F2019%2F12%2F16%2F20191216-lc347%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]示例 2: 输入: nums = [1], k = 1输出: [1]说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/top-k-frequent-elements java12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; if(map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i])+1); else map.put(nums[i],1); &#125; int[][] res = new int[map.size()][2]; int index = 0; for(int x:map.keySet())&#123; res[index][0] = x; res[index][1] = map.get(x); index++; &#125; Arrays.sort(res,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0]?o1[0]-o2[0]:o2[1]-o1[1]; &#125; &#125;); for(int i=0;i&lt;k;i++) list.add(res[i][0]); return list; &#125;&#125; python31234from collections import Counterclass Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: return [item[0] for item in Counter(nums).most_common(k)] 总结&amp;&amp;思路lc中等难度题，java中通过两步实现1、计数，java中通过map的key存储值，value计数。python中则通过Counter函数进行计数直接生成dict。 2、Java中通过比较器实现按照value值降序排列。python中则通过most_common()方法实现前k个数的截取。 积累python3Counter计数器 12345import collectionsobj = collections.Counter('aabbccc')print(obj)=输出：Counter(&#123;'c': 3, 'a': 2, 'b': 2&#125;) most_common(指定一个参数n，列出前n个元素，不指定参数，则列出所有) 12345import collectionsobj = collections.Counter('aabbbcccc')print(obj.most_common(2))=输出：[('c', 4), ('b', 3)] items(从dict类中继承的方法) 1234567891011import collectionsobj = collections.Counter('aabbbcccc')print(obj.items())for k,v in obj.items(): print(k,v)=输出：dict_items([('b', 3), ('c', 4), ('a', 2)])= b 3= c 4= a 2]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[是否能通过考试（背包问题）]]></title>
    <url>%2F2019%2F12%2F15%2F20191215-LCS%2F</url>
    <content type="text"><![CDATA[Description小张想要通过明天的考试。他知道考题的分值分布，也知道考试中要拿到每一个题目需要耗费的时间。假设考试时长为h，共n个题目，需要拿到p分才能通过考试。现在已知每个考题的得分与耗时，请你判断小张能否通过合理安排时间，而通过考试，并给出通过考试的最短时间。 Input输入第一行为测试用例个数.每一个用例有若干行，第一行为任务数量n、考试时常h、通过分数p，下面的n行是每一个题目的耗时和得分。所有数值用空格分开。 Output对每一个用例输出一行，如果能够通过考试，则输出“YES”和做法消耗时间，用空格隔开。 否则，输出“NO”。 SampleSample Input 135 40 2112 1016 1020 1024 108 31 41 1719 145 37 1617 1410 59 103 710 12 Sample Output 1YES 36NOYES 12 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;class T1&#123; static void deal(int n, int h, int p, int[][] num)&#123; int[][] dp = new int[n+1][h+1]; int time = 0;//记录题目用时 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=h;j++)&#123; if(j-num[i-1][0]&gt;=0)&#123; if(dp[i-1][j] &gt; dp[i-1][(j-num[i-1][0])]+num[i-1][1]) dp[i][j] = dp[i-1][j];//不做这题 else dp[i][j] = dp[i-1][(j-num[i-1][0])]+num[i-1][1];//做这题 &#125; &#125; int j = h; for(int i=n;i&gt;0;i--)&#123; if(dp[i][j]!=dp[i-1][j])&#123; time+=num[i-1][0]; j-=num[i-1][1]; &#125; &#125; if(dp[n][h]&lt;p) System.out.println("NO"); else System.out.println("YES"+" "+time); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; int[] nph = StrTurnInt(scan.nextLine().trim().split(" ")); int[][] num = new int[nph[0]][]; for(int i=0;i&lt;nph[0];i++) num[i] = StrTurnInt(scan.nextLine().trim().split(" ")); deal(nph[0],nph[1],nph[2],num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路本题是非常典型的背包问题，是经典的dp算法题型，思路如下1、首先创建dp[][]二维数组，其中行为问题，列为时间限制（对应背包问题的物品和背包容量），然后通过动态规划填充整个dp[][]数组，数组最后一位dp[n][h]保存的是给定时间下的最大分数。2、要求做法消耗的时间需要使用回溯法，从dp[n][h]开始往回回溯，如果碰到满足动态规划递推公式的关系就存储下这一时间（其实就是这一道题是做了的意思，所以记录下做这道题的时间）。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort方法总结]]></title>
    <url>%2F2019%2F12%2F15%2F20191215-sortSummary%2F</url>
    <content type="text"><![CDATA[八种经典排序算法总结算法类型 算法时间，空间，稳定性时间复杂度函数]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell排序]]></title>
    <url>%2F2019%2F12%2F15%2F20191215%2F</url>
    <content type="text"><![CDATA[java-实现Shell排序123456789101112131415161718192021222324class shellSort&#123; public static void main(String[] args) &#123; int[] num = new int[]&#123;23,3,11,34,45,43,67,56,22,33,11,2,8,75,26&#125;; int[] gap = new int[]&#123;5,3,1&#125;; for(int x:gap) shell(num,x); for(int x:num) System.out.print(x+" "); System.out.println(); &#125; static void shell(int[] num,int gap)&#123; int j; for(int i=gap; i&lt;num.length; i++)&#123; int temp = num[i]; for(j=i-gap; j&gt;=0; j-=gap)&#123; if(num[j] &gt; temp) num[j+gap] = num[j]; else break;//注意一定要加，不然下一步每次都遍历回第一位，然后把第一位换掉 &#125; num[j+gap] = temp; &#125; &#125;&#125; 总结&amp;思路八大经典排序算法之一，是插入排序的升级版，核心思想是按照gap将序列划分，每次对划分出来的部分进行插入排序 随着gap慢慢减小到1，排序完成]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分配问题-T4-1]]></title>
    <url>%2F2019%2F11%2F24%2F20191124-T4-1%2F</url>
    <content type="text"><![CDATA[Description对给定的n个任务与n个人之间的成本矩阵完成成本最低的任务分配策略。 Input输入：第一行为用例个数，之后为每一个用例；用例的第一行为任务个数，即n；用例的第二行为使用逗号隔开的人员完成任务的成本；每一个成本描述包括人员序号、任务序号和成本，使用空格隔开。人员序号和任务序号都是从1到n的整数，序号出现的次序没有固定规则。 Output输出：每一个用例输出一行，从序号为1的人员开始，给出其分配的任务序号，使用空格隔开；使用逗号将多个解隔开。结果按照人员分配的任务序号大小排，第一个人员的任务序号大的放在前面，如果相同则看第二个人员的任务，以此类推。 SampleSample Input 1142 1 6,1 2 2,1 3 7,1 4 8,1 1 9,2 2 4,2 3 3,2 4 7,3 1 5,3 2 8,3 3 1,3 4 8,4 1 7,4 2 6,4 3 9,4 4 4 Sample Output 12 1 3 4 java-回溯+基本数据操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.*;public class T1 &#123; static void distribute(List&lt;int[]&gt; t, int n) &#123; int[][] matrix = new int[n][n]; int[] temp = new int[n]; int minCount = Integer.MAX_VALUE; for(int i=0;i&lt;n;i++) temp[i] = i; for(int[] x:t) matrix[x[0]-1][x[1]-1] = x[2]; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); change(list,temp,0); for(int[] tmp:list) &#123; int count = 0; for(int i=0;i&lt;n;i++) count+=matrix[i][tmp[i]]; minCount = Math.min(minCount, count); &#125; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); for(int[] tmp:list) &#123; int count = 0; for(int i=0;i&lt;n;i++) count+=matrix[i][tmp[i]]; if(count == minCount) &#123; int[] t1 = Arrays.copyOf(tmp, tmp.length); res.add(t1); &#125; &#125; //print List&lt;String&gt; res1 = new ArrayList&lt;&gt;(); for(int[] x:res) &#123; StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;x.length-1;i++) sb.append((x[i]+1)+" "); sb.append(x[x.length-1]+1); res1.add(sb.toString()); &#125; Collections.sort(res1,Collections.reverseOrder()); String p =""; if(res1.size() == 1) p += res1.get(0); else &#123; for(int i=0;i&lt;res1.size()-1;i++) p+=res1.get(i)+","; p+=res1.get(res1.size()-1); &#125; System.out.println(p); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int testcase = Integer.parseInt(scan.nextLine()); for(int z=0; z&lt;testcase; z++) &#123; //scan.nextLine(); int n = Integer.parseInt(scan.nextLine()); String[] tmp = scan.nextLine().split(","); List&lt;int[]&gt; t = deal(tmp); distribute(t,n); &#125; scan.close(); &#125; static List deal(String[] tmp)&#123; List&lt;int[]&gt; t = new ArrayList&lt;&gt;(); for(String s:tmp) &#123; String[] a = s.split(" "); t.add(StrTurnInt(a)); &#125; return t; &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; //回溯全排列 static void change(List&lt;int[]&gt; list, int[] temp,int start)&#123; if(start == temp.length)&#123; int[] z = Arrays.copyOf(temp, temp.length); list.add(z); return; &#125; for(int i=start;i&lt;temp.length;i++)&#123; int t = temp[i]; temp[i] = temp[start]; temp[start] = t; change(list,temp,start+1); t = temp[i]; temp[i] = temp[start]; temp[start] = t; &#125; &#125;&#125; 总结&amp;思路本题主要考察回溯法和基本数据操作，较难。我们需要通过创建一个n*n的矩阵用来存储分配成本，然后考察所有的分配情况并获取其中的最小成本值。 难点在于考察所有的分配情况，这里我们通过回溯法获取人员任务分配的全排列可能情况，然后帮助进行查找最小成本值。 找到最小成本值后再遍历一遍找出所有最小成本的方案。 最后还要注意输出格式问题，校园oj格式比较麻烦，要细致注意输出格式。 附上回溯法获得数组全排列，可作为模板熟记 12345678910111213141516void change(List&lt;int[]&gt; list, int[] temp,int start)&#123; if(start == temp.length)&#123; int[] z = Arrays.copyOf(temp, temp.length);//数组作为基本数据结构可以用这种方法进行深拷贝 list.add(z); return; &#125; for(int i=start;i&lt;temp.length;i++)&#123; int t = temp[i]; temp[i] = temp[start]; temp[start] = t; change(list,temp,start+1); t = temp[i]; temp[i] = temp[start]; temp[start] = t; &#125; &#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序（递归&非递归）-T3-8]]></title>
    <url>%2F2019%2F11%2F18%2F20191118-T3-8%2F</url>
    <content type="text"><![CDATA[Description实现归并排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java——递归&amp;非递归12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class R8&#123; //二分递归体 static void mergeSort(int[] num, int low, int high)&#123; if(low &lt; high)&#123; int mid = (low+high)/2; mergeSort(num, low, mid); mergeSort(num, mid+1, high); merge(num, low, mid, high); &#125; &#125; //归并操作 static void merge(int[] num, int low, int mid, int high)&#123; int[] tmp = new int[high-low+1]; int i=low,j=mid+1,index=0; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(num[i]&lt;num[j]) tmp[index++] = num[i++]; else tmp[index++] = num[j++]; &#125; while(i&lt;=mid)&#123; tmp[index++] = num[i++]; &#125; while(j&lt;=high)&#123; tmp[index++] = num[j++]; &#125; for(i=0;i&lt;tmp.length;i++) num[low+i]=tmp[i]; &#125; //程序入口 public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); for(int i=0; i&lt;n; i++)&#123; scan.nextLine(); int len = scan.nextInt(); int[] num = new int[len]; for(int j=0;j&lt;len;j++) num[j] = scan.nextInt(); mergeSort(num,0,num.length-1); for(int j=0;j&lt;num.length-1;j++) System.out.print(num[j]+" "); System.out.println(num[num.length-1]); &#125; scan.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class R8pro&#123; //循环增长gap——1，2，4，8～ static void mergeSort(int[] num)&#123; int gap = 1; while(gap &lt; num.length)&#123; mergePass(num, gap); gap*=2; &#125; &#125; //按照此时的gap循环排序序列的每一个gap区间——low～mid～high static void mergePass(int[] num, int gap)&#123; int i = 0; while(i+2*gap &lt; num.length)&#123; merge(num, i, i+gap-1, i+2*gap-1);//注意mid可以和low重叠，这取决于merge方法的具体代码逻辑 i = i+2*gap; &#125; if(i+gap &lt; num.length) merge(num, i, i+gap-1, num.length-1); &#125; //归并操作 static void merge(int[] num, int low, int mid, int high)&#123; int[] tmp = new int[high-low+1]; int i=low,j=mid+1,index=0; while(i&lt;=mid&amp;&amp;j&lt;=high)&#123; if(num[i]&lt;num[j]) tmp[index++] = num[i++]; else tmp[index++] = num[j++]; &#125; while(i&lt;=mid)&#123; tmp[index++] = num[i++]; &#125; while(j&lt;=high)&#123; tmp[index++] = num[j++]; &#125; for(i=0;i&lt;tmp.length;i++) num[low+i]=tmp[i]; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); for(int i=0; i&lt;n; i++)&#123; scan.nextLine(); int len = scan.nextInt(); int[] num = new int[len]; for(int j=0;j&lt;len;j++) num[j] = scan.nextInt(); mergeSort(num); for(int j=0;j&lt;num.length-1;j++) System.out.print(num[j]+" "); System.out.println(num[num.length-1]); &#125; scan.close(); &#125;&#125; 总结&amp;思路八大算法之一 递归版本比较经典 非递归版本需要通过控制gap增长（对应递归的二分操作），并且按照此时的gap循环排序序列的每一个gap区间——low～mid～high注意mid和low，high的关系要前后一致，类似与向上取整还是向下取整一定要统一的思想]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序（递归&非递归）-T3-7]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-7%2F</url>
    <content type="text"><![CDATA[Description实现快速排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.*;class Main&#123; public static int partition(int[] a, int low, int high) &#123; // 三数取中,将中间元素放在第一个位置（优化效率操作） if (a[low] &gt; a[high]) swap(a, low, high); if (a[(low + high) / 2] &gt; a[high]) swap(a, (low + high) / 2, high); if (a[low] &lt; a[(low + high) / 2]) swap(a, (low + high) / 2, low); int pivotKey = a[low]; // 用第一个元素作为基准元素 while (low &lt; high) &#123; // 两侧交替向中间扫描 while (low &lt; high &amp;&amp; a[high] &gt;= pivotKey) high--; a[low] = a[high]; // swap(a, low, high); //比基准小的元素放到低端 while (low &lt; high &amp;&amp; a[low] &lt;= pivotKey) low++; a[high] = a[low]; // swap(a, low, high); //比基准大的元素放到高端 &#125; a[low] = pivotKey; // 在中间位置放回基准值 return low; // 返回基准元素所在位置 &#125; static void deal(int[] a, int low, int high)&#123; int pivot; if (low &gt;= high) return; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); stack.push(low); stack.push(high); while (!stack.empty()) &#123; // 先弹出high,再弹出low high = stack.pop(); low = stack.pop(); pivot = partition(a, low, high); // 先压low,再压high if (low &lt; pivot - 1) &#123; stack.push(low); stack.push(pivot - 1); &#125; if (pivot + 1 &lt; high) &#123; stack.push(pivot + 1); stack.push(high); &#125; &#125; //deal with the print for(int i=0;i&lt;a.length-1;i++) System.out.print(Integer.toString(a[i])+" "); System.out.println(Integer.toString(a[a.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num, 0, num.length-1); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; //swap public static void swap(int[] a, int i, int j) &#123; int temp; temp = a[j]; a[j] = a[i]; a[i] = temp; &#125;&#125; 总结&amp;思路八大算法之一，利用栈实现非递归的版本，首先需要掌握常规的递归实现，将递归语句替换成符合运算顺序逻辑的入栈出栈操作即可，需要注意的是入栈出栈顺序。附上常规递归版本 123456789101112131415161718192021222324//快排递归体static void quickSort(int[] num,int low,int high)&#123; if(low &gt; high) return; int mid = partition(num,low,high); quickSort(num, low, mid-1); quickSort(num, mid+1, high);&#125;//每次将一个元素放到它的准确位置上，返回它的indexstatic int partition(int[] num,int low,int high)&#123; int tmp = num[low]; while(low &lt; high)&#123; while(low&lt;high &amp;&amp; num[high]&gt;=tmp)&#123; high--; &#125; num[low] = num[high]; while(low&lt;high &amp;&amp; num[low]&lt;=tmp)&#123; low++; &#125; num[high] = num[low]; &#125; num[low] = tmp; return low;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序-T3-6]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-6%2F</url>
    <content type="text"><![CDATA[Description实现计数排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;class Main&#123; static void deal(int[] num)&#123; int[] tnum = new int[num.length]; for(int i=0;i&lt;num.length;i++) tnum[i] = num[i]; for(int i=0; i&lt;tnum.length; i++)&#123; int count = 0; int same = 0; for(int j=0; j&lt;tnum.length; j++) if(tnum[j]&lt;tnum[i]) count++; else if(tnum[j]==tnum[i]) same++; for(int y = 0 ; y &lt; same ; y++) num[count+y]=tnum[i]; &#125; //deal with the print for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路顾名思义按照每个元素大于（小于）所有元素的个数确定该元素的位置，用count记录，然后直接将该元素放到最终位置，需要注意有重复值的情况，用same记录。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序-T3-5]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-5%2F</url>
    <content type="text"><![CDATA[Description实现冒泡排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main&#123; static void deal(int[] num)&#123; for(int i=0; i&lt;num.length; i++) for(int j=num.length-1; j&gt;i; j--) if(num[j]&lt;num[j-1])&#123; int temp = num[j]; num[j] = num[j-1]; num[j-1] = temp; &#125; //deal with the print for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); while(scan.hasNextLine())&#123; int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路八大排序之一，比较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序-T3-4]]></title>
    <url>%2F2019%2F11%2F16%2F20191116-T3-4%2F</url>
    <content type="text"><![CDATA[Description实现插入排序。 Input输入第一行为用例个数， 每个测试用例输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。 Output输出排序的数组，用空格隔开，末尾不要空格。 SampleSample Input 1113 24 3 56 34 3 78 12 29 49 84 51 9 100 Sample Output 13 3 9 12 24 29 34 49 51 56 78 84 100 java123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;class Main&#123; static void deal(int[] num)&#123; for(int i=1; i&lt;num.length; i++)&#123; int tmp = num[i]; int j=i; while(j-1&gt;=0&amp;&amp;num[j-1]&gt;tmp)&#123; num[j] = num[j-1]; j--; &#125; num[j] = tmp; &#125; for(int i=0;i&lt;num.length-1;i++) System.out.print(Integer.toString(num[i])+" "); System.out.println(Integer.toString(num[num.length-1])); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing int n = scan.nextInt(); int[] num = StrTurnInt(scan.nextLine().trim().split(" ")); deal(num); &#125; scan.close(); &#125; //turn String[] to int[] static int[] StrTurnInt(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125;&#125; 总结&amp;思路八大排序之一，比较简单，每次选定一个序列元素，向前找到合适自己的位置将它原来位置前的元素都后移一位后插入到合适位置即可。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表区间逆序-T3-3]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-3%2F</url>
    <content type="text"><![CDATA[Description将单个链表的每K个节点之间逆序，打印出新链表；最后不足K的节点数不需要逆序；要求时间复杂度为O(n)，额外空间复杂度为O(1)。 Input输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个表示链表长度，中间为节点值，最后代表K。 Output输出的每一行为新的链表，节点值用空格隔开，末尾不要空格。 SampleSample Input 128 1 2 3 4 5 6 7 8 38 a b c d e f g h 4 Sample Output 13 2 1 6 5 4 7 8d c b a h g f e java123456789101112131415161718192021222324252627282930313233343536import java.util.*;class Main&#123; static void deal(String[] str, int n)&#123; int flag = 0; while(flag+n-1 &lt; str.length)&#123; swap(str, flag, flag+n-1); flag+=n; &#125; for(int i=0;i&lt;str.length-1;i++) System.out.print(str[i]+" "); System.out.println(str[str.length-1]); &#125; static void swap(String[] str, int start, int end)&#123; while(start&lt;end)&#123; String tmp = str[start]; str[start] = str[end]; str[end] = tmp; start++; end--; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] tool = scan.nextLine().split(" "); String[] str = new String[tool.length-2]; for(int i=0;i&lt;str.length;i++) str[i] = tool[i+1]; deal(str, Integer.parseInt(tool[tool.length-1])); &#125; scan.close(); &#125;&#125; 总结&amp;思路按照题意需要两个指针每次一个不动一个移动K位然后逆转这部分链表，如果剩余链表长度不足以第二个指针移动K位则不进行逆置并结束操作。 但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表回文-T3-2]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-2%2F</url>
    <content type="text"><![CDATA[Description判断一个单向链表是否为回文结构。自定义链表数据结构，要求时间复杂度为O(n)，额外空间复杂度为O(1)。 Input输入第一行为用例个数， 每个测试用例输入的每一行的值用空格隔开，第一个值为节点个数，后面为每一个节点值 Output是回文则输出true，不是则输出false，一行表示一个链表的结果。 SampleSample Input 143 1 2 14 1 2 2 13 3 5 36 a b c d c a Sample Output 1truetruetruefalse java1234567891011121314151617181920212223242526272829303132import java.util.*;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing int n = scan.nextInt(); String res = scan.nextLine().trim(); if(res.equals(reverseString(res))) System.out.println("true"); else System.out.println("false"); &#125; scan.close(); &#125; //reverse the String public static String reverseString(String str) &#123; char[] arr=str.toCharArray(); int middle = arr.length&gt;&gt;1;//EQ length/2 int limit = arr.length-1; for (int i = 0; i &lt; middle; i++) &#123; char tmp = arr[i]; arr[i]=arr[limit-i]; arr[limit-i]=tmp; &#125; return new String(arr); &#125;&#125; 总结&amp;思路按照题意单向链表解决本题，则需要先用一个快慢指针找到单向链表的中间结点，然后逆向前半段链表后一一比对。同时也是一道lc的原题。 但是学校的oj系统比较差，其实正常处理输入就可以做，但是这样做就非常简单了，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列-T3-1]]></title>
    <url>%2F2019%2F11%2F14%2F20191114-T3-1%2F</url>
    <content type="text"><![CDATA[Description给定两个字符串，返回两个字符串的最长公共子序列（不是最长公共子字符串），可能是多个。 Input输入第一行为用例个数， 每个测试用例输入为两行，一行一个字符串 Output如果没有公共子序列，不输出，如果有多个则分为多行，按字典序排序。 SampleSample Input 111A2BD3G4H56JK23EFG4I5J6K7 Sample Output 123G456K23G45JK java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.*;class Main&#123; //recall and get the LCS public static void printLCS(String[] num1, int[][] path, int row, int col, String cur, List&lt;String&gt; res)&#123; //the end condition if(path[row][col] == 0)&#123; if(!res.contains(reverseString(cur))) res.add(reverseString(cur)); return; &#125; if(path[row][col] == path[row-1][col]) printLCS(num1, path, row-1, col, cur, res); if(path[row][col] == path[row][col-1]) printLCS(num1, path, row, col-1, cur, res); if(path[row][col]!=path[row-1][col] &amp;&amp; path[row][col]!=path[row][col-1])&#123; cur += num1[row-1]; printLCS(num1, path, row-1, col-1, cur, res); &#125; &#125; //caculate the len of LCS by dp and recall the LCS public static void deal(String[] num1, String[] num2)&#123; int[][] path = new int[num1.length+1][num2.length+1]; //take care of the length of the res for(int i=1; i&lt;=num1.length; i++) for(int j=1; j&lt;=num2.length; j++) if(num1[i-1].equals(num2[j-1])) //the length is different path[i][j] = path[i-1][j-1]+1; else path[i][j] = Math.max(path[i-1][j],path[i][j-1]); //caculate the len of LCS //int len = path[path.length-1][path[0].length-1]; //System.out.println(len); String cur = ""; List&lt;String&gt; res = new ArrayList&lt;&gt;(); printLCS(num1, path, num1.length, num2.length, cur, res); // Set t = new HashSet(res); // res.clear(); // res.addAll(t); Collections.sort(res); for(String s:res) System.out.println(s); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; //other dealing String[] num1 = scan.nextLine().trim().split(""); String[] num2 = scan.nextLine().trim().split(""); deal(num1,num2); &#125; scan.close(); &#125; //reverse the String public static String reverseString(String str) &#123; char[] arr=str.toCharArray(); int middle = arr.length&gt;&gt;1;//EQ length/2 int limit = arr.length-1; for (int i = 0; i &lt; middle; i++) &#123; char tmp = arr[i]; arr[i]=arr[limit-i]; arr[limit-i]=tmp; &#125; return new String(arr); &#125;&#125; 总结&amp;思路本题是同类型题目中扩展的比较大的情况，比较通常的情况是求LCS的长度或者一种情况。 所有情况的解法可以看成两个部分：1、创建二维数组path[][]通过动态规划存储从path[0][0]——path[n][m]的所有情况（LCS的长度信息就存储在path[n][m]中）2、通过回溯法从后往前回溯path数组，并在过程中维护一个str用于存储LSC（具体方法是在path增长的那一个结点获取原字符串中对应index的字符）注意点：（1）从后往前回溯获得的LCS是反的，需要在存入时进行反转处理。（2）要避免LCS重复的情况，保险起见对结果list去重。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子序列-lc1143]]></title>
    <url>%2F2019%2F11%2F07%2F20191107-lc1143%2F</url>
    <content type="text"><![CDATA[题目描述给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace”，它的长度为 3。示例 2: 输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc”，它的长度为 3。示例 3: 输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-subsequence 思路&amp;实现本题属于典型的动态规划题型，可以通过动态规划快速解决 java12345678910111213class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int[][] res = new int[text1.length()+1][text2.length()+1]; for(int i=1; i&lt;res.length; i++) for(int j=1; j&lt;res[0].length; j++)&#123; if(text1.charAt(i-1)==text2.charAt(j-1)) res[i][j]=res[i-1][j-1]+1; else res[i][j]=Math.max(res[i][j-1],res[i-1][j]); &#125; return res[res.length-1][res[0].length-1]; &#125;&#125; python31234567891011class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int: n, m = len(text1), len(text2) res = [[0]*(m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m+1): if text1[i-1]==text2[j-1]: res[i][j] = res[i-1][j-1]+1 else: res[i][j] = max(res[i-1][j], res[i][j-1]) return res[n][m] 总结lc中等难度题，主要考察动态规划。思路清晰注意好递推条件可以快速解决。 本题还有变体包括：1、输出公共子序列（任一）2、输出所有公共子序列，并按照字典顺序排序（dp+回溯法） 其中2为高级算法课的课后练习，还涉及回溯法，很有学习必要。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair install&management&auth admin]]></title>
    <url>%2F2019%2F11%2F05%2F20191105-tec%2F</url>
    <content type="text"><![CDATA[前言开学第三个月的时间，经历了在私募公司两个月需求不明的实习，回归果麦项目的第一个周期任务也结束了。经过了一段时间的熟悉又上手了spring boot+spring cloud项目。还好有之前的项目总结，上手熟悉没有花费太多的时间，同样，这次也做好总结，方便回顾学习，温故而知新。 这次是果麦新风install模块的功能开发，先贴上学长的要求和我的完成结果： 我说下前端显示的情况：（1）首先我会与一个负责人列表，这个你要去查team_member里role为1的用户返回给我（2）点击每一个member我要知道它所关注的所有团队，要能删除这个团队，或者添加一个新的关注团队。（3）另外，你还需要给我提供一个根据团队id查看所有相关负责人的接口 完成（1）installdesk/MemberController.java–&gt;leaderList()（2）installdesk/TeamWatchController.java–&gt;watches() block() watch()（3）installdesk/TeamWatchController.java–&gt;list() 本来以为只是常规的service/dao/db curd，但还是有比较多的新内容，installdesk模块的接口需求涉及mybatis的多表连接（有问题也有发现），完成后将接口调用加到management里面，并且想要通过管理员权限调用接口进行测试还需要启动auth admin模块调用接口获取token。总之，我又踩了很多坑。。。 踩坑经历1、由于自己的鱼唇首先浪费掉最多时间的永远是自己的愚蠢。一开始进行多表连接由于一开始流程没通过我将结果语句注释掉了，为了能在先验证mybatis的多表连接有没有打通，结果在最后都实现了却忘记了改回来，导致浪费了巨量的时间（自己永远意识不到自己的主动错误），最后还是通过断点debug的过程中发现结果正确却没返回出来才解决。 然而事情还没有完，后面本地运行auth admin报错数据源错误，一开始是配置文件propertise中的数据源没有更新成本地的导致了这样的问题，在改正之后却依旧报错数据源错误，我反复的检查代码逻辑的可能错误，又浪费了大量的时间并且期间陷入了自我怀疑，最后发现是macbook的touchbar启动的并不是更新后的启动类（我一直在运行之前错误的启动类），又是自己的行为导致的问题，以后在更新过启动类后一定要手动找到真实的启动类启动，不能自然的依赖touch bar去运行程序。。 2、枚举类型的查询枚举类型的查询除了需要实现handler以外还需要注意要通过真实值来查询。例如又如下枚举对应关系{ordinary(0),leader(1)}，那么如果想要从数据库中搜索所有这一项为leader的表项，那么我们需要用1这个int类型去传如参数给mybatis的sql语句才能正确执行查询，如果使用ordinary或者leader，那么这个值会默认为0。 新学到的东西1、mybatis多表连接查询由于自己的鱼唇，这一部分多做了很多工作，但是也算是把两种多表连接都学习了一下吧。 1、一对一连接————通过association标签xml文件内容如下 123456789101112131415161718192021222324252627282930&lt;resultMap id="memberTeamVo" type="finley.gmair.model.installation.MemberTeam"&gt; &lt;id property="memberId" column="member_id"/&gt; &lt;association property="member" javaType="finley.gmair.model.installation.Member"&gt; &lt;result property="memberId" column="member_id"/&gt; &lt;result property="teamId" column="team_id"/&gt; &lt;result property="memberPhone" column="member_phone"/&gt; &lt;result property="memberName" column="member_name"/&gt; &lt;result property="wechatId" column="wechat_id"/&gt; &lt;result property="memberRole" column="member_role" typeHandler="finley.gmair.mybatis.handler.MemberRoleHandler"/&gt; &lt;result property="blockFlag" column="block_flag"/&gt; &lt;result property="createAt" column="create_time"/&gt; &lt;/association&gt; &lt;select id="queryMemberTeam" parameterType="java.util.Map" resultMap="memberTeamVo"&gt; SELECT a.member_id, a.team_id, a.member_phone, a.wechat_id, a.member_name, a.member_role FROM gmair_install.team_member a LEFT JOIN gmair_install.team_watch b ON a.member_id = b.member_id WHERE 1 = 1 &lt;if test="watchId != null"&gt; AND b.watch_id = #&#123;watchId&#125; &lt;/if&gt; &lt;if test="memberId != null"&gt; AND b.member_id = #&#123;memberId&#125; &lt;/if&gt; &lt;if test="teamId != null"&gt; AND b.team_id = #&#123;teamId&#125; &lt;/if&gt; &lt;/select&gt; &lt;/resultMap&gt; 这里用到的是MemberTeam和Member两个实体类，注意association中的Member类需要作为属性写在MemberTeam里面 123456789101112public class MemberTeam &#123; private String memberId;//不加get set方法使这一项没有返回值减少表连接的数据冗余 private Member member; public MemberTeam()&#123;&#125; public Member getMember() &#123; return member; &#125; public void setMember(Member member) &#123; this.member = member; &#125;&#125; 最后返回的结果将是这个外层标签的MemberTeam类型，而表连接中另一个表的内容将会通过MemberTeam.member返回出来。 最终返回的将是一个完整的MemberTeam类型，sql语句只能保证MemberTeam的哪些属性是非null的，如果想要控制返回的MemberTeam，可以通过限制它属性的get&amp;set方法来达成，如果不加get&amp;set方法，这个属性就不会出现在返回值中，但是不会影响数据库查询时的逻辑 2、一对多连接————通过collection标签整体使用与association标签的使用类似，只是一个实体类在另一个主实体类中的不再表现为唯一属性值，而是list&lt;属性值&gt;，同样最后会通过主实体类返回。 我在项目中使用的是一对一连接，多对多代码使用参考以下博客————————————————版权声明：本文为CSDN博主「hyhcloud」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Huangyuhua068/article/details/83176160 1234567891011121314151617181920&lt;resultMap id="userMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;!--配置1对多关系映射 property：在User里面的List&lt;Account&gt;的属性名 column:外键 ofType:当前account表的java类型 --&gt; &lt;collection property="accountList" ofType="account"&gt; &lt;id property="accountId" column="accountId"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="userMap"&gt; SELECT * FROM USER LEFT JOIN account on account.uid=user.id &lt;/select&gt; 2、将接口调用加到management这一部分涉及management中的service和controller两个部分 首先我们需要将接口加到management下的service中，需要注意的是1、url的不同。2、参数要添加注释。3、接口名可以自定义 1234567891011@GetMapping("/install/teamwatch/watch/teamList") ResultData queryWatchTeam(@RequestParam("memberId") String memberId); @PostMapping("/install/teamwatch/block") ResultData blockWatchTeam(@RequestParam("memberId") String memberId, @RequestParam("teamId") String teamId); @GetMapping("/install/teamwatch/list") ResultData getLeaderListByTeamid(@RequestParam("teamId") String teamId); @GetMapping("/install/member/leader/list") ResultData getLeaderList(); 然后要在controller中调用接口 3、获取token进行测试management模块的测试需要管理员权限，需要持有token才能调用management模块的http接口。 而想要获取token需要先启动auth-admin模块然后发出请求获取token，这里由于数据源异常踩了很久的坑，前面踩坑经历有提到就不多说了。 总结这半个月的任务量其实不大，新接触的内容有mybatis多表连接查询，management实现接口调用，获取token得到管理员权限。可以说还是比较有收获的，期间碰到的问题也不少但是都解决了，debug能力++，希望下半个月的新任务能顺利也能有收获，少拖延多做事！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从前序与中序遍历序列构造二叉树-lc105]]></title>
    <url>%2F2019%2F10%2F27%2F20191027-lc105%2F</url>
    <content type="text"><![CDATA[题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / 9 20 / 15 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 思路&amp;实现通过前序遍历序列确定root结点，然后根据这个root去中序遍历序列中找到它的位置p，将中序遍历序列按照p分成左右两段，这两段就是以p为根结点的左右子树的中序遍历序列，继续在前序遍历序列中往下找root子树的根结点递归解决即可。 java12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int pre_index = 0; int[] preorder; int[] inorder; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) &#123; this.preorder = preorder; this.inorder = inorder; int i = 0; for(int x:inorder) map.put(x,i++); return help(0,inorder.length); &#125; public TreeNode help(int l, int r)&#123; //l和r只用作递归终止条件 if(l==r) return null; TreeNode root = new TreeNode(preorder[pre_index]); pre_index++; int mid = map.get(root.val); root.left = help(l,mid); root.right = help(mid+1,r); return root; &#125;&#125; python3123456789101112131415161718192021222324252627= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: pre_index = 0 preorder, inorder = [], [] f_inorder = &#123;&#125; def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: self.preorder, self.inorder = preorder, inorder i = 0 for x in inorder: self.f_inorder[x], i = i, i+1 return self.help(0, len(inorder)) def help(self, left, right) -&gt; TreeNode: if left == right: return None root, self.pre_index = TreeNode(self.preorder[self.pre_index]), self.pre_index+1 mid = self.f_inorder[root.val] root.left = self.help(left,mid) root.right = self.help(mid+1,right) return root 总结lc中等难度题，其实是数据结构书籍介绍树部分三序遍历必定会提到的经典问题。 解题思路比较清晰就是借助先序和中序序列的特性进行递归处理。 代码实现方法比较多，我参考lc题解借助map（dict–&gt;python3）能够比较快速的解决，并且时间效率较好。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[固定和的元素对-T2.6]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-6%2F</url>
    <content type="text"><![CDATA[Description输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字，统计这样两个数的对数。 Input输入第一行为用例个数， 每个测试用例输入第一行是数组，每一个数用空格隔开；第二行是数字和。 Output输出这样两个数有几对。 SampleSample Input 111 2 4 7 11 0 9 1511 Sample Input 23 java1234567891011121314151617181920212223242526272829303132333435import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner scan = new Scanner(System.in); int a; a = scan.nextInt(); scan.nextLine(); while(a&gt;0)&#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int num=0; a--; String[] s = scan.nextLine().split(" "); int[] group = new int[s.length]; for(int j=0;j&lt;s.length;j++)&#123; group[j] = Integer.parseInt(s[j]); &#125; int b = scan.nextInt(); scan.nextLine(); for(int k = 0 ; k &lt; group.length ; k++)&#123; if(map.get(group[k])==null)&#123; map.put(b-group[k],group[k]); &#125; else&#123; num++; &#125; &#125; System.out.println(num); &#125; scan.close(); &#125;&#125; 总结&amp;思路lc原题，可以蛮力法简单粗暴，想要比较好的时间复杂度就用1、双指针法。2、借用map。原题就不多赘述了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间第k最小-T2.5]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-5%2F</url>
    <content type="text"><![CDATA[Description找到给定数组的给定区间内的第K小的数值。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个数用空格隔开；第二行是区间（第几个数到第几个数，两头均包含），两个值用空格隔开；第三行为K值。 Output结果。 SampleSample Input 111 2 3 4 5 6 73 52 Sample Input 24 java12345678910111213141516171819202122232425262728293031323334353637import java.util.*;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int start = scan.nextInt(); int end = scan.nextInt(); scan.nextLine(); //int k = scan.nextInt(); //scan.nextLine(); //String[] num2 = scan.nextLine().split(" "); //int start = Integer.parseInt(num2[0]); //int end = Integer.parseInt(num2[1]); int k = Integer.parseInt(scan.nextLine()); System.out.println(Run(num,start-1,end-1,k)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int Run(int[] num, int start, int end, int k)&#123; int[] n = new int[end-start+1]; for(int i=start;i&lt;=end;i++) n[i-start]=num[i]; Arrays.sort(n); return n[k-1]; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔-T2.4]]></title>
    <url>%2F2019%2F10%2F23%2F20191023-T2-4%2F</url>
    <content type="text"><![CDATA[Description汉诺塔问题中限制不能将一层塔直接从最左侧移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间。求当有N层塔的时候移动步数。 Input输入第一行为用例个数， 每个测试用例输入的第一行为N。 Output移动步数。 SampleSample Input 112 Sample Input 28 java12345678910111213141516171819import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; int num = Integer.parseInt(scan.nextLine()); System.out.println(hanoi(num)); &#125; scan.close(); &#125; static int hanoi(int n)&#123; if(n == 1) return 2; else return hanoi(n-1)*3+2; &#125;&#125; 总结&amp;思路题目描述其实不太准确，给出的sample的要求其实不太一样，但是也不是很困难。 当筹码只有一个的时候需要移动两次，而n个筹码移动的次数N(n)=N(n-1)*3+2： 即先将n-1个筹码放到最右边–将第n个筹码放到中间–将n-1个筹码放到最左边–将第n个筹码放到最右边–将n-1个筹码放到最右边。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和窗口-T2.3]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-3%2F</url>
    <content type="text"><![CDATA[Description给定一个整型数组arr和一个大小为w的窗口，窗口从数组最左边滑动到最右边，每次向右滑动一个位置，求出每一次滑动时窗口内最大元素的和。 Input输入第一行为用例个数， 每个测试用例输入的第一行为数组，每一个元素使用空格隔开；第二行为窗口大小。 Output输出每个测试用例结果。 SampleSample Input 114 3 5 4 3 3 6 73 Sample Input 232 java123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int z = 0;z&lt;count;z++)&#123; String[] num1 = scan.nextLine().split(" "); int[] num = turn(num1); int win = Integer.parseInt(scan.nextLine()); System.out.println(countWin(num,win)); &#125; scan.close(); &#125; static int[] turn(String[] num1)&#123; int[] num = new int[num1.length]; for(int i=0;i&lt;num1.length;i++) num[i]=Integer.parseInt(num1[i]); return num; &#125; static int countWin(int[] num,int win)&#123; int res = 0; for(int i=0;i&lt;num.length-win+1;i++) res+=max(num,i,win+i-1); return res; &#125; static int max(int[] num,int start,int end)&#123; int res = Integer.MIN_VALUE; for(int i=start;i&lt;=end;i++) if(res&lt;num[i]) res = num[i]; return res; &#125;&#125; 总结&amp;思路较简单，略。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子矩阵问题-T2.2]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-2%2F</url>
    <content type="text"><![CDATA[Description给定一个矩形区域，每一个位置上都是1或0，求该矩阵中每一个位置上都是1的最大子矩形区域中的1的个数。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为矩阵行数n和列数m，下面的n行每一行是用空格隔开的0或1。 Output输出一个值。 SampleSample Input 113 41 0 1 11 1 1 11 1 1 0 Sample Input 26 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;class T2&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = scan.nextInt(); for(int i = 0;i &lt; count; i++)&#123; scan.nextLine();//pass the /0 String[] two = scan.nextLine().split(" "); int n = Integer.parseInt(two[0]); int m = Integer.parseInt(two[1]); int[][] matrix = new int[n][m]; for(int k1=0;k1&lt;n;k1++) for(int k2=0;k2&lt;m;k2++) matrix[k1][k2] = scan.nextInt(); System.out.println(Deal(matrix)); &#125; scan.close(); &#125; //deal with the matrix and produce arrays to deal static int Deal(int[][] matrix)&#123; if(matrix == null||matrix.length == 0||matrix[0].length == 0) return 0; int res = 0; int[] arr = new int[matrix[0].length]; for(int i=0;i&lt;matrix.length;i++)&#123; for(int j=0;j&lt;matrix[0].length;j++) arr[j] = (matrix[i][j]==0?0:arr[j]+1); res = Math.max(res, dealArra(arr)); &#125; return res; &#125; //deal with the arr and return the max area static int dealArra(int[] arr)&#123; if(arr == null||arr.length == 0) return 0; int maxArea = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;arr.length;i++)&#123; while(!stack.empty()&amp;&amp;arr[i]&lt;arr[stack.peek()])&#123; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (i-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; stack.push(i); &#125; while(!stack.isEmpty())&#123; // while the arr is finished int right = arr.length; int cur = stack.pop(); int left = (stack.isEmpty()?0:cur); int curArea = (right-left)*arr[cur]; maxArea = Math.max(maxArea, curArea); &#125; return maxArea; &#125;&#125; 总结&amp;思路解决这题需要先了解直方图最大面积的求法初次理解花了比较多时间，说起来比较复杂就留个连接：https://www.cnblogs.com/CodeCafe/p/7634233.html 了解做法以后只要将矩阵读入成int[][]后每次读一行，并将那一行的数值当作一个直方图进行处理得出一个最大值存储起来 然后每次读下一行（需要通过上一行的值进行更新），又作为直方图得到一个最大值，并和之前存储的最大值进行比较留较大的。 循环遍历矩阵的每一行后最后留下的值就是最大值。 本题难度主要在直方图最大面积的理解，并通过辅助Stack进行代码层次的实现。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子数组的取值范围-T2.1]]></title>
    <url>%2F2019%2F10%2F22%2F20191022-T2-1%2F</url>
    <content type="text"><![CDATA[Description给定数组arr和整数num，求arr的连续子数组中满足：其最大值减去最小值的结果大于num的个数。请实现一个时间复杂度为O(length(arr))的算法。 Input输入第一行为测试用例个数。每一个用例有若干行，第一行为数组，每一个数用空格隔开，第二行为num。 Output输出一个值。 SampleSample Input 113 6 4 3 22 Sample Output 16 java123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int count = Integer.parseInt(scan.nextLine()); for(int i=0;i&lt;count;i++)&#123; int res = 0,p = 0,q = 1; String[] num = scan.nextLine().split(" "); int target = Integer.parseInt(scan.nextLine()); while(p!=num.length&amp;&amp;q!=num.length)&#123; if(p==q)&#123; q++; continue; &#125; int c = run(num,p,q); if(c&gt;target)&#123; res+=num.length-q; p++; continue; &#125; else&#123; q++; continue; &#125; &#125; System.out.println(res); &#125; scan.close(); &#125; public static int run(String[] num, int p, int q)&#123; int max=Integer.parseInt(num[p]),min=Integer.parseInt(num[p]); for(int i=p;i&lt;=q;i++)&#123; int t = Integer.parseInt(num[i]); if(t&gt;max) max=t; if(t&lt;min) min=t; &#125; return max-min; &#125;&#125; 总结&amp;思路做法是滑动窗口一次遍历数组做到时间复杂度O(N)，具体做法如下： 用两个指针l, r确定窗口边界，初始窗口大小为2只包含数组的前两位，然后对每次窗口做如下判断 1、如果窗口内的最大数-最小数&gt;num，则包含当前窗口的所有窗口必然满足条件，count += arr.length-count，然后l指针向右移一位； 2、如果窗口内的最大数-最小数&lt;num，则当前窗口不满足要求，指针l向右移一位扩大窗口后再进行判断； 3、注意窗口大小一定要&gt;=2，所以要处理l,r重合的情况； 高级算法课的课后练习和平时刷lc有较大差别，不止要想出解决的做法，还要处理好输入输出，之前一味刷lc忽略了输入输出的处理导致一开始做题真的很难受，nextInt() nextLine()换行符问题都困扰了一段时间。自己写完整程序时也要多考虑合理的模块化，方便错误定位和代码清晰性。还是要多多学习，多多练习。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>after class practise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据身高重建队列-lc406]]></title>
    <url>%2F2019%2F10%2F14%2F20191014-lc406%2F</url>
    <content type="text"><![CDATA[题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height 思路&amp;实现本题题目逻辑没有很清楚，需要了解到最终的排序要求是对于每个身处最终位置的人，他前面有且仅有k个h大于他的人。 我们用排序思路理清我们要做的就是，首先将所有人按照1、身高顺序降序排序2、身高相同则k升序排序3、遍历排序后的数组，根据K插入到K的位置上 核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求 在代码实现方面，使用java的比较器实现，并用匿名函数Lambda表达式优化代码结构，以下是实现降序排序的比较器Comparator的使用方法（Collections.reverseOrder()的实现） 1234567891011public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2)&#123; return o2-o1; &#125; &#125;); for(int x:num) System.out.println(x); &#125; 然后是使用Lambda表达式优化后的做法 123456public static void main(String[] args) &#123; Integer[] num = &#123;1,4,5,6,2,8,3&#125;; Arrays.sort(num,(o1,o2)-&gt;o2-o1); for(int x:num) System.out.println(x); &#125; 可以看到代码大大简化，可读性提升。 java比较器传统实现 1234567891011121314class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0]? o1[1]-o2[1]:o2[0]-o1[0]; &#125; &#125;); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; Lambda实现 123456789class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people,(o1,o2)-&gt;o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]); List&lt;int[]&gt; res = new ArrayList(); for(int[] x:people) res.add(x[1],x); return res.toArray(new int[people.length][2]); &#125;&#125; python3-Lambda1234567class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: people.sort(key = lambda x: [-x[0], x[1]]) res = [] for p in people: res.insert(p[1], p) return res 总结本题是一道lc中等难度题,题目要求转换成解法比较绕弯不易想到，而且比较器和Lambda函数对我来说算是新知识了，花了些时间学习了一下，比较有收获，需要注意的是，Lambda表达式虽然可以优化代码结构，但是运行速度在lc编译器中显示没有传统比较器实现来的快。 java比较器使用： 1234567Arrays.sort(object o,new Comparator&lt;sonDataType&gt;()&#123; @Override public sonDataType compare(sonDataType o1, sonDataType o2)&#123; //排序顺序o1-o2为升序，o2-o1为降序 return o1-o2; &#125;&#125;); java Lambda表达式用法： 12345678910// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();//Java 8方式：new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); python3 Lambda表达式用法： 12345//按照people中的子list的第二个元素大小升序排序people.sort(key=Lambda x:x[1])//按照people中的子list的第一个元素的大小降序排序，第一个元素同样大的情况下按照第二个元素大小升序排序people.sort(key=Lambda x:[-x[0],x[1]])]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序链表-lc148]]></title>
    <url>%2F2019%2F10%2F07%2F20191007-lc148%2F</url>
    <content type="text"><![CDATA[题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-list 思路&amp;实现题目要求逻辑很清晰，其实就是基于链表的排序，主要是限制了时间复杂度，再加上链表的特性，限制了排序方法的选择，这里我觉得用归并排序的方法解决这个题比较容易。 java123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head == null||head.next == null) return head; ListNode left = head; ListNode right = head.next; while(right!=null&amp;&amp;right.next!=null)&#123; left = left.next; right = right.next.next; &#125; ListNode tmp = left.next; left.next = null;//以中点断开链表以免相互影响 left = sortList(head); right = sortList(tmp); ListNode dummy = new ListNode(-1); ListNode res = dummy; while(left!=null&amp;&amp;right!=null)&#123; if(left.val &gt; right.val)&#123; dummy.next = right; right = right.next; &#125;else&#123; dummy.next = left; left = left.next; &#125; dummy = dummy.next; &#125; dummy.next = left!=null?left:right; return res.next; &#125;&#125; python31234567891011121314151617181920class Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head left, right = head, head.next while right and right.next: left, right = left.next, right.next.next tmp ,left.next = left.next, None left, right = self.sortList(head), self.sortList(tmp) m = res = ListNode(-1) while left and right: if left.val &lt; right.val: m.next = left left = left.next else: m.next = right right = right.next m = m.next m.next = left if left else right return res.next 总结本题是一道lc中等难度题，主要考察限制条件的sort算法，使用归并递归的方式比较好解决，但是这样会使用一些额外空间，如果想要使得空间复杂度保持O(1)，那么就需要用到非递归的归并算法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除自身以外数组的乘积-238]]></title>
    <url>%2F2019%2F09%2F25%2F20190925-238%2F</url>
    <content type="text"><![CDATA[题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6]说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self 思路&amp;实现题目其实比较简单，直观的第一想法应该是先将nums数组的元素总乘机求出然后遍历一遍数组，每个元素都对总乘机做一次除法即可。时间复杂度为O(N)但是题目要求限制使用除法，并且要求相同的复杂度。题目使坏导致我们没法那么舒适的做出这道题但是其实也可以用乘法思路解决。 对于res数组的每个元素都可以将他看成是 [该元素左边所有元素的乘积]*[该元素右边所有元素的乘积] 所以我们可以采用两次循环遍历解决这个题第一遍循环遍历解决所有左边元素的乘积（因为可以累乘所以这并不难）第二便循环遍历解决所有右边元素的乘积（相同思路） java1234567891011121314151617class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; int k = 1; for(int i = 0; i &lt; nums.length; i++)&#123; res[i] = k; k *= nums[i]; &#125; k = 1; for(int i = nums.length-1; i &gt;= 0; i--)&#123; res[i] *= k; k *= nums[i]; &#125; return res; &#125;&#125; python312345678910class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: res, k, k1 = [1]*len(nums), 1, 1 for i in range(len(nums)): res[i] *= k k *= nums[i] for i in range(len(nums)-1, -1, -1): res[i] *= k1 k1 *= nums[i] return res 总结本题是一道lc中等难度题，主要考察对线性表的基本数据操作，通过限制条件加大难度，思路理清后较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树展开为链表-lc114]]></title>
    <url>%2F2019%2F09%2F23%2F20190923-lc114%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / 2 5 / \ 3 4 6将其展开为： 1 2 3 4 5 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list 思路看题目以及给的例子可以看出题目要求，即将一颗二叉树的全部节点都放置到顺序的右子树，左子树为空。形似一根单链表。 有这样的思路步骤：1、将二叉树的右子树暂存起来，记为y2、将二叉树的左子树移到右子树位置，然后遍历现在这棵树的右节点直到尽头，然后将y接在后面3、递归处理所有的右子节点 java12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null) return; TreeNode temp = root.right; root.right = root.left; root.left = null; TreeNode t = root; while(t.right != null) t = t.right; t.right = temp; flatten(root.right); &#125;&#125; python312345678910111213141516171819\# Definition for a binary tree node.\# class TreeNode:\# def __init__(self, x):\# self.val = x\# self.left = None\# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return t1, t2 = root.right, root root.right, root.left = root.left, None while t2.right: t2 = t2.right t2.right = t1 self.flatten(root.right) 总结本题是一道lc中等难度题，主要考察二叉树的处理结合递归操作，思路清晰后代码实现比较简单。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比特位计数-lc338]]></title>
    <url>%2F2019%2F09%2F18%2F20190918-lc338%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2输出: [0,1,1]示例 2: 输入: 5输出: [0,1,1,2,1,2]进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits java python3–位运算&amp;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++)//要从1开始，第0位在数组初始化时default值为0满足要求 res[i] = res[i &amp; (i - 1)] + 1; return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0]*(num+1) for i in range(1, num+1): res[i] = res[i&amp;(i-1)] + 1 return res 这种做法运用了位运算符 a&amp;b————两个数a b都转换成二进制编码进行位比较，当且仅当两位同时为1则该位结果为1，否则为0。 技巧在于i &amp; (i-1)这个操作可以去掉i的二进制编码的最右边的一个1（被-1后的数二进制表现为最右边的1右移一位，而不影响其他1位），因此（1）i &amp; (i-1)的结果十进制数的1的个数+1就是我们要的结果。（2）i &amp; (i-1)由于最右边一位1被去掉了十进制数大小要比i小，所以已经被我们在前面计算过了并存储在了结果数组中。（3）通过这种做法不断迭代计算后面的值即可。 java python3–位运算&gt;&gt;12345678class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1; i&lt;=num; i++) res[i] = res[i&gt;&gt;1] + (i&amp;1);//注意括号一定要，&amp;和加减乘除的优先级是一样的 return res; &#125;&#125; 123456class Solution: def countBits(self, num: int) -&gt; List[int]: res = [0] for i in range(1, num+1): res.append(res[i&gt;&gt;1] + (i&amp;1)) return res 这种做法运用了位运算符 a&gt;&gt;b————将十进制数a的二进制形式右移b位（最右边b位去掉），然后返回处理后的二进制数的十进制结果。 技巧在于 i&gt;&gt;1 这个操作可以去掉i的二进制编码的最右边一位（不管是0还是1），因此（1）i&gt;&gt;1的结果（十进制）一定比i小，所以i&gt;&gt;1的1的个数的值已经被我们在前面计算过了并存储在了结果数组中。（2）如果被去掉的最后一位是0，那么我们要的值就是res[i&gt;&gt;1]； 如果是1，那么我们要的值就是res[i&gt;&gt;1]+1. 综合一下就是res[i&gt;&gt;1]+(1&amp;i)不是吗(3)通过这种做法不断迭代计算后面的值即可。 总结本题是lc中等难度的一道题，禁止使用java或是python中基本库包含的直接计数函数，考察的是对二进制以及位运算方面的知识，当然也可以将十进制数化成二进制以后再操作而不是用位运算，简单粗暴但是这样的话代码会复杂很多而且十分不优雅，所以还是要好好学习下如何用位运算来处理这样的题。在lc评论区学习一番之后总结了两种代码比较优雅时间复杂度也比较优秀的做法。 附上位运算的一些基础介绍，以后忘了可以回来看看（java,python3的位运算符用法相同）]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子集-lc78]]></title>
    <url>%2F2019%2F09%2F16%2F20190916-lc78%2F</url>
    <content type="text"><![CDATA[题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subsets java–迭代123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); res.add(new ArrayList()); for(int i = 0; i &lt; nums.length; i++)&#123; int count = res.size();//记录下当前res的长度，否则res空间跟着程序变化就会死循环 for(int j = 0; j &lt; count; j++)&#123; List&lt;Integer&gt; temp = new ArrayList(res.get(j)); temp.add(nums[i]); res.add(temp); &#125; &#125; return res; &#125;&#125; 程序思路是一开始创建一个[[]]，然后针对nums中的每个元素（以nums[0] = 1为例）进行：1、取出res中的每个子list–[]2、加上nums[0] = 1–[1]3、将这个新list加入到res中–res = [[],[1]]4、以此类推遍历nums中的所有元素 java–回溯123456789101112131415class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); back(res, 0, nums, new ArrayList()); return res; &#125; public void back(List&lt;List&lt;Integer&gt;&gt; res, int n, int[] nums, List&lt;Integer&gt; temp)&#123; res.add(temp); for(int i = n; i &lt; nums.length; i++)&#123; List&lt;Integer&gt; t = new ArrayList(temp);//基础类型所以可以做到深拷贝 t.add(nums[i]); back(res, i+1, nums, t); &#125; &#125;&#125; python3–迭代12345678class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: count = len(res) for j in range(count): res.append([i]+res[j]) return res 123456class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for i in nums: res = res + [[i] + num for num in res] return res 总结本题是一道lc中等难度题，主要学习了回溯和迭代两种做法，其中回溯法只要想像出递归树那么就能解决，主要注意的是避免因为细节问题出现重复项或多余项；迭代法思路比较巧妙，每次都在前一次迭代的基础上添加一个新元素，直到nums遍历完成。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到字符串中所有字母异位词-lc438]]></title>
    <url>%2F2019%2F09%2F11%2F20190911-lc438%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。不考虑答案输出的顺序。示例 1: 输入:s: “cbaebabacd” p: “abc” 输出:[0, 6] 解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。 示例 2: 输入:s: “abab” p: “ab” 输出:[0, 1, 2] 解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string java–滑动窗口123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res=new ArrayList(); if(s.length()==0||s.length()&lt;p.length()) return res; int[] pnum=new int[26]; int[] snum=new int[26]; for(char c:p.toCharArray()) pnum[c-'a']++; for(int i=0; i&lt;p.length()-1; i++) snum[s.charAt(i)-'a']++; for(int i=p.length()-1; i&lt;s.length(); i++)&#123; snum[s.charAt(i)-'a']++; if(Arrays.equals(pnum, snum)) res.add(i-p.length()+1); snum[s.charAt(i-p.length()+1)-'a']--; &#125; return res; &#125;&#125; python3–滑动窗口123456789101112131415161718class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: if len(s) &lt; len(p): return [] Num = [] n = len(p) A = [0] * 26 for i in range(n): A[ord(p[i]) - ord('a')] += 1 A[ord(s[i]) - ord('a')] -= 1 if A == [0] * 26: Num.append(0) for i in range(n, len(s)): A[ord(s[i]) - ord('a')] -= 1 A[ord(s[i - n]) - ord('a')] += 1 if A == [0] * 26: Num.append(i + 1 - n) return Num ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。实例如下 12345&gt;&gt;&gt;ord('a')97&gt;&gt;&gt; ord('€')8364&gt;&gt;&gt; 总结又是一道扮猪吃老虎的简单题，如果对于滑动窗口的使用不够熟练，那么这个题是有些难度的，我在空闲时间想刷一下简单题一下子就卡住了，花了些时间搞懂了滑动窗口逻辑处理的方式就很简单了。这题主要在于在窗口的移动中要维护好窗口，并且每次移动窗口都进行判断是否配对。python3和java是两种做法，但是都是基于的滑动窗口的维护，刚好可以帮助我们更好的多角度的掌握滑动窗口的使用。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Level Order Traversal-lc102]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc102%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / 9 20 / 15 7返回其层次遍历结果： [ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal java–BFS123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); if(root == null) return res; Queue&lt;TreeNode&gt; queue=new LinkedList(); queue.add(root); while(!queue.isEmpty())&#123; int len = queue.size(); List&lt;Integer&gt; temp = new ArrayList(); for(int i=0;i&lt;len;i++)&#123; TreeNode t = queue.poll(); temp.add(t.val); if(t.left!=null) queue.add(t.left); if(t.right!=null) queue.add(t.right); &#125; res.add(temp); &#125; return res; &#125;&#125; python3–BFS1234567891011121314151617181920212223242526272829= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result=[] queue=collections.deque() queue.append(root) \#visited=set(root) 在二叉树的层序遍历中可省，但是在图中这句是必须的，否则会访问重复的节点 while queue: level_size=len(queue) cur_level=[] for _ in range(level_size): node = queue.popleft() cur_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(cur_level) return result python3–DFS123456789101112131415class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] self.result = [] self._dfs(root,0) return self.result def _dfs(self, root: TreeNode, level): if not root: return if len(self.result)&lt;level+1: self.result.append([]) self.result[level].append(root.val) self._dfs(root.left,level+1) self._dfs(root.right,level+1) 总结非常经典的题，以至于在数据结构这门专业课中都有专门介绍的经典算法，但是即使在已经学习过思想的情况下，写起来依旧有很多值得注意的点。经典的solution是我们的BFS，也顺应我们的通常思维，通过一个队列来一层一层的存储树中的节点，每次内层循环都是每层的长度，值得注意的是图的层序遍历也可以这么做，不过需要多加一个visited的set用于判断是否重复（这是树中没有的操作因为树不会有循环结构） 另一方面，发现了DFS的做法，说实话DFS非常的反正常思维，但是确实可行，而且利用递归代码还显得更为简洁，我参考视频中大牛的思路写了python3的版本，将java版本留下以后复习再写。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House Robber lc198]]></title>
    <url>%2F2019%2F09%2F08%2F20190908-lc198%2F</url>
    <content type="text"><![CDATA[题目描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber python31234567class Solution: def rob(self, nums: List[int]) -&gt; int: pre = 0 cur = 0 for i in nums: cur, pre = max(pre+i,cur),cur return cur java123456789101112class Solution &#123; public int rob(int[] nums) &#123; int preMax = 0; int curMax = 0; for(int i:nums)&#123; int temp = curMax; curMax = Math.max(preMax+i,curMax); preMax = temp; &#125; return curMax; &#125;&#125; 总结个人感觉又是一道扮猪吃老虎的lc简单题，看到easy的标签让人觉得可以通过循环遍历来处理解决它，但其实通常的循环遍历并不能解决这个题，它其实是个典型的动态规划思想的题，通过从数组长度1开始拓展，每次规划取最优解。没错这种不使用递归的简单动态规划似乎又可以被想成一种数学归纳的方法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diameter of Binary Tree lc543]]></title>
    <url>%2F2019%2F09%2F07%2F20190907-lc543%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/diameter-of-binary-tree python3–递归123456789101112131415161718192021222324= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: res = 0 def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: if root == None: return 0 self.depth(root) return self.res def depth(self, root: TreeNode): if root == None: return 0; l = self.depth(root.left) r = self.depth(root.right) if l + r &gt; self.res: self.res = l + r return max(l, r) + 1 java–递归12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; int res=0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null) return 0; depth(root); return res; &#125; public int depth(TreeNode root)&#123; if(root == null) return 0; int r = depth(root.right); int l = depth(root.left); if(r + l &gt; res) res = r + l; return Math.max(r, l)+1; &#125;&#125; 总结本题是一道leetcode简单难度的题，思路比较明确那就是利用递归的思想每次对于一个节点都要获取它的左右子树的最大深度然后暂存这两个值的和，并且每次返回的是两者中的较大的值供上层递归使用，这题比较奇特的地方在于它虽然利用递归但是并不能靠递归的返回值累加来获得最终的结果，需要创建一个全局变量并且在整个递归的过程中维护这个全局变量的值，它才是我们最终的res，所以我抱着传统的递归思路去做这个题的时候总感觉思路很清晰却总有点问题，最后看了评论区大佬的思路才恍然大悟，所以说思路不能固化，即使是递归也有不同的用法。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 teaching experience]]></title>
    <url>%2F2019%2F08%2F30%2F20190830%2F</url>
    <content type="text"><![CDATA[前言由于这周回了一条天国的微信消息被老师派遣去干苦力教一名高中生python3编程，并且自己的python3也就是个半吊子于是乎一周都沉浸在现学现卖赶制第二天ppt的劳累生活之中，算是尝试了一把新人老师的心酸生活。 但是，另一个角度来说我也又过了一遍python3的基础语法，可以说收获还是有的。由于本科是c语言作为第一门编程语言学习语法，所以母语思维就是静态语言类型，后来学c++，java可以说由于同是静态语言差别并不大。而python是在大三的时候企业工程实践老师在介绍Jquery和Flask时提到让我们学，当时也没有系统的教我们，只是在用到的部分就去查这样的填补式学习，而这一周算是让我补上了以前缺失的基础部分知识。 安装与使用自己用的macos所以有自带python2.7，但是教学需要还是重新下载覆盖了python3.7，使用的是python3.7版本的anaconda，记得以前本科时使用opencv2踩过坑，当时傻白甜的下载了官网python并自己导入包，老师就说过可以用anaconda。如今才知道anaconda是个python开源版本&amp;包管理工具，如果可以回到从前我一定拍死自己= =。 下载anaconda就意味着python3.7和一些IDE都已经下载好了，配置一下环境变量即可覆盖2.7并使用，python环境变量配置比较简单就略过吧。值得一题的是Jupyter notebook这个IDE，作为新手的IDE来说确实不错，不需要适应新的客户端，网页端就可以用，基础功能也比较全面，非常时候新手学习使用。而且anaconda自带，也不需要另外下了。 动态语言python的优势作为我接触的第一个动态编程语言，python给我的第一感觉是不可思议的，相比之下java就显得严格且死板。 首先接触到的区别在于python对于基础类型的自动转换，使得我们不需要通过基础类型关键字去创建变量，并且可以批量赋值十分灵活。 12345678910===python3x, y=1, 1.2x, y='1', '1.2'===javaint x=1;float y=1.2char z='1'String x="1.2"//......wdnmd 其次python灵活丰富的方法以及运算符重载使得可操作性极其强大，你不仅可以用+号去拼接字符串，还可以去拼接list，set等，用-号去操作set等。而这些高级数据结构的重载在java中是没有的，你只能手动去实现。。。 python与java在看了一周python的基础语法后我发现作为一门OOP语言python与java其实在基础语法方面基本是一致的，只是形式不同，python使用冒号：以及严格的缩进区分方法体，类内容等，同时加不加分号；作为结束都是不影响的。而java使用大括号{}区分方法体和类的内部，并且严格的要求在变量定义和创建参数列表时使用基础类型关键字，并且每一条语句需要分号；结束。 当然除了格式的不同，它们在基础语法的部分也是有一定差别的第一、python中没有char类型的概念，全部使用string类型，也没有数组int[]的概念全部使用list。可以说更加简洁方便 第二、python中没有java中的这种常用for循环用法 123for(int i=0;i&lt;nums.length;i++)&#123; ......&#125; 取而代之的是配合range的for循环，两者功能一致，而且都非常好用 12for i in range(nums): ...... 第三、python的类变量区分为class variables 和 instance variables。而java中与之对应的是static关键字修饰的静态成员变量以及普通成员变量。两种语言的变量相互对应起来功能类似，但是又有细微的区别。 1234567891011===pythonclass Shark(): \# class variable type="fish" def __init__(self, name): \# instance variable self.name = names1=Shark("Lucy")s2=Shark("Lily")s1.type="food" 如果我执行以上的语句，如果是java的静态成员变量，那么s2的type属性会同步成”food”，但是在python中不会，python会认为s1并没有权限修改class variable因此在执行修改时将s1的type属性降级成instance variable从而成为s1专属的成员变量，而不会影响其他Shark对象的type属性。简单说来python拒绝类对象对类变量执行重新赋值“=”的操作，会导致变量类型的转换（我理解为权限的降级），但是以下的修改语句是被允许的 123456class Shark(): num=[1,2,3]s1=Shark()s2=Shark()s1.num.append(4) 可以理解为类对象可以修改但不能重新赋值类变量，这种行为比较奇特也是java中没有的，我暂时还不知道为什么python会有这样的特性。 总结这一周时间都贡献给了python，既没有新技术栈的学习，也没有踩坑解惑的经历，只是回顾了以前的知识并补ß上一些空白，最初的两天我是很不爽的，我觉得这完全是浪费时间，然而现在我觉得这还是有意义的，而且是我以前很少做的事，知识在回顾的时候可能学到更多，而且可以加深自己以前的理解。总的来说这一周不亏。马上后天研究生开学了，期待一个新的生活吧。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ+Mqtt enable publisher/subscriber]]></title>
    <url>%2F2019%2F08%2F17%2F20190817-tec%2F</url>
    <content type="text"><![CDATA[前言这周有空余时间于是补了一下上周的week4任务中的ActiveMQ使用，本来想下载apache apollo的，但是发现apache官网已经没有了apollo的下载提供，短暂的尝试寻找资源后放弃了，反正一脉相承，又是官网主推的，那么就用ActiveMQ代替学习吧。但是不得不说最新版本东西的可借鉴博客真的少的可怜，基本都是讲apollo的，我结合apollo类似部分以及啃官方文档总算是大概用起来了。 经历安装与启用本来还在官网下载了一下ActiveMQ的最新版本然后手动移动解压文件后来一拍脑袋，有homebrew不用的都是傻子，于是删掉后shell里一行装好，不得不说homebrew是真的香啊，不枉我上周踩了好久坑才装好。 1brew install activemq 安装好以后直接用activemq命令就可以开启和关闭服务 12activemq startactivemq stop 这里有一点，启动后官方文档说shell中会有启动的web页面端口号，但是我自己启动并没有发现有端口号提示，一开始是看网上的博主的默认端口号打开的网页端，后来知道activemq的文件家中/../conf文件夹中有activemq的所有配置文件，包括默认用户名密码，网页默认端口，各种连接方式端口等等，都可供修改。 启动服务后，打开网页url输入用户名密码就可以登陆服务端管理界面了里面有topic，queue创建管理以及连接上服务端的客户端的管理，已有订阅者的管理等等。 实现subscriber/publisher在上一步开启服务进入服务页面后，我还使用了两个客户端和它进行连接，分别是：1、mqttfx，之前学mqtt的时候下的，当时没用上现在用了，通过activemq提供的mqtt端口接入，填好mqttfx的信息后connect建立连接。就可以实现订阅topic和向topic publish信息。2、下载的activemq文件夹中有提供相应的简易客户端用于test，我使用了example文件夹下mqtt/websocket的客户端，就一个html页面，页面极度简单，填完连接信息connect后就一个输入框一个按钮一个显示框，像极了刚学C# winform时拖控件的我做出的第一个界面= =，不过这也算是有基本功能了，可以说是易用性极强。 两个客户端都连接上服务端后，就可以动手创建topic，订阅消息发布消息，查看mqtt这种中间件的运作模式了，动了手以后会让理论上的理解更上一层楼。 总结mqtt确实是提供了一个双向交互的中间消息队列服务，其中服务端只是做一个中转站，只要是连接上服务端的客户端，并且订阅了同一个topic，那么他们就可以通过服务端进行双向的交互，可以说非常方便。还记得以前企业工程实践课的老师让我们学socket的时候，说用socket就可以很快的实现类似qq这样的聊天软件功能，现在知道了mqtt这种中间件，看看都是封装tcp协议的东西，如果只是实现聊天的话mqtt这边用现成的客户端一行代码都不用敲= =。]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PES-Gmair drift]]></title>
    <url>%2F2019%2F08%2F16%2F20190816-tec%2F</url>
    <content type="text"><![CDATA[前言暑假提前来到学校也跟着学长的开发任务做了些事，大概是一周前还做着开发任务，隔了一周配置本地项目又是不知所措，好多熟悉的bug又遗忘了怎么处理，关键是自己寻找问题解决方案的能力还很有待提高总是浪费很多时间才能解决，总是去问学长又太麻烦他，以后我会将每一段时间的项目经验总结在这里，方便回顾学习，温故而知新。 这次主要是springboot+springcloude+mybatis的果麦新风drift模块的开发，需要给订单order对应的快递单号express功能接口的实现，中间碰了很多坑。 踩坑经历1、本地与服务器的配置不同与冲突这一部分是每次git pull整合本地代码以后都要做的事，已经习惯了如何处理倒是没有花费太多的时间，首先检查eureka-server端的properties文件，写一个自己想用的端口号，并且做一些常规的处理 1234567#spring.profiles.active=test 这一行是服务端代码，用于选择需要的properties版本server.port=8080eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 然后检查需要开发的drift模块的properties文件 12345678910111213server.port=8000spring.application.name=drift-agenteureka.client.healthcheck=trueeureka.client.service-url.defaultZone=http://127.0.0.1:8080/eureka/mybatis.config-location=classpath:mybatis-config.xmlspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/gmair_drift?useLegacyDatetimeCode=false&amp;serverTimezone=CTT&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=shuge888 以及pom文件中的架包依赖，这主要是修改本地与服务端使用的不同版本的架包依赖，例如我们服务端中mysql的drive驱动版本是6.0.6，但是我本地的mysql版本较新需要使用新一些的drive驱动例如8.0.11否则本地运行会报错。 这里要着重说的是common模块中lombok版本不匹配问题影响了我很长时间，最后是麻烦学长才解决的，lombok是用于自动添加实体类get()/set()方法的工具，但是服务器上的java9版本的lombok版本却与我本地的java11冲突，导致maven重新生成target文件夹失败，进而导致mybatis的XML文件中引用枚举类型enum的handler失败，需要修改lombok架包版本才能解决这一系列的问题。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--这条语句是老版本lombok没有的，但是缺少这条语句又是不行的--&gt;&lt;/dependency&gt; Addition:我对maven的命令使用也不熟悉，常用命令还是要牢记的，例如清理maven后重新安装项目以及依赖的命令；maven打包命令 123mvn -U clean installmvn package 2、总体项目进度带来的对其他模块的依赖在一周前还可以本地运行的项目一周后就不行了，因为总的项目进度在向前，开发的模块可能加入了对其他开发者模块的依赖，例如我这次添加的wechat.properties以及sesame.properties。这两个配置文件缺失的话就无法运行项目，前者是微信模块，可以直接创建一个新的文件里面的内容部分留空也可以运行；后者则是alipay相关模块，里面需要内容，这一部分问学长要了一下填上也就解决了。 3、自己编程造成的bug这一部分我是没有想到的，由于昨天是12点前开始写到1点半写完的接口（别问我之前干嘛去了，我也不知道我的时间去哪儿了= =），在第二天提交后测试的时候发现两处致命的错误。。。（没错有一处还是拼写错误），这两处错误精妙的没有引起编译报错，又确实的造成了软件错误，因为这两处错误一处出在xml文件中的拼写错误，另一处是写Express实体类的时候忘记extend Entity基础类了导致实体缺了两个公共属性。 回想起来这是真的蠢，再次提醒自己编码一定要细致，尽量在自己精力充沛的时候进行开发任务，不然会出很多错。 新学到的东西java中的枚举类型enum早就知道有这么个东西了，但是一直都没有自己用过，这次在开发任务中碰到也算是学习了一下，首先枚举类型的构造十分简单，和class类似。 123456789101112131415161718192021public enum ExpressStatus implements EnumValue &#123; DELIVERED(0),BACk(1); private int value; ExpressStatus(int value)&#123;this.value=value;&#125; public static ExpressStatus valueOf(int value)&#123; //这个方法是重载的，用于枚举值和实际值int转换 switch (value)&#123; case 0: return DELIVERED; case 1: return BACk; default: return null; &#125; &#125; @Override public int getValue()&#123;return value;&#125;&#125; 定义后在后端代码中正常使用即可，主要的不同在于mybatis的xml文件中与数据库表的映射需要调用一个handler处理，在insert方法中调用系统的EnumOrdinalTypeHandler即可正常转换插入 123456789&lt;insert id="insert" parameterType="finley.gmair.model.drift.Express" useGeneratedKeys="false"&gt; insert into gmair_drift.order_express (order_id, express_id, express_status, company, block_flag, create_time) VALUES (#&#123;orderId&#125;, #&#123;expressId&#125;, #&#123;status, typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;company&#125;, #&#123;blockFlag&#125;, #&#123;createAt&#125;)&lt;/insert&gt; 这样可以保证数据插入的正常，但是想要正常的获取数据还需要我们自己写一个handler用于数据的检验和转换，这个handler类的编写是继承并实现系统提供的abstract class，第一眼看上去好像代码很复杂但是其实都是根据实际情况overwrite，而且逻辑简单，只是抽象类的方法体比较陌生，但是其实并不难。这个ExpressStatusHandler的代码较长而且就是实现抽象类就不贴了，写好以后在mybatis中的xml文件中的”resultMap”映射标签中提供这个handler就ok了 1234567&lt;resultMap id="expressVo" type="finley.gmair.model.drift.Express"&gt; &lt;result property="orderId" column="order_id"&gt;&lt;/result&gt; &lt;result property="expressId" column="express_id"&gt;&lt;/result&gt; &lt;result property="company" column="company"&gt;&lt;/result&gt; &lt;result property="status" column="express_status" typeHandler="finley.gmair.mybatis.handler.ExpressStatusHandler"&gt;&lt;/result&gt;&lt;/resultMap&gt; 这样就实现了枚举类与数据库交互的转换。 总结学习总是难受的过程，拿到任务我也总是会畏难，拖啊拖的，但是其实碰到的困难有多难克服并总结后的收获就有多大。今天是8月16号，离开学也就剩两周时间了，希望自己能好好抓紧时间少摸鱼多锄地！]]></content>
      <categories>
        <category>project experience</category>
      </categories>
      <tags>
        <tag>project experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree lc538]]></title>
    <url>%2F2019%2F08%2F14%2F20190814-lc538%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this: 5 / 2 13 Output: The root of a Greater Tree like this: 18 / 20 13 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree python3–lastOrder递归1234567891011121314151617= Definition for a binary tree node.= class TreeNode:= def __init__(self, x):= self.val = x= self.left = None= self.right = Noneclass Solution: count=0; def convertBST(self, root: TreeNode) -&gt; TreeNode: if root: root.right=self.convertBST(root.right); root.val=root.val+self.count; self.count=root.val; root.left=self.convertBST(root.left); return root; return None; java–lastOrder非递归12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int count=0; public TreeNode convertBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack(); //stack.add(root);这里不需要，但是留在这里作为经典后序非递归做法参考 TreeNode node=root; while(node!=null||!stack.isEmpty())&#123; while(node!=null)&#123; stack.add(node); node=node.right; &#125; node=stack.pop(); node.val+=count; count=node.val; if(node.left!=null) node=node.left; else node=null; &#125; return root; &#125;&#125; 总结本题是一道leetcode简单题，使用后序遍历的递归写法就非常容易实现，但是我把它放在这里希望自己也能记住后序遍历的非递归实现，记得在考研专业课准备的时候第一次了解三序遍历的递归以及非递归实现，当时由于只是看书没有敲代码实现只能勉强的理解后序遍历的非递归做法，今天做题做到感觉非常亲切，似乎是个老朋友的感觉，并且比以前更加熟悉了。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求众数 lc169]]></title>
    <url>%2F2019%2F08%2F07%2F20190807-lc169%2F</url>
    <content type="text"><![CDATA[题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element java–sort+map+摩尔投票法sort后一次遍历处理，时间复杂度O(NlogN)12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; //if(nums==null)return 0;题目保证不会出现的情况 if(nums.length==1)return nums[0]; int count=1; Arrays.sort(nums); for(int i=0;i&lt;nums.length-1;i++) &#123; if(nums[i]==nums[i+1]) count++; else &#123; if(count&gt;nums.length/2) return nums[i]; else count=1; &#125; &#125; return count&gt;nums.length/2?nums[nums.length-1]:0; &#125;&#125; map一次遍历存储后输出即可，时间复杂度O(N)123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; map=new HashMap(); for(int x:nums)&#123; if(map.containsKey(x)) map.put(x,map.get(x)+1); else map.put(x,1); &#125; for(int x:map.keySet())//keySet方法返回key的集合set if(map.get(x)&gt;nums.length/2) return x; return 0; &#125;&#125; 摩尔投票法O(N)1234567891011121314151617class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int maj = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (maj == nums[i]) count++; else &#123; count--; if (count == 0) &#123; maj = nums[i + 1]; &#125; &#125; &#125; return maj; &#125;&#125; python本题投机取巧法（如果有唯一众数，那一定是排序后的中位数） 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2]; 总结本题是leetcode中的简单难度题，只是求解的话比较容易。 但是本题实际可用的方法非常多，对于求每个元素出现的次数第一反应应该是map的方法，同时本题可用的摩尔投票法也是非常亮眼，与map同级别的时间复杂度并且在本题表现中要更好 而且除了我放进来的方法以外其实还有分治的方法也能解决（O(NlogN)），希望自己能从多角度思考问题，学习多种方法解决问题。]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pow(x,n) lc50]]></title>
    <url>%2F2019%2F08%2F06%2F20190806-lc50%2F</url>
    <content type="text"><![CDATA[题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000 示例 2:输入: 2.10000, 3输出: 9.26100 示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n java–非递归分治循环123456789101112class Solution &#123; public double myPow(double x, int n) &#123; double res=1.0; for(int i=n;i!=0;i=i/2) &#123; if(i%2!=0) res*=x; x*=x; &#125; return n&gt;0?res:1/res; &#125;&#125; python–递归123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x, n = 1/x, -n; if not n: #recursion termination return 1; if n % 2: return x*self.myPow(x, n-1); return self.myPow(x*x, n/2); 总结本题主要在于如何用较好的时间复杂度求解，主要是分治法的使用和递归。需要注意的有两点：一、n为负数时的情况，个人感觉直接进行一次判断后执行「x, n = 1/x, -n」比较方便。二、在递归或者分治循环的过程中要判断n为奇数还是偶数，进行if判断即可。tip：注意递归写法的重要习惯————递归终止语句]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-recursion(divide conquer)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝叶斯理解+实例]]></title>
    <url>%2F2019%2F08%2F05%2F20190805%2F</url>
    <content type="text"><![CDATA[什么是贝叶斯英国数学家托马斯·贝叶斯在一篇论文中，为了解决一个“逆概率”问题，而提出了贝叶斯定理。 在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，比如举办了一个抽奖，抽奖桶里有10个球，其中2个白球，8个黑球，抽到白球就算你中奖。你伸手进去随便摸出1颗球，摸出中奖球的概率是多大。（2/10）而贝叶斯在他的文章中是为了解决一个“逆概率”的问题。比如上面的例子我们并不知道抽奖桶里有什么，而是摸出一个球，通过观察这个球的颜色，来预测这个桶里里白色球和黑色球的比例。 贝叶斯案例有两个一模一样的碗1号碗里有：30个巧克力和10个水果糖2号碗里有：20个巧克力和20个水果糖然后把碗盖住。随机选择一个碗，从里面摸出了一个巧克力。问题：这颗巧克力来自1号碗的概率是多少？（即，在随即取一个碗并从中摸出了一个巧克力的情况下，这个碗是1号碗的概率） 第1步，分解问题1）要求解的问题：取出的巧克力，来自1号碗的概率是多少？来自1号碗记为事件A1，来自2号碗记为事件A2取出的是巧克力，记为事件B，那么要求的问题就是P(A1|B)，即取出的是巧克力，来自1号碗的概率 2）已知信息：1号碗里有30个巧克力和10个水果糖2号碗里有20个巧克力和20个水果糖取出的是巧克力 第2步，应用贝叶斯定理1）求先验概率由于两个碗是一样的，所以在得到新信息（取出是巧克力之前），这两个碗被选中的概率相同，因此P(A1)=P(A2)=0.5,(其中A1表示来自1号碗，A2表示来自2号碗)这个概率就是’先验概率’，即没有做实验之前，来自一号碗、二号碗的概率都是0.5。 2）求可能性函数P(B|A1)/P(B)其中，P(B|A1)表示从一号碗中(A1)取出巧克力(B)的概率。因为1号碗里有30个水果糖和10个巧克力，所以P(B|A1)=30/(30+10)=75%P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)=0.75*0.5+20/(20+20)*0.5=62.5%所以，可能性函数P(A1|B)/P(B)=75%/62.5%=1.2可能性函数&gt;1.表示新信息B对事情A1的可能性增强了。 3）带入贝叶斯公式求后验概率将上述计算结果，带入贝叶斯定理，即可算出P(A1|B)=60%这个例子中我们需要关注的是约束条件：抓出的是巧克力。如果没有这个约束条件在，来自一号碗这件事的概率就是50%了，因为巧克力的分布不均把概率从50%提升到60%。]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最近公共祖先 lc236]]></title>
    <url>%2F2019%2F08%2F02%2F20190802-lc236%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree java–递归1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==p||root==q) return root; TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left==null) return right; if(right==null) return left; return root; //return left==null?right:right==null?left:root; &#125;&#125; 思路：1、如果root就是p或q则root必定就是最近公共祖先2、如果1为false并且p，q分别在root的左右子树中，那么这种情况root就是最近公共祖先3、如果1，2都为false，那么p，q一定都在root的左（右）子树中，那么root一定就不是最近公共祖先了，候选人改为root.left(right)进行递归操作继续寻找即可 总结一定要好好理解递归操作，递归可以大大简化代码量，合适的递归操作也可以使得时间复杂度较低，本题的递归操作就只需要一遍遍历树，时间复杂度为O(N)，但是比较巧妙，要注重理解，最后的注释是用来简化的代码的迭代三目运算符，等效于最后的if判断，替换后代码更简洁但是消耗会略有增加。 拓展 lc235二叉搜索树的最近公共祖先与本题类似，也可以完全用通用树的方法求解，但是有了二叉搜索树的特性，可以利用这一特性快速求解，比较简单就不多赘述了 123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) return lowestCommonAncestor(root.left,p,q); if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125;]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some Daliy Complaint]]></title>
    <url>%2F2019%2F08%2F01%2F20190801%2F</url>
    <content type="text"><![CDATA[Feeling boring and tired after a period of time full of struggling study, especially faced with other bothering business.I think it’s common in everyone’s life, and I just want to change this situation as soon as possible.Wish a good morning.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证二叉搜索书 lc98]]></title>
    <url>%2F2019%2F07%2F30%2F20190730-lc98%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree 思路1:中序遍历二叉树，生成序列如果升序则true，else false思路2:递归，每次判断右子树最小值，左子树最大值与根节点val的逻辑关系，然后进行递归 python3–语言优势递归生成中序序列1234567891011121314151617‘’‘ Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None’‘’class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: o=self.inorder(root); return o==list(sorted(set(o)));#注意如果树中出现重复，那么一定不符合二叉搜索树 def inorder(self,root: TreeNode) -&gt; list: if root is None: return []; return self.inorder(root.left)+[root.val]+self.inorder(root.right); java–经典的非递归中序遍历，使用前一项判断123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); double pre=-Double.MAX_VALUE;//万恶的leetcode测试用例，写Integer.MIN_VALUE也会用例报错 while(!stack.isEmpty()||root!=null) &#123; while(root!=null) &#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(root.val&lt;=pre) return false; pre=root.val; root=root.right; &#125; return true; &#125;&#125; 总结感觉是比较经典的题，尽量完全熟悉递归，非递归方法；中序序列判断升序或者记录前节点两种做法]]></content>
      <categories>
        <category>algorithm practise</category>
      </categories>
      <tags>
        <tag>algorithm-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Attempt]]></title>
    <url>%2F2019%2F07%2F28%2F20190728%2F</url>
    <content type="text"><![CDATA[I am trying to learn more about the hexo to get my blog better,and I want to get a habit to record my achievement here!]]></content>
      <categories>
        <category>Introduction</category>
      </categories>
      <tags>
        <tag>It&#39;s my first time to try to write sth here!</tag>
      </tags>
  </entry>
</search>
